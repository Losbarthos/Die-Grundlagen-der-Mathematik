%
% expl3_prop_demo.tex
%

\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{xparse}
\usepackage{expl3}
\usepackage{geometry}
\geometry{margin=2.2cm}
\usepackage{listings}
\lstset{language=[LaTeX]TeX,basicstyle=\ttfamily\small,columns=fullflexible,
        numbers=left,numberstyle=\scriptsize,numbersep=8pt,breaklines=true}

\newcommand{\code}[1]{\texttt{\detokenize{#1}}}

% --- expl3-Teil: Glossar mit prop ---
\ExplSyntaxOn

% 1) Datenstruktur: Property-Liste (Key -> Value)
\prop_new:N \g_demo_glossary_prop % global: überlebt Umgebungen

% 2) Hilfsvariablen
\tl_new:N   \l_demo_tmp_tl

% 3) Eintrag hinzufügen/ersetzen (lokal vs. global)
\cs_new_protected:Nn \demo_gloss_put:nn
  { \prop_put:Nnn  \g_demo_glossary_prop { #1 } { #2 } } % lokal (innerhalb von Gruppen)
\cs_new_protected:Nn \demo_gloss_gput:nn
  { \prop_gput:Nnn \g_demo_glossary_prop { #1 } { #2 } } % global (über Gruppen hinaus)

% 4) Nur falls neu (kein Überschreiben bestehender Keys)
\cs_new_protected:Nn \demo_gloss_put_if_new:nn
  { \prop_put_if_new:Nnn \g_demo_glossary_prop { #1 } { #2 } }

% 5) Eintrag entfernen
\cs_new_protected:Nn \demo_gloss_remove:n
  { \prop_gremove:Nn \g_demo_glossary_prop { #1 } } % globales Entfernen

% 6) Abfrage mit Fallback-Text
\cs_new_protected:Nn \demo_gloss_get_or:nN
  {
    % #1 = key, #2 = tl-Variable für Ergebnis
    \prop_get:NnNTF \g_demo_glossary_prop { #1 } #2
      { }                                   % Key vorhanden: #2 gesetzt
      { \tl_set:Nn #2 { \emph{(unbekannt)} } } % sonst Fallback
  }

% 7) Benutzerkommandos (user-level)
% \defgls{<key>}{<wert>} – lokal überschreibend
\NewDocumentCommand \defgls { m m }
  { \demo_gloss_put:nn { #1 } { #2 } }

% \gdefgls{<key>}{<wert>} – global überschreibend
\NewDocumentCommand \gdefgls { m m }
  { \demo_gloss_gput:nn { #1 } { #2 } }

% \defglsIfNew{<key>}{<wert>} – nur wenn Key noch nicht existiert
\NewDocumentCommand \defglsIfNew { m m }
  { \demo_gloss_put_if_new:nn { #1 } { #2 } }

% \gls{<key>} – Wert ausgeben (oder "(unbekannt)")
\NewDocumentCommand \gls { m }
  {
    \demo_gloss_get_or:nN { #1 } \l_demo_tmp_tl
    \l_demo_tmp_tl
  }

% \printglossary – alle Paare "key = value" ausgeben
\NewDocumentCommand \printglossary { }
  {
    \par\smallskip
    \textbf{Glossar: }
    \prop_if_empty:NTF \g_demo_glossary_prop
      { \emph{leer} }
      {
        \prop_map_inline:Nn \g_demo_glossary_prop
          { \texttt{##1} = ##2 \quad }
      }
  }

% \clearglossary – Liste leeren (global)
\NewDocumentCommand \clearglossary { }
  { \prop_gclear:N \g_demo_glossary_prop }

% \removegls{<key>} – Eintrag entfernen (global)
\NewDocumentCommand \removegls { m }
  { \demo_gloss_remove:n { #1 } }

\ExplSyntaxOff
% --- Ende expl3-Teil ---

\title{Kleines \texttt{expl3}-Beispiel mit \texttt{prop} (Property-Listen)}
\author{}
\date{}

\begin{document}
\maketitle

\section*{1.\;Demo-Ausgabe}
Wir legen ein paar Einträge an und zeigen sie direkt (Echo) — zusätzlich folgt darunter die Gesamtausgabe:

\begin{itemize}
  \item \gdefgls{Monoid}{Halbgruppe mit neutralem Element}%
        \quad \texttt{Monoid} := \gls{Monoid}
  \item \defglsIfNew{Gruppe}{Monoid mit Inversen}%
        \quad \texttt{Gruppe} := \gls{Gruppe}
  \item \defglsIfNew{Gruppe}{(wird NICHT überschrieben)}%
        \quad \texttt{Gruppe} := \gls{Gruppe}
  \item \defgls{Ring}{Abel’sche Gruppe (+) mit Multiplikation}%
        \quad \texttt{Ring} := \gls{Ring}
\end{itemize}

\printglossary

\medskip
\noindent\textbf{Abfrage:} \verb|\gls{Gruppe}| $\Rightarrow$ \gls{Gruppe}; \quad
\verb|\gls{Feld}| $\Rightarrow$ \gls{Feld} % unbekannt -> Fallback

\medskip
\noindent\textbf{Entfernen und Leeren:}
Wir entfernen \enquote{Ring} und geben erneut aus.
\removegls{Ring} \par
\printglossary

\clearglossary \par
\printglossary

\bigskip
\noindent\rule{\linewidth}{0.4pt}

\section*{2.\;Quelltext des Beispiels (mit Zeilennummern)}
\medskip
\begin{lstlisting}
%
% expl3_prop_demo.tex
%

\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{xparse}
\usepackage{expl3}
\usepackage{geometry}
\geometry{margin=2.2cm}
\usepackage{listings}
\lstset{language=[LaTeX]TeX,basicstyle=\ttfamily\small,columns=fullflexible,
        numbers=left,numberstyle=\scriptsize,numbersep=8pt,breaklines=true}

\newcommand{\code}[1]{\texttt{\detokenize{#1}}}

% --- expl3-Teil: Glossar mit prop ---
\ExplSyntaxOn

\prop_new:N \g_demo_glossary_prop
\tl_new:N   \l_demo_tmp_tl

\cs_new_protected:Nn \demo_gloss_put:nn
  { \prop_put:Nnn  \g_demo_glossary_prop { #1 } { #2 } }
\cs_new_protected:Nn \demo_gloss_gput:nn
  { \prop_gput:Nnn \g_demo_glossary_prop { #1 } { #2 } }

\cs_new_protected:Nn \demo_gloss_put_if_new:nn
  { \prop_put_if_new:Nnn \g_demo_glossary_prop { #1 } { #2 } }

\cs_new_protected:Nn \demo_gloss_remove:n
  { \prop_gremove:Nn \g_demo_glossary_prop { #1 } }

\cs_new_protected:Nn \demo_gloss_get_or:nN
  {
    \prop_get:NnNTF \g_demo_glossary_prop { #1 } #2
      { }
      { \tl_set:Nn #2 { \emph{(unbekannt)}} }
  }

\NewDocumentCommand \defgls { m m }
  { \demo_gloss_put:nn { #1 } { #2 } }
\NewDocumentCommand \gdefgls { m m }
  { \demo_gloss_gput:nn { #1 } { #2 } }
\NewDocumentCommand \defglsIfNew { m m }
  { \demo_gloss_put_if_new:nn { #1 } { #2 } }
\NewDocumentCommand \gls { m }
  {
    \demo_gloss_get_or:nN { #1 } \l_demo_tmp_tl
    \l_demo_tmp_tl
  }
\NewDocumentCommand \printglossary { }
  {
    \par\smallskip
    \textbf{Glossar: }
    \prop_if_empty:NTF \g_demo_glossary_prop
      { \emph{leer} }
      {
        \prop_map_inline:Nn \g_demo_glossary_prop
          { \texttt{##1} = ##2 \quad }
      }
  }
\NewDocumentCommand \clearglossary { }
  { \prop_gclear:N \g_demo_glossary_prop }
\NewDocumentCommand \removegls { m }
  { \demo_gloss_remove:n { #1 } }

\ExplSyntaxOff
% --- Ende expl3-Teil ---

\title{Kleines \texttt{expl3}-Beispiel mit \texttt{prop} (Property-Listen)}
\author{}
\date{}

\begin{document}
\maketitle

\section*{1.\;Demo-Ausgabe}
\begin{itemize}
  \item \gdefgls{Monoid}{Halbgruppe mit neutralem Element}%
        \quad \texttt{Monoid} := \gls{Monoid}
  \item \defglsIfNew{Gruppe}{Monoid mit Inversen}%
        \quad \texttt{Gruppe} := \gls{Gruppe}
  \item \defglsIfNew{Gruppe
  }{(wird NICHT ueberschrieben)}%
        \quad \texttt{Gruppe} := \gls{Gruppe}
  \item \defgls{Ring}{Abelsche Gruppe (+) mit Multiplikation}%
        \quad \texttt{Ring} := \gls{Ring}
\end{itemize}

\printglossary

\medskip
\textbf{Abfrage:} \verb|\gls{Gruppe}| $\Rightarrow$ \gls{Gruppe};
\verb|\gls{Feld}| $\Rightarrow$ \gls{Feld}

\medskip
\textbf{Entfernen und Leeren:}
\removegls{Ring} \par
\printglossary

\clearglossary \par
\printglossary

\end{document}
\end{lstlisting}

\bigskip
\noindent\rule{\linewidth}{0.4pt}

\section*{3.\;Erklärung Zeile für Zeile (mit Fokus auf \texttt{prop})}

\begin{description}
  \item[\code{\prop_new:N \g_demo_glossary_prop}]
    Legt eine \emph{Property-Liste} an (Mapping \enquote{Key $\to$ Value}). 
    Das Präfix \code{g_} deutet an, dass wir sie \emph{global} nutzen wollen.

  \item[\code{\prop_put:Nnn} vs. \code{\prop_gput:Nnn}]
    Beide setzen \enquote{Key $\to$ Value}. \code{put} ist \emph{lokal} (wirkt nur innerhalb der aktuellen Gruppe/Umgebung),
    \code{gput} ist \emph{global} (überdauert Gruppen). In diesem Beispiel verbergen die Nutzerkommandos den Unterschied: 
    \verb|\defgls| nutzt lokal, \verb|\gdefgls| global.

  \item[\code{\prop_put_if_new:Nnn}]
    Fügt nur ein, wenn der Key bisher \emph{nicht} existiert. Überschreibt also keine vorhandenen Werte – praktisch für Default-Initialisierung.

  \item[\code{\prop_get:NnNTF}]
    Liest den Wert zu \enquote{Key} in eine \code{tl}-Variable ein und verzweigt:
    \code{T}-Zweig, wenn vorhanden (Variable gefüllt), sonst \code{F}-Zweig (hier setzen wir einen Fallback \enquote{\emph{(unbekannt)}}).

  \item[\code{\prop_gremove:Nn}, \code{\prop_gclear:N}]
    Entfernt \emph{einen} Key bzw. leert die gesamte Liste – jeweils global.

  \item[\code{\prop_if_empty:NTF}]
    Testet, ob die Property-Liste leer ist und wählt entsprechend Ausgabe \enquote{leer} oder die eigentliche Liste.

  \item[\code{\prop_map_inline:Nn}]
    Iteriert über alle Paare. In der Body-Funktion stehen \verb|##1| für den Key und \verb|##2| für den Value.
\end{description}

\paragraph{Kurzfazit (Unterschiede in einem Blick):}
\[
\begin{array}{ll}
\texttt{put} \text{ vs. } \texttt{gput} & \text{lokal (gruppengebunden) vs. global (persistiert)} \\
\texttt{put\_if\_new} & \text{fügt nur ein, wenn Key noch nicht existiert (kein Überschreiben)} \\
\texttt{get\ldots T/F} & \text{Abfrage mit Verzweigung – sauberer Fallback möglich} \\
\texttt{gremove}, \texttt{gclear} & \text{gezieltes Entfernen bzw. komplettes Leeren (global)} \\
\texttt{map\_inline} & \text{einfaches Ausgeben/Verarbeiten aller Key-Value-Paare}
\end{array}
\]

\end{document}
