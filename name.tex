% main.tex (optimiert für schnelleres Kompilieren)
\documentclass{book}

% --- Packages ---
\usepackage{subfiles}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage{thmtools}
\usepackage{etoolbox}
\usepackage{longtable}
\usepackage{xparse}       % für NewDocumentCommand
\usepackage{imakeidx}
\usepackage{bussproofs}
\usepackage{multirow}
\usepackage[nameinlink,capitalise]{cleveref}

\MakeAutoQuote{„}{“}
\hypersetup{
  bookmarksopen=false,
  bookmarksnumbered=true
}

% Optionaler Turbo-Draft-Schalter (keine Syntaxänderung an deinem Dokument notwendig)
\newif\iffastcompile
% \fastcompiletrue % <- bei Bedarf für schnelle Drafts aktivieren
\iffastcompile
  \usepackage[draft]{hyperref}
  \microtypesetup{activate=false}
\fi

\input{commands.tex}

% -------------------------------
% Datei-Zähler und Theorem-Zähler
% -------------------------------
\newcounter{file}

% Theorem
\newcounter{theoremInFile}[file]
\renewcommand{\thetheoremInFile}{\arabic{file}.\arabic{theoremInFile}}
\newtheorem{theorem}[theoremInFile]{Theorem}

% Definition
\newcounter{definitionInFile}[file]
\renewcommand{\thedefinitionInFile}{\arabic{file}.\arabic{definitionInFile}}
\newtheorem{definition}[definitionInFile]{Definition}

% Axiom
\newcounter{axiomInFile}[file]
\renewcommand{\theaxiomInFile}{\arabic{file}.\arabic{axiomInFile}}
\newtheorem{axiom}[axiomInFile]{Axiom}

% Weitere Umgebungen, falls benötigt:
\newtheorem{corollary}[theoremInFile]{Korollar}
\newtheorem{lemma}[theoremInFile]{Lemma}
\newtheorem{hilfsdefinition}[theoremInFile]{Hilfsdefinition}
\newtheorem{tempdefinition}[theoremInFile]{Temporäre Definition}

% Unnummerierte Umgebungen
\theoremstyle{remark}
\newtheorem*{remark}{Bemerkung}
\newtheorem*{bemerkung}{Bemerkung}
\newtheorem*{example}{Beispiel}
\newtheorem*{hint}{Hinweis}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{notation*}{Notation}

\makeindex[name=satz,title=Sätze und Definitionen zu diesem Kapitel]

% -------------------------------
% Schneller Label-Sanitizer (expl3 + Cache)
% Ergebnis wie bisher in \temp
% -------------------------------
\ExplSyntaxOn
\prop_new:N \g__sanitize_cache_prop
\tl_new:N   \l__sanitize_work_tl

\cs_new_protected:Npn \sanitize #1
  {
    % Cache-Hit?
    \prop_get:NnNTF \g__sanitize_cache_prop {#1} \l__sanitize_work_tl
      { \tl_set_eq:NN \temp \l__sanitize_work_tl }
      {
        % Cache-Miss: berechnen
        \tl_set:Nx \l__sanitize_work_tl { \detokenize{#1} }

        % ---- Mathematische Schriftarten
        \regex_replace_all:nnN { \\mathcal } { mathcal } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\mathbb }   { mathbb }  \l__sanitize_work_tl
        \regex_replace_all:nnN { \\mathrm }   { rm }      \l__sanitize_work_tl

        % ---- Logische Verknüpfungen
        \regex_replace_all:nnN { \\leftrightarrow } { Equiv } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\rightarrow }      { Imp }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\eqvdash }         { Eqvboth }\l__sanitize_work_tl
        \regex_replace_all:nnN { \\dashv }           { DashV } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\vdash }           { Vdash } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\iff }             { Iff }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\land }            { And }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\lor }             { Or }    \l__sanitize_work_tl
        \regex_replace_all:nnN { \\neg }             { Neg }   \l__sanitize_work_tl

        % ---- Quantoren und Mengen
        \regex_replace_all:nnN { \\forall }  { Forall } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\exists }  { Exists } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\iota }    { Iota }   \l__sanitize_work_tl

        % ---- Relationen und Operatoren
        \regex_replace_all:nnN { :\= }       { Defeq }    \l__sanitize_work_tl
        \regex_replace_all:nnN { \= }        { Eq }       \l__sanitize_work_tl
        \regex_replace_all:nnN { \\neq }     { Neq }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\not }     { Notin }    \l__sanitize_work_tl
        \regex_replace_all:nnN { \\in }      { In }       \l__sanitize_work_tl
        \regex_replace_all:nnN { \\subseteq }{ Subseteq } \l__sanitize_work_tl

        % ---- Mengenoperationen
        \regex_replace_all:nnN { \\emptyset } { Emptyset } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\bigcup }   { Bigcup }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\cup }      { Cup }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\cap }      { Cap }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\bigcap }   { Bigcap }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\mid }      { Mid }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\setminus } { Setminus } \l__sanitize_work_tl

        % ---- Zahlen
        \regex_replace_all:nnN { \_ }  { Index } \l__sanitize_work_tl
        \regex_replace_all:nnN { 0 }   { Null }  \l__sanitize_work_tl
        \regex_replace_all:nnN { 1 }   { One }   \l__sanitize_work_tl
        \regex_replace_all:nnN { 2 }   { Two }   \l__sanitize_work_tl
        \regex_replace_all:nnN { 3 }   { Three } \l__sanitize_work_tl
        \regex_replace_all:nnN { 4 }   { Four }  \l__sanitize_work_tl

        % ---- Klammern (literale Zeichen)
        \regex_replace_all:nnN { \x{28} } { Lp } \l__sanitize_work_tl % (
        \regex_replace_all:nnN { \x{29} } { Rp } \l__sanitize_work_tl % )
        \regex_replace_all:nnN { \\bigl|\\bigr|\\Bigl|\\Bigr } { } \l__sanitize_work_tl

        % ---- Störendes entfernen
        \regex_replace_all:nnN { \\begin | \\end } { } \l__sanitize_work_tl
        \regex_replace_all:nnN { aligned }         { } \l__sanitize_work_tl
        \regex_replace_all:nnN { [\{\}] }          { } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\\\ }            { } \l__sanitize_work_tl
        \regex_replace_all:nnN { [\ \t] }          { } \l__sanitize_work_tl
        \regex_replace_all:nnN { \& }              { } \l__sanitize_work_tl
        % ---- Abstands-/Trenn-Kommandos und verbleibende Backslashes entfernen
        \regex_replace_all:nnN { \\\, } {} \l__sanitize_work_tl  % \,
        \regex_replace_all:nnN { \\\; } {} \l__sanitize_work_tl  % \;
        \regex_replace_all:nnN { \\\: } {} \l__sanitize_work_tl  % \:
        \regex_replace_all:nnN { \\\! } {} \l__sanitize_work_tl  % \!
        \regex_replace_all:nnN { \\quad } {} \l__sanitize_work_tl
        \regex_replace_all:nnN { \\qquad } {} \l__sanitize_work_tl
        \regex_replace_all:nnN { \\~ } {} \l__sanitize_work_tl   % \~ (geschütztes Leerzeichen)
        \regex_replace_all:nnN { \\\x{20} } {} \l__sanitize_work_tl % Backslash + Space
        % am Ende: alle übrigen Backslashes killen (Sicherheitsnetz)
        \regex_replace_all:nnN { \\ } {} \l__sanitize_work_tl

        % ---- Sonstiges
        \regex_replace_all:nnN { , }               { Comma } \l__sanitize_work_tl

        % Ergebnis bereitstellen + cachen
        \tl_set_eq:NN \temp \l__sanitize_work_tl
        \prop_gput:NnV \g__sanitize_cache_prop {#1} \temp
      }
  }
\ExplSyntaxOff

\makeatletter
\newcommand{\debugsanitize}[1]{%
  \def\tempa{#1}%
  \expandafter\sanitize\expandafter{\tempa}%
  \typeout{Ergebnis von sanitize: [\temp]}%
}
\makeatother

% -------------------------------
% Automatische Theorem/Definition/Axiom-Umgebungen
% -------------------------------
\NewDocumentCommand{\FormulaThmAuto}{o m o}{%
  \sanitize{#2}%
  \edef\lab{\temp}%
  \edef\labFull{thm\arabic{file}_\lab}%
  \IfNoValueTF{#1}
    {\begin{theorem}\label{\labFull}}%
    {\begin{theorem}[#1]\label{\labFull}}%
  \IfNoValueF{#3}{#3\par\medskip}%
  \[
    #2
  \]
  \end{theorem}%
}

\NewDocumentCommand{\FormulaDefAuto}{o m o}{%
  \sanitize{#2}%
  \edef\labD{\temp}%
  \edef\labFullD{def\arabic{file}_\labD}%
  \IfNoValueTF{#1}
    {\begin{definition}\label{\labFullD}}%
    {\begin{definition}[#1]\label{\labFullD}}%
  \IfNoValueF{#3}{#3\par\medskip}%
  \[
    #2
  \]
  \end{definition}%
}

\NewDocumentCommand{\FormulaAxiomAuto}{o m o}{%
  \sanitize{#2}%
  \edef\labA{\temp}%
  \edef\labFullA{ax\arabic{file}_\labA}%
  \IfNoValueTF{#1}
    {\begin{axiom}\label{\labFullA}}%
    {\begin{axiom}[#1]\label{\labFullA}}%
  \IfNoValueF{#3}{#3\par\medskip}%
  \[
    #2
  \]
  \end{axiom}%
}

% -------------------------------
% Referenz-Makro (schneller, mit kollisionsarmem Cache)
% -------------------------------
\crefformat{theorem}{Th[#2#1#3]}
\crefformat{axiom}{Ax[#2#1#3]}
\crefformat{definition}{Def[#2#1#3]}

\ExplSyntaxOn
\prop_new:N \g__ref_cache_prop
\tl_new:N   \l__ref_result_tl
\tl_new:N   \l__ref_raw_tl

% Hilfsfunktion: suche ersten Treffer eines Präfixes (thm/def/ax)
\cs_new_protected:Npn \__ref_find:nn #1#2
  {
    \tl_clear:N \l__ref_result_tl
    \int_step_inline:nn { \value{maxfile} }
      {
        \exp_args:Nx \cs_if_exist:cTF { r@#1##1_#2 }
          { \tl_set:Nx \l__ref_result_tl { #1##1_#2 } \prg_break: }
          { }
        \prg_break_point:
      }
  }

\NewDocumentCommand{\FormulaRefAuto}{m o g}
  {
    % rohen Eingabetext als stabilen Cache-Key verwenden
    \tl_set:Nx \l__ref_raw_tl { \detokenize{#1} }
    \edef\tempa{\unexpanded{#1}}%
    \expandafter\sanitize\expandafter{\tempa}% -> \temp
    \edef\lab{\temp}%

    % explizite Datei (#2): direkt verlinken
    \IfNoValueF{#2}
      {%
        \edef\labFull{#2_\lab}%
        \IfNoValueTF{#3}
          {\text{\hyperref[\labFull]{\cref{\labFull}}}}
          {\text{\hyperref[\labFull]{\cref{\labFull}(#3)}}}%
        \use_none: % beendet die Ausführung
      }%

    % 1) Cache nach RAW-Key abfragen
    \prop_get:NVNTF \g__ref_cache_prop \l__ref_raw_tl \l_tmpa_tl
      {
        \edef\labFull{\l_tmpa_tl}
        \IfNoValueTF{#3}
          {\text{\hyperref[\labFull]{\cref{\labFull}}}}
          {\text{\hyperref[\labFull]{\cref{\labFull}(#3)}}}%
      }
      {
        % 2) Suchen: thm -> def -> ax
        \__ref_find:nn {thm}{\lab}
        \tl_if_empty:NT \l__ref_result_tl { \__ref_find:nn {def}{\lab} }
        \tl_if_empty:NT \l__ref_result_tl { \__ref_find:nn {ax}{\lab} }

        \tl_if_empty:NTF \l__ref_result_tl
          { \text{[??]} } % nichts gefunden
          {
            \edef\labFull{\l__ref_result_tl}
            % 3) Fund unter RAW-Key cachen (kollisionsarm)
            \prop_gput:NVn \g__ref_cache_prop \l__ref_raw_tl { \labFull }
            \IfNoValueTF{#3}
              {\text{\hyperref[\labFull]{\cref{\labFull}}}}
              {\text{\hyperref[\labFull]{\cref{\labFull}(#3)}}}%
          }
      }
  }
\ExplSyntaxOff

\makeatletter
\newcounter{maxfile}
\setcounter{maxfile}{4} % <- Anzahl deiner Dateien
\makeatother

% -------------------------------
% Beweisumgebungen
% -------------------------------
\newcounter{proofstepnr}

\newenvironment{tabproof}
  {\begin{proof}\setcounter{proofstepnr}{0} \[ \begin{array}{llll} }
  {\end{array} \] \end{proof}}

\newenvironment{tabproofsplit}
  {\begin{proof}}{\end{proof}}

\newcommand{\proofpart}[1]{%
  \par\medskip\noindent #1:\par%
  \setcounter{proofstepnr}{0}%
  \[\begin{array}{llll}}

\newcommand{\closeproofpart}{%
  \end{array}\]}

\newcommand{\proofstep}[3]{%
  \stepcounter{proofstepnr}%
  #1 & (\arabic{proofstepnr}) & #2 & #3 \\}

\newcommand{\proofstepstar}[3]{%
  #1 & & #2 & #3 \\}

\newenvironment{tabproofwide}
  {\begin{proof}\setcounter{proofstepnr}{0} \[ \begin{array}{lllcll} }
  {\end{array} \] \end{proof}}

\newcommand{\proofstepwide}[4]{%
  \stepcounter{proofstepnr}%
  & (\arabic{proofstepnr}) & #1 & #2 & #3 & #4 \\}

\RenewDocumentCommand{\proofstepwide}{o m m m m}{%
  \stepcounter{proofstepnr}%
  \IfNoValueTF{#1}
    { & (\arabic{proofstepnr}) & #2 & #3 & #4 & #5 \\}
    { #1 & (\arabic{proofstepnr}) & #2 & #3 & #4 & #5 \\}
}

\RenewDocumentCommand{\proofstepwide}{s o m m m m}{%
  \IfBooleanTF{#1}{
    % Sternchen: keine Zählererhöhung, keine Nummer
    \IfNoValueTF{#2}
      { & & #3 & #4 & #5 & #6 \\}
      { #2 & & #3 & #4 & #5 & #6 \\}
  }{
    % Normalfall: Zähler erhöhen und anzeigen
    \stepcounter{proofstepnr}%
    \IfNoValueTF{#2}
      { & (\arabic{proofstepnr}) & #3 & #4 & #5 & #6 \\}
      { #2 & (\arabic{proofstepnr}) & #3 & #4 & #5 & #6 \\}
  }
}

\NewDocumentCommand{\proofstepwidestar}{o m m}{%
  \stepcounter{proofstepnr}%
  \IfNoValueTF{#1}
    { & (\arabic{proofstepnr}) & \multicolumn{3}{l}{#2} & #3 \\}
    { #1 & (\arabic{proofstepnr}) & \multicolumn{3}{l}{#2} & #3 \\}
}

\newenvironment{tabproofsplitwide}
  {\begin{proof}}{\end{proof}}

\newcommand{\proofpartwide}[1]{%
  \par\medskip\noindent #1:\par%
  \setcounter{proofstepnr}{0}%
  \[\begin{array}{lllcll}}

\newcommand{\closeproofpartwide}{%
  \end{array}\]}
% -------------------------------
% Dokumentstart
% -------------------------------
\setcounter{file}{3}

\begin{document}

\title{}
\author{}
\date{}


\chapter{Die Zermelo-Fraenkel-Axiome}
Nachdem wir die grundlegenden Begriffe und Notationen eingeführt haben, wenden wir uns nun den Zermelo-Fraenkel-Axiomen zu, die das Fundament der modernen Mengenlehre bilden. Diese Axiome definieren, wie Mengen gebildet werden können und welche Eigenschaften sie besitzen.
\begin{definition}[Begriff der Menge]
Der \textbf{Begriff der Menge} wird durch das \textbf{Element-Symbol} \(\in\) \textbf{implizit definiert}. 
Das Symbol \(\in\) ist ein binäres Prädikat, das die Mitgliedschaft zwischen einem Element und einer Menge 
ausdrückt, also \(x \in y\) bedeutet, dass \(x\) ein Element von \(y\) ist. Die Eigenschaften von \(\in\) 
werden durch die folgenden Axiome der Zermelo-Fraenkel-Mengenlehre festgelegt, welche zusammen die Menge von 
Aussagen \(\Phi(\in)\) bilden:
\end{definition}

\FormulaAxiomAuto[Extensionalität]{\forall x\, (x \in A \leftrightarrow x \in B) \eqvdash A = B}

\FormulaAxiomAuto[Leere Menge]{\exists O\;\bigl(\forall x\,(x \not\in O)\bigr)}

\FormulaDefAuto[Leere Menge]{\emptyset := \iota O\bigl(\forall x\,(x \not\in O)\bigr)}
\begin{remark}
    Hieraus gewinnen wir für alle \(x\):
    \[
    x \not\in \emptyset.
    \]
Das Symbol \(\emptyset\) wird oft verwendet, um die leere Menge zu repräsentieren. Es stammt aus der skandinavischen Schreibweise des Buchstabens "`O"' und wurde von den Mathematikern André Weil und Bourbaki eingeführt. Es ist wichtig zu beachten, dass \(\emptyset\) nur ein Symbol ist und nicht als eine Zahl oder ein anderes mathematisches Objekt betrachtet werden sollte. In der Mengenlehre repräsentiert es speziell eine Menge, die keine Elemente enthält.
\end{remark}

\FormulaThmAuto{ \exists! O\forall x (x \not\in O) }
\begin{tabproof}
  \proofstep{}{ \exists O\forall x (x \not\in O) }{ \FormulaRefAuto{\exists O\;\bigl(\forall x\,(x \not\in O)\bigr)} }
  \proofstep{2}{ \forall x (x \not\in O) }{ \rA }
  \proofstep{3}{ \forall x (x \not\in P) }{ \rA }
  \proofstep{2}{ \forall x (x \not\in O \lor x \in P) }{ \FormulaRefAuto{\forall x(F(x))\lor\forall x(G(x))\vdash\forall x(F(x)\lor G(x))} }
  \proofstep{3}{ \forall x (x \not\in P \lor x \in O) }{ \FormulaRefAuto{ \forall x(F(x))\lor\forall x(G(x))\vdash\forall x(F(x)\lor G(x))} }
  \proofstep{2,3}{ \forall x (x \in O \leftrightarrow x \in P) }{ \FormulaRefAuto{ \forall x (P(x) \leftrightarrow Q(x)) \dashv \vdash \forall x (\neg P(x) \lor Q(x)) \land \forall x (\neg Q(x) \lor P(x)) } }
  \proofstep{2,3}{ O = P }{ \FormulaRefAuto{ \forall x\, (x \in A \leftrightarrow x \in B) \eqvdash A = B } }
  \proofstep{}{ \exists! O (\forall x (x \not\in O)) }{ \UEI{1,2,3,6} }
\end{tabproof}

\FormulaAxiomAuto[Aussonderung]{\forall A\;\forall P\;\exists B\;\Bigl(\forall x\;\bigl(x \in B \;\leftrightarrow\; x \in A \,\land\, P(x)\bigr)\Bigr)}


\FormulaDefAuto[Aussonderung]{\{x\in A \,\mid\, P(x)\} := \iota B\bigl(\forall x\,(x\in B \leftrightarrow (x\in A \land P(x)))\bigr)}[Sei \(A\) eine Menge und \(P\) ein einstelliges Prädikat. Wir definieren:]
\begin{remark}
Hieraus gewinnen wir für alle \(x\) das Axiom:
\[
x \in \{x \in A \mid P(x)\} \eqvdash x \in A \land P(x).
\]    
\end{remark}

\FormulaThmAuto[Zur Eindeutigkeit]{ \forall x (x \in B \leftrightarrow P(x)), \forall x (x \in C \leftrightarrow P(x)) \vdash B = C }
\begin{tabproof}
  \proofstep{1}{ \forall x (x \in B \leftrightarrow P(x)) }{ \rA }
  \proofstep{2}{ \forall x (x \in C \leftrightarrow P(x)) }{ \rA }
  \proofstep{1,2}{ \forall x (x \in B \leftrightarrow x \in C) }{ \FormulaRefAuto{ \forall x(P(x)\leftrightarrow Q(x)), \forall x(R(x)\leftrightarrow Q(x))\vdash \forall x(P(x)\leftrightarrow R(x)) }{1,2} }
  \proofstep{1,2}{ B = C }{ \FormulaRefAuto{ \forall x\, (x \in A \leftrightarrow x \in B) \eqvdash A = B }{3} }
\end{tabproof}

\FormulaThmAuto[Eindeutigkeit der Komprehension]{ \exists B(\forall x(x \in B\leftrightarrow P(x)))\vdash \exists! B(\forall x(x \in B\leftrightarrow P(x))) }
\begin{tabproof}
  \proofstep{1}{ \exists B(\forall x(x \in B\leftrightarrow P(x))) }{ \rA }
  \proofstep{2}{ \forall x(x \in A\leftrightarrow P(x)) }{ \rA }
  \proofstep{3}{ \forall x(x \in B\leftrightarrow P(x)) }{ \rA }
  \proofstep{2,3}{ A = B }{ \FormulaRefAuto{ \forall x (x \in B \leftrightarrow P(x)), \forall x (x \in C \leftrightarrow P(x)) \vdash B = C }{2,3} }
  \proofstep{1}{ \exists! B(\forall x(x \in B\leftrightarrow P(x))) }{ \UEI{1,2,3,4} }
\end{tabproof}



\end{document}

/* Beispiele 

\FormulaThmAuto{A \subseteq B \vdash A \cap C \subseteq B \cap C}
\begin{tabproof}
  \proofstep{1}{A \subseteq B}{\rA}
  \proofstep{2}{x \in A \cap C}{\rA}
  \proofstep{2}{x \in A}{\FormulaRefAuto{x \in A \cap B \vdash x \in A}{2}}
  \proofstep{2}{x \in C}{\FormulaRefAuto{x \in A \cap B \vdash x \in B}{2}}
  \proofstep{1,2}{x \in B}{\FormulaRefAuto{A \subseteq B,\, x \in A \vdash x \in B}{1,3}}
  \proofstep{1,2}{x \in B \cap C}{\FormulaRefAuto{x \in A \cap B \eqvdash x \in A \land x \in B}{\rAI{5,4}}}
  \proofstep{1}{A \cap C \subseteq B \cap C}{\FormulaRefAuto{A \subseteq B := \forall x\,(x \in A \rightarrow x \in B)}{\rUI{\rRI{2,6}}}}
\end{tabproof}


\FormulaThmAuto{A \subseteq B \eqvdash A \cap B = A}
\begin{tabproofsplitwide}
  \proofpartwide{\(\vdash\)}
    \proofstepwidestar[1]{A \subseteq B}{\rA}
    \proofstepwidestar[]{A \cap B \subseteq A}{\FormulaRefAuto{A \cap B \subseteq A}}
    \proofstepwide{A}{=}{A \cap A}{\FormulaRefAuto{A = A \cap A}}
    \proofstepwide[1]{}{\subseteq}{A \cap B}{\FormulaRefAuto{A \subseteq B \vdash A \cap C \subseteq B \cap C}{1}}
    \proofstepwide[1]{A}{\subseteq}{A \cap B}{\rChain{3,4}}
    \proofstepwide[1]{A \cap B}{=}{A}{\FormulaRefAuto{A \subseteq B \land B \subseteq A \eqvdash A = B}{\rAI{2,5}}}
  \closeproofpartwide

  \proofpartwide{\(\dashv\)}
    \proofstepwidestar[1]{A \cap B = A}{\rA}
    \proofstepwide[1]{A}{\subseteq}{A \cap B}{\rAEb{\FormulaRefAuto{A \subseteq B \land B \subseteq A \eqvdash A = B}{1}}}
    \proofstepwide[1]{A \cap B}{\subseteq}{B}{\FormulaRefAuto{A \cap B \subseteq B}}
    \proofstepwide[1]{A}{\subseteq}{B}{\FormulaRefAuto{A \subseteq B, B \subseteq C \vdash A \subseteq C}{2,3}}
  \closeproofpartwide
\end{tabproofsplitwide}

\FormulaThmAuto{P(A) \vdash x \in \bigcap_{P(B)} B \leftrightarrow \forall C\, (P(C) \rightarrow x \in C)}
\begin{tabproofwide}
  \proofstepwidestar[1]{P(A)}{\rA}
  \proofstepwidestar[2]{\forall C\, (P(C)\rightarrow x\in C)}{\rA}
  \proofstepwidestar[]{\forall C\, (P(C)\rightarrow x\in C) \rightarrow x\in A}{\rRI{2,\FormulaRefAuto{P(a), \forall x\, (P(x) \rightarrow Q(x)) \vdash Q(a)}{1,2}}}
  \proofstepwide[1]{x\in \bigcap_{P(B)} B}{\leftrightarrow}{x\in I_A}{\rUE{\FormulaRefAuto{\forall x\, (x \in A \leftrightarrow x \in B) \eqvdash A = B}{\FormulaRefAuto{P(A) \vdash \bigcap_{P(B)} B = \{ x \in A \mid \forall D\, (P(D) \rightarrow x \in D) \}}{1}}}}
  \proofstepwide[1]{}{\leftrightarrow}{x\in A \land \forall C\, (P(C)\rightarrow x\in C)}{\FormulaRefAuto{\{x\in A \,\mid\, P(x)\} := \iota B\bigl(\forall x\,(x\in B \leftrightarrow (x\in A \land P(x)))\bigr)}{\rIE{\rUE{\DefBigcapLbAMidPLpARpRbMidSubB{}},4}}}
  \proofstepwide[1]{}{\leftrightarrow}{\forall C\, (P(C)\rightarrow x\in C)}{\FormulaRefAuto{P \rightarrow Q \vdash P \leftrightarrow (Q \land P)}{3}}
  \proofstepwide[1]{x\in \bigcap_{P(B)} B}{\leftrightarrow}{\forall C\, (P(C)\rightarrow x\in C)}{\rChain{4,6}}
\end{tabproofwide}

\FormulaThmAuto{A \subseteq C,\, B \subseteq C \vdash A \cup B \subseteq C}
\begin{tabproofwide}
  \proofstepwidestar[1]{A \subseteq C}{\rA}
  \proofstepwidestar[2]{B \subseteq C}{\rA}
  \proofstepwide{z \in A \cup B}{\rightarrow}{z \in A \lor z \in B}%
    {\FormulaRefAuto{z \in A \cup B \eqvdash z \in A \lor z \in B}}
  \proofstepwide[1,2]{}{ \rightarrow}{z \in C}%
    {\FormulaRefAuto{P \rightarrow Q,\, R \rightarrow Q,\, P \lor R \vdash Q}%
      {\rUE{\FormulaRefAuto{A \subseteq B := \forall x\,(x\in A \rightarrow x\in B)}{1}},%
       \rUE{\FormulaRefAuto{A \subseteq B := \forall x\,(x\in A \rightarrow x\in B)}{2}},3}}
  \proofstepwide[1,2]{z \in A \cup B}{\rightarrow}{z \in C}%
    {\rChain{3,4}}
  \proofstepwidestar[1,2]{A \cup B \subseteq C}%
    {\FormulaRefAuto{A \subseteq B := \forall x\,(x\in A \rightarrow x\in B)}{\rUI{5}}}
\end{tabproofwide}


*/