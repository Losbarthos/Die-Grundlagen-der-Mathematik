%============================================================
%  Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte
%============================================================

\documentclass[main.tex]{subfiles}


\title{Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte}
\author{Martin Kunze}
\date{today}

\begin{document}
\maketitle
\tableofcontents
\raggedbottom

\chapter{Aussagenlogik und Prädikatenlogik}

% =========================================================
\section{Formale Sprachen und Syntax}

In diesem Kapitel betrachten wir Logik als \emph{formale Sprache}:
Wir legen ein Alphabet von Symbolen fest und beschreiben mit
\emph{Bildungsregeln}, welche endlichen Symbolketten wir als
\emph{Formeln} zulassen. 

Die folgenden Abschnitte führen zunächst die \emph{Aussagensprache}
(Aussagenlogik) und danach die \emph{Prädikatensprache erster Stufe}
(Prädikatenlogik) ein. In beiden Fällen interessiert uns hier nur
die \textbf{Syntax} der Formeln. Fragen nach \enquote{Wahrheit} oder
\enquote{Bedeutung} der Formeln (Semantik) werden in späteren
Kapiteln behandelt.

% =========================================================
\section{Aussagen und Prädikatenlogik}

\subsection{Nichtlogische Symbole}

\paragraph{Aussagevariablen.}
Aus der Menge der uns zur Verfügung stehenden Symbole wählen wir einige
als Platzhalter und bezeichnen diese als \emph{Aussagevariablen}
(oder \emph{Aussagensymbole}). Typische Bezeichnungen sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  A & A_0 & A_1 & \dots \\
  B & B_0 & B_1 & \dots \\
  C & C_0 & C_1 & \dots
\end{array}
\]

\paragraph{Variablen.}
Typische Bezeichnungen für (individuelle) Variablen sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  x & x_0 & x_1 & \dots \\
  y & y_0 & y_1 & \dots \\
  z & z_0 & z_1 & \dots
\end{array}
\]

\paragraph{Konstantensymbole.}
Typische Bezeichnungen für Konstantensymbole sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  c & c_0 & c_1 & \dots
\end{array}
\]

\paragraph{Funktionssymbole.}
Typische Bezeichnungen für Funktionssymbole sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  f & f_0 & f_1 & \dots \\
  g & g_0 & g_1 & \dots
\end{array}
\]

\paragraph{Prädikatensymbole.}
Typische Bezeichnungen für Prädikatensymbole sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  P & P_0 & P_1 & \dots \\
  Q & Q_0 & Q_1 & \dots \\
  R & R_0 & R_1 & \dots
\end{array}
\]

\subsection{Logische Symbole}

Wir reservieren ferner die folgenden Symbole:
\begin{itemize}
  \item die \emph{(logischen) Junktoren}
    \[
      \neg,\quad \land,\quad \lor,\quad \rightarrow,\quad \leftrightarrow,
    \]
  \item die \emph{(logischen) Quantoren}
    \[
      \forall,\quad \exists,\quad \exists!
    \]
  \item das \emph{Gleichheitszeichen}
    \[
      =
    \]
  \item die \emph{Klammerzeichen}
    \[
      ( \quad )
    \]
\end{itemize}

\subsection{Terme}

Aus Variablen, Konstantensymbolen und Funktionssymbolen bilden wir
\emph{Terme}. Informell sind das Ausdrücke wie
\(x\), \(c\), \(f(x)\), \(g(f(x),c)\) usw. Die folgenden
Bildungsregeln fassen dies zusammen.

\FormulaDefDelta[Terme der Prädikatenlogik]{%
  \begin{array}[t]{@{}l@{}}
    \text{(i)}\; x \text{ ist ein Term},\\[0.2em]
    \text{(ii)}\; c \text{ ist ein Term},\\[0.2em]
    \text{(iii)}\; f(t_1,\dots,t_n) \text{ ist ein Term}.
  \end{array}
}{
  \DeltaRow{Variablen}{x}
  \DeltaRow{Konstantensymbole}{c}
  \DeltaRow{Funktionssymbole}{f}
  \DeltaRow{Terme}{t_1 \dsep \dots \dsep t_n}
}

\subsection{Aussagen der Logik}

Aus Aussagevariablen sowie aus Prädikatensymbolen und Termen
bilden wir die \emph{Aussagen der Logik}.

\FormulaDefDelta[Aussagen der Logik]{%
  \begin{array}[t]{@{}l@{}}
    \text{(i)}\; R \text{ ist eine Aussage},\\[0.3em]
    \text{(ii)}\; P(t_1,\dots,t_n) \text{ ist eine Aussage, falls } P
               \text{ ein }n\text{-stelliges Prädikat}\\
    \qquad\text{und } t_1,\dots,t_n \text{ Terme sind},\\[0.4em]
    \text{(iii)}\; t_1 = t_2 \text{ ist eine Aussage, falls } t_1,t_2
               \text{ Terme sind},\\[0.4em]
    \text{(iv)}\; \neg A \text{ ist eine Aussage},\\[0.2em]
    \text{(v)}\; (A \land B)\dsep (A \lor B)\dsep
       (A \rightarrow B)\dsep (A \leftrightarrow B)\\
       \qquad\text{ sind Aussagen},\\[0.4em]
    \text{(vi)}\; \forall x\,A \dsep \exists x\,A \dsep \exists!x\,A
       \text{ sind Aussagen}.
  \end{array}
}{
  \DeltaRow{Aussagevariablen}{R}
  \DeltaRow{Prädikatensymbole}{P \dsep Q}
  \DeltaRow{Terme}{t_1 \dsep \dots \dsep t_n}
  \DeltaRow{Variablen}{x}
  \DeltaRow{Quantoren}{\forall \dsep \exists \dsep \exists!}
  \DeltaRow{Aussagen}{A \dsep B}
}

\chapter{Beweistheorie}

\section{Einleitung zur Beweistheorie}
Beweistheorie ist ein zentraler Bestandteil der formalen Logik, der sich mit den Methoden und Prinzipien befasst, mit denen logische Aussagen bewiesen werden können. Durch die systematische Anwendung von Regeln können wir die Gültigkeit von Aussagen innerhalb eines logischen Systems feststellen. In diesem Kapitel werden wir das Kalkül des natürlichen Schließens als eine der grundlegenden Beweisformen kennenlernen und anwenden.

\section{Formale Sprache}

\begin{definition}[Formale Sprache]
Eine \textbf{formale Sprache} \(\mathcal{L}\) besteht aus zwei Hauptkomponenten:

\begin{enumerate}
    \item \textbf{Alphabet} \( \Sigma \): Eine endliche Menge von \textbf{Symbolen} (z.\,B.\ Buchstaben, Zeichen, Operatoren), die die Grundbausteine der Sprache bilden.
    \item \textbf{Syntaxregeln}: Regeln, die festlegen, wie die Symbole aus \( \Sigma \) kombiniert werden dürfen, um \textbf{wohlgeformte Formeln} (Wff) der Sprache zu bilden. Diese Regeln definieren die Struktur der zulässigen Ausdrücke in der Sprache.
\end{enumerate}

Eine \textbf{wohlgeformte Formel} ist eine endliche Zeichenkette aus Symbolen des Alphabets \( \Sigma \), die den Syntaxregeln der formalen Sprache \(\mathcal{L}\) entspricht.
\end{definition}

\begin{remark}
Die \textbf{Prädikatenlogik} und die \textbf{Aussagenlogik} sind zentrale Beispiele für formale Sprachen. Sie erfüllen die oben genannten Kriterien, indem sie jeweils ein spezifisches Alphabet und klare Syntaxregeln definieren, die die Konstruktion wohlgeformter Formeln ermöglichen.
\end{remark}

\subsection{Beispiele für Formale Sprachen}

Um die Definition einer formalen Sprache zu verdeutlichen, betrachten wir zwei grundlegende logische Systeme: die \textbf{Aussagenlogik} und die \textbf{Prädikatenlogik}.

\subsubsection{Aussagenlogik}

\begin{itemize}
    \item \textbf{Alphabet} \( \Sigma \): Besteht aus
    \begin{enumerate}
        \item \textbf{Aussagevariablen}: Symbole wie \( p, q, r, \ldots \), die atomare Aussagen repräsentieren.
        \item \textbf{Logische Operatoren}: 
        \begin{itemize}
            \item \( \neg \) (Nicht)
            \item \( \land \) (Und)
            \item \( \lor \) (Oder)
            \item \( \rightarrow \) (Impliziert)
            \item \( \leftrightarrow \) (Genau dann wenn)
        \end{itemize}
        \item \textbf{Klammern}: \( (, ) \), die zur Strukturierung von Ausdrücken verwendet werden.
    \end{enumerate}
    
    \item \textbf{Syntaxregeln}: Bestimmen, wie Aussagevariablen und Operatoren kombiniert werden dürfen, um \textbf{wohlgeformte Formeln} zu bilden. Beispiele hierfür sind:
    \begin{itemize}
        \item Eine Aussagevariable allein ist eine wohlgeformte Formel, z.\,B.\ \( p \).
        \item Wenn \( \phi \) eine wohlgeformte Formel ist, dann ist \( \neg \phi \) ebenfalls eine wohlgeformte Formel.
        \item Wenn \( \phi \) und \( \psi \) wohlgeformte Formeln sind, dann sind auch \( \phi \land \psi \), \( \phi \lor \psi \), \( \phi \rightarrow \psi \) und \( \phi \leftrightarrow \psi \) wohlgeformte Formeln.
        \item Klammern werden verwendet, um die Struktur und Priorität der Operatoren zu definieren, z.\,B.\ \( (p \land q) \rightarrow r \).
    \end{itemize}
\end{itemize}

\subsubsection{Prädikatenlogik}

\begin{itemize}
    \item \textbf{Alphabet} \( \Sigma \): Enthält die folgenden Komponenten:
    \begin{enumerate}
        \item \textbf{Individuenkonstanten}: Symbole, die spezifische Objekte in der Domäne repräsentieren, z.\,B.\ \( a, b, c, \ldots \).
        \item \textbf{Variablen}: Symbole wie \( x, y, z, \ldots \), die beliebige Elemente der Do-mäne darstellen können.
        \item \textbf{Funktionssymbole}: Symbole wie \( f, g, h, \ldots \), die Funktionen mit festgelegter Anzahl der Argumente repräsentieren, z.\,B.\ \( f(x), g(x, y) \).
        \item \textbf{Prädikate}: Symbole wie \( P, Q, R, \ldots \), die Relationen oder Eigenschaften ausdrücken und ebenfalls eine festgelegte Arity haben, z.\,B.\ \( P(x), Q(x, y) \).
        \item \textbf{Quantoren}: \( \forall \) (Für alle) und \( \exists \) (Es existiert), die die Bereiche der Variablen einschränken.
        \item \textbf{Logische Operatoren}: Wie in der Aussagenlogik, einschließlich \( \neg \) (Nicht), \( \land \) (Und), \( \lor \) (Oder), \( \rightarrow \) (Impliziert), \( \leftrightarrow \) (Genau dann wenn).
        \item \textbf{Gleichheitszeichen}: \( = \), das die Gleichheit zweier Terme ausdrückt.
        \item \textbf{Klammern}: \( (, ) \), die zur Strukturierung von Ausdrücken verwendet werden.
    \end{enumerate}
    
    \item \textbf{Syntaxregeln}: Regeln, die festlegen, wie die Symbole aus \( \Sigma \) kombiniert werden dürfen, um \textbf{wohlgeformte Formeln} (Wff) der Sprache zu bilden. Diese Regeln definieren die Struktur der zulässigen Ausdrücke in der Sprache.
\end{itemize}

\section{Grundbegriffe: Kalkül und Beweis}

Bevor wir uns dem Kalkül des natürlichen Schließens zuwenden, ist es wichtig, die grundlegenden Begriffe \textit{Kalkül} und \textit{Beweis} präzise zu definieren.

\begin{definition}[Kalkül]
Ein \textbf{Kalkül} (auch \textit{formales Kalkül} oder \textit{formales System} genannt) ist ein strukturiertes System, das aus folgenden Komponenten besteht:

\begin{enumerate}
    \item \textbf{Formale Sprache} \(\mathcal{L}\): Bestehend aus einem Alphabet von Symbolen und Syntaxregeln, die bestimmen, wie wohlgeformte Formeln gebildet werden.
    \item \textbf{Axiome} und/oder \textbf{Annahmen} (Prämissen): Eine Menge von wohlgeformten Formeln in der Sprache \(\mathcal{L}\), die ohne Beweis als wahr angenommen werden.
    \item \textbf{Inferenzenregeln}: Regeln, die festlegen, wie aus gegebenen Formeln neue Formeln abgeleitet werden können.
\end{enumerate}

Die \textbf{Axiome} und \textbf{Annahmen} sind wohlgeformte Formeln, die als Ausgangspunkt dienen. Die \textbf{Inferenzenregeln} ermöglichen es, innerhalb des Kalküls systematisch neue Aussagen zu beweisen.
\end{definition}

\begin{definition}[Beweis]
Ein \textbf{Beweis} in einem Kalkül ist eine endliche Folge von Aussagen
\[
\phi_1, \phi_2, \ldots, \phi_n
\]
wobei jede Aussage \(\phi_i\) entweder eine \textbf{Annahme} (Prämisse), ein \textbf{Axiom} ist oder sich durch Anwendung einer Inferenzenregel auf vorhergehende Aussagen \(\phi_{j}\) (mit \(j < i\)) ableiten lässt. Die letzte Formel \(\phi_n\) des Beweises ist die zu beweisende Aussage.
\end{definition}

\begin{definition}[Argument]
Ein \textbf{Argument} in der Logik besteht aus einer Menge von Aussagen, den sogenannten \textbf{Prämissen}, und einer Aussage, der \textbf{Schlussfolgerung}. Die Prämissen sollen die Schlussfolgerung unterstützen oder begründen.

Formal kann ein Argument als geordnetes Paar \((\Gamma, \phi)\)  definiert werden, wobei \(\Gamma\) eine Menge von Aussagen (die Prämissen) und \(\phi\) eine einzelne Aussage (die Schlussfolgerung) ist.

Ein Argument \((\Gamma, \phi)\) wird als \textbf{gültig} bezeichnet, wenn es eine Ableitung der Schlussfolgerung \(\phi\) aus den Prämissen in \(\Gamma\) gemäß den Regeln des Kalküls gibt.

\end{definition}


\section{Definition einer Theorie}

Eine \textbf{Theorie} in der Prädikatenlogik ist ein formales System, das aus einer Menge von Aussagen besteht, die als Axiome dienen. Aus diesen Axiomen können mittels logischer Schlussregeln weitere Aussagen bewiesen werden.

\begin{definition}[Theorie]
Eine \textbf{Theorie} \(\mathcal{T}\) in der Prädikatenlogik besteht aus einem \textbf{Axiomensystem} \(\Sigma\) und umfasst alle Aussagen \(\phi\) in der Sprache \(\mathcal{L}\), für die gilt:
\[
\Sigma \vdash \phi
\]
Das bedeutet, dass die Aussage \(\phi\) beweisbar ist aus den Axiomen \(\Sigma\) unter Verwendung der festgelegten Schlussregeln.
\end{definition}

\begin{remark}
Der wesentliche Unterschied zwischen einem \textbf{Kalkül} und einer \textbf{Theorie} besteht darin, dass der Kalkül das formale System mit seiner \textbf{Sprache}, \textbf{Axiomen} und \textbf{Inferenzenregeln} definiert, während eine Theorie eine spezifische Menge von Axiomen innerhalb dieses Kalküls ist und alle daraus ableitbaren Aussagen umfasst.
\end{remark}

\section{Eigenschaften einer Theorie}

Die Eigenschaften \textbf{Konsistenz} und \textbf{Vollständigkeit} sind zentrale Merkmale einer Theorie. Diese werden im Folgenden separat definiert und formal beschrieben.

\subsection{Konsistenz}

\begin{definition}[Konsistenz]
Eine \textbf{Theorie} \(\mathcal{T}\) mit Axiomensystem \(\Sigma\) ist \textbf{konsistent}, wenn es keine Aussage \(\phi\) gibt, für die sowohl \(\Sigma \vdash \phi\) als auch \(\Sigma \vdash \neg \phi\) gilt.
\end{definition}

\begin{remark}
Eine Theorie ist konsistent genau dann, wenn sie keine widersprüchlichen Aussagen enthält. Das bedeutet, es ist nicht möglich, sowohl eine Aussage als auch ihr Gegenteil aus den Axiomen abzuleiten.
\end{remark}

\subsection{Vollständigkeit}

\begin{definition}[Vollständigkeit]
Eine \textbf{Theorie} \(\mathcal{T}\) mit Axiomensystem \(\Sigma\) ist \textbf{vollständig}, wenn für jede Aussage \(\phi\) in der Sprache \(\mathcal{L}\) entweder \(\Sigma \vdash \phi\) oder \(\Sigma \vdash \neg \phi\) gilt.
\end{definition}

\begin{remark}
Eine Theorie ist vollständig genau dann, wenn für jede Aussage entweder die Aussage selbst oder ihre Negation aus den Axiomen ableitbar ist.
\end{remark}

\section{Arten von Definitionen}

\subsection{Explizite Definitionen}

\begin{definition}[Explizite Definition]
Sei \(\varphi(x_1,\dots,x_n)\) ein bereits bekannter, wohldefinierter Ausdruck (z.\,B.\ ein Prädikat oder Term) in einer formalen Sprache \(\mathcal{L}\) und \(Q(x_1,\dots,x_n)\) ein \emph{neues} Symbol, das in \(\mathcal{L}\) bisher nicht vorkam. Dann nennen wir
\[
\forall x_1,\dots,x_n \bigl( Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n) \bigr)
\]
eine \textbf{explizite Definition} von \(Q\). In dieser Definition heißt:
\begin{itemize}
    \item \(Q\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item \(\varphi\) \textbf{Definiens} (der bereits bekannte Ausdruck).
\end{itemize}

\noindent
\subsubsection{Wohldefiniertheit der expliziten Definition} 
\begin{enumerate}
    \item Alle in \(\varphi\) vorkommenden Symbole (Variablen, Konstanten, Funktions- oder Prädikatsymbole) sind bereits bekannt \emph{und} ihrerseits wohldefiniert.
    \item Das neue Symbol \(Q\) kommt in \(\varphi\) selbst nicht vor (keine Zirkularität).
    \item Für jede mögliche Belegung der Variablen \(x_1,\dots,x_n\) existiert genau ein \(y\), sodass \(\varphi(x_1,\dots,x_n) = y\). Formal ausgedrückt:
    \[
    \forall x_1,\dots,x_n \, \forall y \, \forall z \, \bigl( \varphi(x_1,\dots,x_n) = y \land \varphi(x_1,\dots,x_n) = z \rightarrow y = z \bigr).
    \]
    \item Für jede mögliche Belegung der Variablen \(x_1, \dots, x_n\) ist \(\varphi(x_1,\dots,x_n)\) widerspruchsfrei und erfüllt das Prinzip des ausgeschlossenen Dritten. Formal:
    \[
    \forall x_1,\dots,x_n \, \neg \bigl( \varphi(x_1,\dots,x_n) \land \neg \varphi(x_1,\dots,x_n) \bigr) \quad \text{(Konsistenz)},
    \]
    sowie
    \[
    \forall x_1,\dots,x_n \, \bigl( \varphi(x_1,\dots,x_n) \lor \neg \varphi(x_1,\dots,x_n) \bigr) \quad \text{(Vollständigkeit)}.
    \]
\end{enumerate}
\end{definition}

\subsection{Partielle Definitionen}
\begin{definition}[Partielle Definition]
Sei \(\varphi(x_1,\dots,x_n)\) ein bereits bekannter, wohldefinierter Ausdruck (z.\,B.\ ein Prädikat oder Term) in einer formalen Sprache \(\mathcal{L}\), \(C(x_1,\dots,x_n)\) eine Bedingung (ein weiteres Prädikat), und \(Q(x_1,\dots,x_n)\) ein \emph{neues} Symbol, das in \(\mathcal{L}\) bisher nicht vorkam. Dann nennen wir
\[
\forall x_1,\dots,x_n \bigl( C(x_1,\dots,x_n) \rightarrow ( Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n) ) \bigr)
\]
eine \textbf{partielle Definition} von \(Q\). In dieser Definition heißt:
\begin{itemize}
    \item \(Q\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item \(\varphi\) \textbf{Definiens} (der bereits bekannte Ausdruck),
    \item \(C\) \textbf{Bedingung} (das Prädikat, unter dem die Definition gilt).
\end{itemize}

\noindent
\subsubsection{Wohldefiniertheit der partiellen Definition} \emph{wohldefiniert}, wenn
\begin{enumerate}
    \item Alle in \(\varphi\) und \(C\) vorkommenden Symbole (Variablen, Konstanten und Funktions- oder Prädikatsymbole) sind bereits bekannt \emph{und} ihrerseits wohldefiniert.
    \item Das neue Symbol \(Q\) kommt weder in \(\varphi\) noch in \(C\) selbst vor (keine Zirkularität).
    \item Für jede mögliche Belegung der Variablen \(x_1,\dots,x_n\), für die \(C(x_1,\dots,x_n)\) wahr ist, existiert genau ein \(y\), sodass \(\varphi(x_1,\dots,x_n) = y\). Formal:
    \[
    \begin{aligned}
    & \forall x_1,\dots,x_n \, \forall y \, \forall z \, 
       \bigl( C(x_1,\dots,x_n) \rightarrow \\
    &\qquad (\varphi(x_1,\dots,x_n) = y \land 
              \varphi(x_1,\dots,x_n) = z \rightarrow y = z ) \bigr).
    \end{aligned}
    \]
    \item Für jede mögliche Belegung der Variablen \(x_1, \dots, x_n\), für die \(C(x_1,\dots,x_n)\) wahr ist, gilt, dass \(\varphi(x_1,\dots,x_n)\) widerspruchsfrei und vollständig ist. Formal:
    \[
    \begin{aligned}
    & \forall x_1,\dots,x_n \, 
       \bigl( C(x_1,\dots,x_n) \rightarrow \\
    &\qquad \neg\bigl( \varphi(x_1,\dots,x_n) \land 
                       \neg \varphi(x_1,\dots,x_n) \bigr) \bigr)
       \quad \text{(Konsistenz)}.
    \end{aligned}
    \]
    sowie
    \[
    \begin{aligned}
    & \forall x_1,\dots,x_n \, 
       \bigl( C(x_1,\dots,x_n) \rightarrow \\
    &\qquad ( \varphi(x_1,\dots,x_n) \lor 
               \neg \varphi(x_1,\dots,x_n) ) \bigr)
       \quad \text{(Vollständigkeit)}.
    \end{aligned}
    \]
\end{enumerate}
\end{definition}

\subsection{Rekursive Definition}

\begin{definition}[Rekursive Definition]
Sei \(\sigma(x_1, \ldots, x_n)\) ein \emph{neues} Symbol, das in einer formalen Sprache \(\mathcal{L}\) eingeführt werden soll. Eine \textbf{rekursive Definition} von \(\sigma\) besteht aus zwei Teilen:

\begin{itemize}
    \item \textbf{Basisfall:} Eine oder mehrere explizite Festlegungen von \(\sigma\) für spezielle Werte der Variablen, beispielsweise:
    \[
    \sigma(a_1, \ldots, a_k) \coloneqq b \quad \text{für feste Werte } a_1, \ldots, a_k \text{ und } b.
    \]
    Hierbei sind \(a_1, \ldots, a_k\) konkrete Werte aus der Domäne \(D\) und \(b\) ein bereits bekannter Term oder Wert in \(\mathcal{L}\).
    
    \item \textbf{Rekursionsvorschrift:} Eine oder mehrere Regeln, die \(\sigma(x_1, \ldots, x_n)\) für allgemeine Werte der Variablen definieren, indem sie auf zuvor definierte Werte von \(\sigma\) Bezug nehmen. Dies erfolgt in der Form:
    \[
    \sigma(x_1, \ldots, x_n) \coloneqq f\big(\sigma(y_1, \ldots, y_m), z_1, \ldots, z_p\big),
    \]
    wobei \(y_1, \ldots, y_m\) eine Teilmenge von \(x_1, \ldots, x_n\) ist, \(f\) eine bekannte Funktion in der Sprache \(\mathcal{L}\), und \(z_1, \ldots, z_p\) bekannte Terme in \(\mathcal{L}\) sind. Die Terme \(z_1, \ldots, z_p\) dürfen nicht rekursiv auf \(\sigma\) zurückgreifen, können jedoch von den Variablen \(x_1, \ldots, x_n\) abhängen oder andere bekannte Größen in \(\mathcal{L}\) enthalten.
\end{itemize}

In dieser Definition heißt:
\begin{itemize}
    \item \(\sigma\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item Die Basisfälle und Rekursionsvorschriften zusammen bilden das \textbf{Definiens}.
\end{itemize}

\noindent
\subsubsection{Wohldefiniertheit der rekursiven Definition}
\begin{enumerate}
    \item \textbf{Terminierung der Rekursion:} Für jede mögliche Belegung der Variablen \(x_1, \ldots, x_n\) wird die Rekursion nach endlich vielen Schritten beendet. Formal:
    \[
    \forall x_1, \ldots, x_n \, \exists k \in \mathbb{N} \, \bigl( \text{\(\sigma(x_1, \ldots, x_n)\) wird nach \(k\) Schritten berechnet} \bigr).
    \]
    \item \textbf{Eindeutigkeit:} Für jede Belegung der Variablen \(x_1, \ldots, x_n\) gibt es genau einen Wert \(y\), sodass die Rekursionsvorschrift für \(\sigma(x_1, \ldots, x_n)\) erfüllt ist. Formal:
    \[
    \forall x_1, \ldots, x_n \, \forall y \, \forall z \, \bigl( \sigma(x_1, \ldots, x_n) = y \land \sigma(x_1, \ldots, x_n) = z \rightarrow y = z \bigr).
    \]
    \item \textbf{Konsistenz der Rekursionsvorschrift:} Für jede mögliche Belegung der Variablen \(x_1, \ldots, x_n\) erzeugt die Rekursionsvorschrift keinen Widerspruch. Formal:
    \[
    \forall x_1, \ldots, x_n \, \neg \bigl( \sigma(x_1, \ldots, x_n) \land \neg \sigma(x_1, \ldots, x_n) \bigr).
    \]
    \item \textbf{Vollständigkeit der Rekursionsvorschrift:} Für jede mögliche Belegung der Variablen \(x_1, \ldots, x_n\) existiert ein definierter Wert. Formal:
    \[
    \forall x_1, \ldots, x_n \, \bigl( \sigma(x_1, \ldots, x_n) \lor \neg \sigma(x_1, \ldots, x_n) \bigr).
    \]
    \item \textbf{Monotonie der Rekursion:} Die Rekursionsvorschrift bezieht sich nur auf kleinere oder gleichwertige Argumente, die gemäß einer festen Ordnungsrelation \(R\) definiert sind. Formal:
    \[
    \forall x_1, \ldots, x_n \, \forall y_1, \ldots, y_m \, \bigl( R((y_1, \ldots, y_m), (x_1, \ldots, x_n)) \bigr),
    \]
    wobei \(R\) die Terminierung sicherstellt.
\end{enumerate}
\end{definition}


\subsection{Implizite Definition}

Die \textbf{implizite Definition} ist eine Methode, neue Symbole oder Konzepte in einer Theorie einzuführen, indem ihre Eigenschaften durch Axiome festgelegt werden, anstatt sie direkt zu definieren.

\begin{definition}[Implizite Definition]
Eine \textbf{implizite Definition} eines neuen Symbols \(\sigma\) in einer Theorie \(\mathcal{T}\) besteht aus einer Menge von \textbf{Aussagen} \(\Phi(\sigma)\), die die Eigenschaften von \(\sigma\) festlegen.
In formalen Kalkülen dürfen diese Axiome durch \textbf{äquivalente Schlussregeln} ersetzt werden, die dieselben Eigenschaften syntaktisch ausdrücken, um die Anwendbarkeit zu erleichtern.

\end{definition}

\subsubsection{Wohldefiniertheit einer Impliziten Definition}

\begin{definition}[Wohldefiniertheit einer impliziten Definition]
Eine implizite Definition \(\Phi(\sigma)\) ist \emph{wohldefiniert}, wenn sie die folgenden Eigenschaften erfüllt:
\begin{enumerate}
    \item \textbf{Konsistenz:} Die Menge der Aussagen \(\Phi(\sigma)\) darf keine widersprüchlichen Bedingungen enthalten. Formal:
    \[
    \neg \exists \phi, \psi \in \Phi(\sigma) \, \bigl( \phi \land \neg \phi \bigr).
    \]

    \item \textbf{Existenz:} Es muss mindestens eine Interpretation von \(\sigma\) geben, die alle Aussagen in \(\Phi(\sigma)\) erfüllt. Formal:
    \[
    \exists \sigma' \, \forall \phi \in \Phi(\sigma) \, \bigl( \phi[\sigma' / \sigma] \bigr),
    \]
    wobei \(\phi[\sigma' / \sigma]\) die Aussage \(\phi\) mit der Interpretation \(\sigma'\) für das Symbol \(\sigma\) bezeichnet.

    \item \textbf{Eindeutigkeit:} Es darf höchstens eine Interpretation von \(\sigma\) geben, die alle Aussagen in \(\Phi(\sigma)\) erfüllt. Formal:
    \[
    \forall \sigma', \sigma'' \, \bigl( (\forall \phi \in \Phi(\sigma) \, \phi[\sigma' / \sigma]) \land (\forall \phi \in \Phi(\sigma) \, \phi[\sigma'' / \sigma]) \rightarrow \sigma' = \sigma'' \bigr).
    \]
\end{enumerate}
\end{definition}

\subsection{Das Iota-Symbol}

In manchen Fällen möchten wir einen Begriff oder ein Symbol definieren, der oder das eindeutig durch eine bestimmte Eigenschaft charakterisiert ist. Hier kommt das \textbf{Iota-Symbol} \( \iota \) zum Einsatz, das in der formalen Logik verwendet wird, um auf ein eindeutig bestimmtes Objekt Bezug zu nehmen.

\begin{definition}[Iota-Symbol (\( \iota \))]
Sei \( P(x) \) eine Aussage oder Eigenschaft über \( x \). Falls es genau ein \( x \) gibt, für das \( P(x) \) gilt, schreiben wir:
\[
\iota x \, P(x)
\]
und meinen damit \enquote{das eindeutige \( x \), für das \( P(x) \) gilt}.

Formal bedeutet dies:
\[
\exists! x \, P(x) \quad \text{und} \quad \iota x \, P(x) \text{ ist dieses eindeutige } x.
\]
Dabei steht \( \exists! x \, P(x) \) für \enquote{Es existiert genau ein \( x \), für das \( P(x) \) gilt} und ist definiert als:
\[
\exists x \, P(x) \land \forall y \, (P(y) \rightarrow y = x).
\]
\end{definition}

\paragraph{Definition einer neuen Konstante}

\begin{definition}[Iota-Definition]
Sei \(P(x)\) eine bereits bekannte und wohldefinierte Eigenschaft in einer formalen Sprache \(\mathcal{L}\). Sei \(\sigma\) ein \emph{neues} Symbol (z.\,B.\ eine neue Konstante), das in \(\mathcal{L}\) bisher nicht vorkam. Dann definieren wir
\[
\sigma \coloneqq \iota x\,P(x)
\]
\emph{genau dann}, wenn \(\exists!\,x\,P(x)\) (es existiert \emph{genau ein} \(x\), für das \(P(x)\) gilt). 

\noindent
In dieser Definition heißt:
\begin{itemize}
    \item \(\sigma\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item \(\iota x\,P(x)\) \textbf{Definiens} (der bereits bekannte Ausdruck mit dem Iota-Operator).
\end{itemize}

\noindent
\textbf{Wohldefiniertheit der Iota-Definition} setzt voraus:
\begin{enumerate}
    \item \(\exists!\,x\,P(x)\), d.\,h.\ es existiert \emph{genau ein} \(x\), für das \(P(x)\) gilt.
    \item Das neue Symbol \(\sigma\) kommt in \(\iota x\,P(x)\) selbst nicht vor (keine Zirkularität).
\end{enumerate}
\end{definition}


\section{Grundlegende Beweisprinzipien}

In diesem Abschnitt werden weiterführende Konzepte vorgestellt, die im Rahmen von Beweisen und der Entwicklung formaler Theorien eine zentrale Rolle spielen.


\begin{definition}[Theorem]
Ein \textbf{Theorem} ist eine Aussage, die innerhalb eines Kalküls unter Verwendung der definierten Inferenzenregeln und gegebenen Annahmen bewiesen wurde. Theoreme sind zentrale Bestandteile mathematischer Theorien und dienen als Bausteine für weiterführende Beweise.
\end{definition}

\begin{definition}[Lemma]
Ein \textbf{Lemma} ist ein unterstützender Satz, der im Verlauf des Beweisens eines Theorems verwendet wird. Lemmata dienen dazu, komplexere Beweise in überschaubare Schritte zu gliedern.
\end{definition}

\begin{definition}[Korollar]
Ein \textbf{Korollar} ist eine Aussage, die sich unmittelbar aus einem bereits bewiesenen Theorem oder Lemma ableiten lässt. Korollare sind oft direkte Konsequenzen der zuvor bewiesenen Aussagen.
\end{definition}
\begin{remark}
Die in Theoremen, Lemmata und Korollaren zu zeigenden Argumente notieren wir im Folgenden durch \(\Gamma \vdash \phi\). Dabei stellt \(\Gamma\) eine Aufzählung der Prämissen dar, die notwendig sind, um \(\phi\) zu zeigen.

\noindent
\textbf{Keine Annahmen:} Falls keine Annahmen für den Beweis notwendig sind, um \(\phi\) zu zeigen, notieren wir das Argument schlicht als \(\phi\). Dies impliziert, dass der Beweis aus dem \emph{leeren} Prämissenkontext \(\Gamma = \varnothing\) geführt werden kann, d.\,h.\ \(\varnothing \vdash \phi\).
Besteht \(\Gamma\) aus lediglich einer Annahme \(\psi\) und gilt neben \(\psi\vdash\phi\) auch \(\phi\vdash\psi\), so schreiben wir für beide Argumente schlicht: \(\psi\dashv\vdash \phi\).
\end{remark}

\begin{definition}[Hilfsdefinition]
Eine \textbf{Hilfsdefinition} ist eine unterstützende Definition, die im Verlauf der Entwicklung einer formalen Theorie eingeführt wird, um eine komplexere Hauptdefinition vorzubereiten oder zu vereinfachen. Hilfsdefinitionen können als Zwischenstufen betrachtet werden, die es ermöglichen, komplexe Begriffe in mehreren Schritten aufzubauen.
\end{definition}

\begin{remark}
Hilfsdefinitionen dienen dazu, Definitionen modular und über-sichtlich zu gestalten. Sie sind im Allgemeinen lokal auf den Kontext der Hauptdefinition beschränkt.
\end{remark}

\begin{definition}[Temporäre Definition]
Eine \textbf{temporäre Definition} ist eine Definition, die ausschließlich innerhalb eines Beweises eingeführt wird, um dessen Struktur zu vereinfachen und zu verdeutlichen. Diese Definition hat keine Bedeutung außerhalb des Beweises und wird nach Abschluss des Beweises nicht weiter verwendet.
\end{definition}

\begin{remark}
Temporäre Definitionen sind nützlich, um komplexe Beweisschritte zu modularisieren und zu vereinfachen. Sie werden nur im Rahmen eines einzelnen Beweises verwendet und danach verworfen.
\end{remark}

\section{Kalkül des natürlichen Schließens}

\subsection{Einführung}
Das Kalkül des natürlichen Schließens ist ein formales System, das in der
Aussagen- und Prädikatenlogik verwendet wird, um Beweise zu führen. Es wurde
entwickelt, um eine Methode zur Verfügung zu stellen, die der Art und Weise,
wie Menschen intuitiv logische Schlussfolgerungen ziehen, möglichst nahe kommt.

Das natürliche Schließen ist ein spezielles Kalkül, das \emph{keine Axiome}
verwendet, sondern sich vollständig auf eine festgelegte Menge von
\emph{Schlussregeln} stützt. Diese Schlussregeln sind die fundamentalen
Bausteine des Kalküls und bestimmen, wie aus gegebenen Formeln neue Formeln
abgeleitet werden können. Sie definieren die zulässigen Schritte innerhalb des
Systems und gewährleisten so die logische Korrektheit der abgeleiteten
Aussagen.

Ein \emph{Beweis} im Kalkül des natürlichen Schließens ist eine endliche Folge
von Formeln, bei der jede Formel entweder eine \emph{Annahme} (Prämisse) ist
oder sich durch Anwendung einer der Schlussregeln auf zuvor eingeführte
Formeln ableiten lässt.

\subsection{Tabellarische Beweisdarstellung nach Lemmon}

Im Folgenden verwenden wir eine tabellarische Darstellung der Beweise
(nach Lemmon). Jede Zeile einer Beweistabelle hat die Form
\[
  \begin{array}{llll}
    I & (m) & P & \text{Regelname } j_1,\dots,j_\ell
  \end{array}
\]
und ist wie folgt zu lesen:
\begin{itemize}
  \item \(m\) ist die \emph{Zeilennummer} (eine natürliche Zahl),
  \item \(P\) ist die in dieser Zeile auftretende Formel,
  \item \(I\) ist eine endliche Menge von Zeilennummern, die die noch offenen
        \emph{Annahmen} (Prämissen) dieser Zeile kodiert,
  \item \(\text{Regelname } j_1,\dots,j_\ell\) gibt an, welche Schlussregel
        angewendet wurde und auf welche Zeilen \(j_1,\dots,j_\ell\) sich diese
        Anwendung bezieht.
\end{itemize}

Eine Zeile ist eine \emph{Annahme}, wenn sie nur aus sich selbst abhängt und
noch keinen Schluss aus vorherigen Zeilen darstellt:


\label{rule:A}
\[
  \begin{array}{llll}
    \{i\} & (i) & P & \rA
  \end{array}
\]

Hier ist \(P\) eine beliebige Formel, \(i\) ist die Zeilennummer, und \(I=\{i\}\)
markiert, dass die Zeile \(i\) nur von sich selbst als offener Annahme
abhängt.

\begin{definition}[Beweistabelle]
Eine \emph{Beweistabelle} ist eine endliche Sequenz von Zeilen
\[
  Z_1,\dots,Z_N,
\]
wobei jede Zeile \(Z_m\) (\(1 \le m \le N\)) die Form
\[
  Z_m = (I_m,\,(m),\,P_m,\,\text{Regelname}_m\,j_1,\dots,j_\ell)
\]
hat und folgenden Bedingungen genügt:
\begin{enumerate}
  \item \textbf{Annahmen.} Eine Zeile \(Z_i\) ist Annahme, wenn sie die Form
    \[
      \{i\}\ (i)\ P_i\ \rA
    \]
    hat.
  \item \textbf{Schlussregeln.} Jede nicht als Annahme eingeführte Zeile
    \(Z_m\) entsteht durch Anwendung einer der festgelegten Schlussregeln
    (oder eines bereits bewiesenen Theorems/einer Definition) auf vorherige
    Zeilen \(Z_{j_1},\dots,Z_{j_\ell}\) mit \(j_r < m\). Die Menge \(I_m\) der
    offenen Annahmen ergibt sich dabei aus den Mengen \(I_{j_1},\dots,I_{j_\ell}\)
    gemäß der jeweiligen Schlussregel.
\end{enumerate}
Eine Beweistabelle \emph{beweist} eine Formel \(R\) unter Annahmen
\(P_1,\dots,P_n\), wenn die letzte Zeile \(Z_N\) die Formel \(R\) enthält
und ihre Abhängigkeitsmenge \(I_N\) genau die Zeilennummern der Annahmen
\(P_1,\dots,P_n\) umfasst.
\end{definition}

\subsection{Abstrakte Schreibweise für Schlussregeln}

Metalogisch beschreiben wir eine Schlussregel in der abstrakten Form
\[
  P_1,\dots,P_n \;\vdash_\Delta\; R.
\]
Dies ist so zu lesen:
\begin{quote}
  Wenn in einer Beweistabelle die Formeln \(P_1,\dots,P_n\) in geeigneter Weise
  zur Verfügung stehen, dann erlaubt die Schlussregel \(\Delta\), die Formel
  \(R\) als neue Zeile einzuführen.
\end{quote}
Die abstrakte Notation blendet die genaue tabellarische Form (Indizes,
Zeilennummern, Referenzen) aus. Um die Verbindung zur Beweistabelle explizit
zu machen, verwenden wir eine kompakte Schreibweise in Form von \emph{Regelschemata}, die beide Ebenen miteinander verknüpft.

\subsection{Regelschemata ohne und mit entladenen Annahmen}

\begin{DeltaContext}{In diesem Abschnitt verwendete Symbole}
  \DeltaRow{Aussagen}{P_1 \dsep \dots \dsep P_n \dsep A \dsep R}
  \DeltaRow{Zeilennummern}{m_1 \dsep \dots \dsep m_n \dsep m \dsep k}
  \DeltaRow{Indexmengen}{I_1 \dsep \dots \dsep I_n \dsep I \dsep I_s}
\end{DeltaContext}

\paragraph{Regeln ohne entladene Annahmen.}
Ein Regelschema der Form
\[
  P_1,\dots,P_n \;\vdash_\Delta\; R
\]
wird tabellarisch durch folgendes Schema repräsentiert:
\begin{RuleSchema}
\[
P_1,\dots,P_n \;\vdash_\Delta\; R
\]

\[
\leadsto\;
\boxed{%
  \begin{array}{llll}
    I_1&(m_{i_1})&P_{i_1}&\cdots \\
    I_2&(m_{i_2})&P_{i_2}&\cdots \\
       &        &\vdots  &        \\
    I_n&(m_{i_n})&P_{i_n}&\cdots \\
    I  &(m)      &R      &\Delta(m_{i_1},\dots,m_{i_n}) \\
  \end{array}
}
\]

\[
I := I_1 \cup \dots \cup I_n.
\]
\end{RuleSchema}

Die Indizes \(i_1,\dots,i_n\) geben an, an welchen Zeilennummern die Formeln
\(P_1,\dots,P_n\) tatsächlich im konkreten Beweis vorkommen. Die Mengen
\(I_1,\dots,I_n\) kodieren die offenen Annahmen dieser Zeilen. Die Regel
\(\Delta\) erlaubt es, aus diesen Zeilen eine neue Zeile \(m\) mit Formel
\(R\) zu bilden, deren Abhängigkeitsmenge die Vereinigung der bisherigen
Abhängigkeitsmengen ist.

\paragraph{Regeln mit einer entladenen Annahme.}
Viele Schlussregeln (zum Beispiel \(\rightarrow I\), \(\neg I\), \(\lor E\))
arbeiten mit einem \emph{Hilfsbeweis} unter einer zusätzlichen Annahme \(A\),
die am Ende des Subbeweises wieder \enquote{entladen} wird. Meta\-logisch
schreiben wir dies als
\[
  P_1,\dots,[A]\vdots P_j,\dots,P_n \;\vdash_\Delta\; R,
\]
wobei \([A]\vdots P_j\) einen Teilbeweis bezeichnet, der mit einer Annahme
\(A\) beginnt und in \(P_j\) endet.

Tabellarisch verwenden wir dafür das Schema:
\begin{RuleSchema}
\[
P_1,\dots,[A]\vdots P_j,\dots,P_n \;\vdash_\Delta\; R
\]

\[
\leadsto\;
\boxed{%
  \begin{array}{llll}
       &        &\vdots  &        \\[0.2ex]
    k  &(k)     &A       &\rA     \\[0.2ex]
       &        &\vdots  &        \\[0.2ex]
    I_s&(m_{i_s})&P_j    &\cdots  \\[0.2ex]
       &        &\vdots  &        \\[0.4ex]
    I  &(m)      &R      &\Delta(\text{alle verwendeten }m_{i_r}\text{ inkl.\ }k,m_{i_s}) \\
  \end{array}
}
\]

\[
i_s = j,\qquad
I_s' := I_s \setminus \{k\},
\]

\[
\text{es gibt weitere Zeilen }(I_r,(m_{i_r}),P_{i_r},\dots)
\text{ für } r \neq s,
\]

\[
I := \bigcup_{r\neq s} I_r \,\cup\, I_s'.
\]
\end{RuleSchema}

Dabei ist \(k\) die Zeilennummer der eingeführten Annahme \(A\) mit
Abhängigkeitsmenge \(\{k\}\), und \(m_{i_s}\) ist die Zeile, in der der
Subbeweis unter dieser Annahme endet (Formel \(P_j\), mit \(i_s=j\)). Beim
Übergang zur Schlusszeile \(m\) mit Formel \(R\) wird die Annahme \(A\)
entladen, indem der Index \(k\) aus der Abhängigkeitsmenge \(I_s\) entfernt
wird. Entsprechend wird \(I\) durch Vereinigung dieser bereinigten Mengen
gebildet.

\subsection{Meta-Notation für Eigenvariablenbedingungen}

Bei Quantorenregeln treten oft sogenannte \emph{Eigenvariablenbedingungen}
auf: bestimmte freie Variablen dürfen in offenen Annahmen oder in der
Konklusion nicht frei vorkommen. Um solche Nebenbedingungen kompakt notieren
zu können, verwenden wir eine spezielle Meta-Notation.

\begin{definition}[Notation \(P(x)\mid_x\)]
Sei \(P(x)\) eine Formel mit einer freien Variable \(x\).
Wir schreiben
\[
  P(x)\mid_x,
\]
wenn es eine Beweistabelle gibt, in der eine Zeile
\[
  I\ (m)\ P(x)\ \dots
\]
vorkommt, so dass in keiner der durch \(I\) kodierten offenen Annahmen die
Variable \(x\) frei vorkommt. 

Allgemeiner schreiben wir
\[
  P_1,\dots,P_{j-1},\,P(x)\mid_x,\,P_{j+1},\dots,P_n \;\vdash\; R,
\]
wenn es eine Beweistabelle mit letzter Zeile \(R\) gibt und eine Zeile mit
Formel \(P(x)\), so dass
\begin{itemize}
  \item \(P_1,\dots,P_n\) genau die offenen Annahmen der letzten Zeile sind,
  \item \(P(x)\) an der \(j\)-ten Stelle dieser Liste steht und
  \item in keiner der übrigen offenen Annahmen die Variable \(x\) frei vorkommt.
\end{itemize}
\end{definition}

Die Notation \(P(x)\mid_x\) fasst also die übliche Bedingung zusammen, dass
\(x\) \enquote{neu} ist und nur in dem Teil des Beweises frei vorkommt, in dem
\(P(x)\) selbst erscheint, nicht aber in den übrigen offenen Annahmen.

\begin{definition}[Notation \(P(x)\vdots Q\mid_x\)]
Seien \(P(x)\) und \(Q\) Formeln. Wir schreiben
\[
  P(x)\vdots Q\mid_x,
\]
wenn es einen Subbeweis
\[
  [P(x)]\ \vdots\ Q
\]
gibt, d.\,h.\ eine Folge von Zeilen, die mit einer Annahmezeile
\[
  \{k\}\ (k)\ P(x)\ \rA
\]
beginnt und in einer Zeile
\[
  J\ (m)\ Q\ \dots
\]
endet, so dass die folgende Eigenvariablenbedingung erfüllt ist:
\begin{itemize}
  \item Die Variable \(x\) kommt in keiner der durch \(J\setminus\{k\}\)
        kodierten offenen Annahmen frei vor, und
  \item \(x\) kommt in der Konklusion \(Q\) nicht frei vor.
\end{itemize}
Wir können dies informell so lesen:
\enquote{Es gibt einen Subbeweis von \(P(x)\) nach \(Q\), in dem \(x\) nur in
der speziellen Annahme \(P(x)\) und deren Ableitungen frei vorkommt, aber
nicht in den übrigen offenen Annahmen und nicht in \(Q\) selbst.}
\end{definition}

\begin{remark}
Die Notationen \(P(x)\mid_x\) und \(P(x)\vdots Q\mid_x\) sind rein
metalogische Kurzschreibweisen. Sie fassen jeweils bestimmte
Eigenvariablenbedingungen zusammen, die insbesondere bei den Regeln für
Quantoren (z.\,B.\ All- und Existenzquantor) auftreten. Die konkreten
Quantorenregeln werden später in dieser Notation formuliert.
\end{remark}

\subsection{Übersicht über die elementaren Schlussregeln}

\begin{center}
  \renewcommand{\arraystretch}{1.3}
  \begin{tabularx}{\textwidth}{@{}l l X@{}}
    \toprule
    Symbol & Regeltyp & Abstraktes Regelschema \\
    \midrule
    % --- Konjunktion ---
    $\land$
      & Einführung
      & \label{rule:AI}%
        \(P,\;Q \;\vdash_{\land I}\; P \land Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:AE1}%
        \(P \land Q \;\vdash_{\land E_1}\; P\),\quad
        \label{rule:AE2}%
        \(P \land Q \;\vdash_{\land E_2}\; Q\) \\[0.9ex]

    % --- Disjunktion ---
    $\lor$
      & Einführung
      & \label{rule:OI1}%
        \(P \;\vdash_{\lor I_1}\; P \lor Q\),\quad
        \label{rule:OI2}%
        \(Q \;\vdash_{\lor I_2}\; P \lor Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:OE}%
        \(P \lor Q,\; [P]\vdots R,\; [Q]\vdots R
          \;\vdash_{\lor E}\; R\) \\[0.9ex]

    % --- Implikation ---
    $\rightarrow$
      & Einführung
      & \label{rule:RI}%
        \([P]\vdots Q \;\vdash_{\rightarrow I}\; P \rightarrow Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:RE}%
        \(P \rightarrow Q,\; P \;\vdash_{\rightarrow E}\; Q\) \\[0.9ex]

    % --- Äquivalenz ---
    $\leftrightarrow$
      & Einführung
      & \label{rule:LRI}%
        \(P \rightarrow Q,\; Q \rightarrow P
          \;\vdash_{\leftrightarrow I}\; P \leftrightarrow Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:LRE1}%
        \(P \leftrightarrow Q \;\vdash_{\leftrightarrow E_1}\;
          P \rightarrow Q\),\quad
        \label{rule:LRE2}%
        \(P \leftrightarrow Q \;\vdash_{\leftrightarrow E_2}\;
          Q \rightarrow P\) \\[0.9ex]

    % --- Negation und Widerspruch ---
    $\neg,\;\bot$
      & Einführung von \(\bot\)
      & \label{rule:BI}%
        \(P,\;\neg P \;\vdash_{\bot I}\; \bot\) \\[0.6ex]
      & Einführung von \(\neg\)
      & \label{rule:CI}%
        \([P]\vdots \bot \;\vdash_{\neg I}\; \neg P\) \\[0.6ex]
      & Eliminierung von \(\neg\)
      & \label{rule:CE}%
        \(\neg P,\; \bot \;\vdash_{\neg E}\; P\) \\[0.9ex]

    % --- Allquantor ---
    $\forall$
      & Einführung
      & \label{rule:UI}%
        \(P(x)\mid_x \;\vdash_{\forall I}\; \forall x\,P(x)\) \\[0.6ex]
      & Eliminierung
      & \label{rule:UE}%
        \(\forall x\,P(x) \;\vdash_{\forall E}\; P(t)\) \\[0.9ex]

    % --- Existenzquantor ---
    $\exists$
      & Einführung
      & \label{rule:EI}%
        \(P(t) \;\vdash_{\exists I}\; \exists x\,P(x)\) \\[0.6ex]
      & Eliminierung
      & \label{rule:EE}%
        \(\exists x\,P(x),\; P(x)\vdots Q\mid_x
          \;\vdash_{\exists E}\; Q\) \\[0.9ex]

    % --- Identität ---
    $=$
      & Einführung
      & \label{rule:II}%
        \(\vdash_{= I}\; t = t\) \\[0.6ex]
      & Eliminierung
      & \label{rule:IE}%
        \(t = u,\; P(t) \;\vdash_{= E}\; P(u)\) \\
    \bottomrule
  \end{tabularx}
\end{center}

\subsection{Weitere (abgeleitete) Schlussregeln}

Neben den elementaren Regeln aus dem letzten Abschnitt verwenden wir
gelegentlich noch abgeleitete Regeln für die alternative Disjunktion \(\lxor\)
und den Eindeutigkeitsquantor \(\exists!\).
Beide Operatoren werden in unserem System nicht als primitive Symbole
verstanden, sondern über bereits bekannte Formeln definiert
(zum Beispiel lässt sich \(\lxor\) mit Hilfe von \(\land,\lor,\neg\) und
\(\exists!\) mit Hilfe von \(\exists,\forall,=\) ausdrücken).
Aus diesen Definitionen zusammen mit den elementaren Schlussregeln folgen
die nun aufgeführten abgeleiteten Regeln.

\begin{center}
\renewcommand{\arraystretch}{1.25}
\begin{tabularx}{\textwidth}{@{}llX@{}}
\toprule
Symbol & Regeltyp & Abstraktes Regelschema \\ 
\midrule
$\lxor$
  & \label{rule:XOrI1}Einführung 1 
  & \[
      P \land \neg Q \;\vdash_{\lxor I_1}\; P \lxor Q
    \] \\[0.6ex]
  & \label{rule:XOrI2}Einführung 2
  & \[
      \neg P \land Q \;\vdash_{\lxor I_2}\; P \lxor Q
    \] \\[0.6ex]
  & \label{rule:XOrE}Eliminierung
  & \[
      P \lxor Q,\; [P,\neg Q]\vdots R,\; [\neg P,Q]\vdots R
      \;\vdash_{\lxor E}\; R
    \] \\[0.8ex]
$\exists!$
  & \label{rule:UEI}Einführung
  & \[
      \exists x\,P(x),\;
      [P(a),P(b)]\vdots a = b
      \;\vdash_{\exists! I}\; \exists! x\,P(x)
    \] \\[0.8ex]
  & \label{rule:UEE}Eliminierung
  & \[
      \exists! x\,P(x),\;
      [P(a),\forall y\,(P(y)\rightarrow a=y)]\vdots Q
      \;\vdash_{\exists! E}\; Q
    \] \\
\bottomrule
\end{tabularx}
\end{center}

\subsection{Theoreme, Definitionen und Axiome als Schlussregeln}

In diesem Abschnitt legen wir fest, wie bereits bewiesene Theoreme,
eingeführte Definitionen und Axiome später in Beweistabellen als
\emph{Schlussregeln} verwendet werden dürfen. Die Leitidee ist immer:
Eine Aussage der Form
\[
  P_1,\dots,P_n \vdash C
\]
wird metalogisch als Regel mit Voraussetzungen \(P_1,\dots,P_n\) und
Konklusion \(C\) gelesen. In der Beweistabelle erscheint diese Regel als
Index unter dem Schlussstrich; an die Stelle eines abstrakten Symbols
\(\Delta\) tritt jeweils die Nummer des entsprechenden Theorems,
der Definition oder des Axioms (z.\,B.\ \enquote{Thm.~2.34}).

\subsubsection{Theoreme als Regeln}

Sei in diesem Skript ein Theorem der Form
\[
  P_1,\dots,P_n \vdash C
\]
bewiesen und mit einer Nummer (z.\,B.\ \enquote{Thm.~s}) versehen.

In späteren Beweisen darf jede Zeile
\[
  I\ (m)\ C\ \text{Thm.~s}(j_1,\dots,j_n)
\]
als Anwendung dieses Theorems gelesen werden, sofern in den Zeilen
\(j_1,\dots,j_n\) die Formeln \(P_1,\dots,P_n\) abgeleitet wurden und
\(I\) genau die Vereinigung der Abhängigkeitsmengen dieser Zeilen ist.
Metalogisch entspricht dies genau der abstrakten Notation
\[
  P_1,\dots,P_n \;\vdash_{\text{Thm.~s}}\; C.
\]

\subsubsection{Explizite und partielle Definitionen als Regeln}

Sei eine neue Symbolfolge \(Q(x_1,\dots,x_n)\) explizit durch
\[
  Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n)
\]
eingeführt und als Definition ausgezeichnet (etwa durch
\verb|\FormulaDefAuto| oder \verb|\FormulaDefDeltaK|). Metalogisch liefert
diese Definition sofort die beiden Regeln
\[
  \varphi(x_1,\dots,x_n) \vdash Q(x_1,\dots,x_n),
  \qquad
  Q(x_1,\dots,x_n) \vdash \varphi(x_1,\dots,x_n).
\]
In der Beweistabelle dürfen wir dann Zeilen der Form
\[
  I\ (m)\ Q(x_1,\dots,x_n)\ \text{Def.~t}(j)
  \quad\text{bzw.}\quad
  I\ (m)\ \varphi(x_1,\dots,x_n)\ \text{Def.~t}(j)
\]
verwenden, sobald in Zeile \(j\) jeweils die andere Seite der Definition
hergeleitet wurde. Der Index \enquote{Def.~t} ist dabei die Nummer der
entsprechenden Definition.

\paragraph{Partielle Definition.}
Sei nun \(Q(x_1,\dots,x_n)\) nur \emph{unter einer Bedingung}
\(C(x_1,\dots,x_n)\) durch \(\varphi(x_1,\dots,x_n)\) festgelegt, etwa in
der Form
\[
  C(x_1,\dots,x_n) \rightarrow
  \bigl(Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n)\bigr).
\]
Intuitiv bedeutet dies:
\enquote{Immer wenn die Bedingung \(C\) erfüllt ist, darf \(Q\) wie
\(\varphi\) behandelt werden.}

Metalogisch ergeben sich daraus die beiden Regeln
\[
  C(x_1,\dots,x_n),\ \varphi(x_1,\dots,x_n)
    \vdash Q(x_1,\dots,x_n),
\]
bzw.
\[
  C(x_1,\dots,x_n),\ Q(x_1,\dots,x_n)
    \vdash \varphi(x_1,\dots,x_n).
\]
In der Beweistabelle sehen entsprechende Zeilen zum Beispiel so aus:
\[
  I\ (m)\ Q(x_1,\dots,x_n)\ \text{Def.~t}(j,k)
\]
bzw.
\[
  I\ (m)\ \varphi(x_1,\dots,x_n)\ \text{Def.~t}(j,k),
\]
wobei \(j\) auf eine Zeile mit \(C(x_1,\dots,x_n)\) und \(k\) auf die
jeweils andere Seite der partiellen Definition verweist.
Die Abhängigkeitsmenge \(I\) ist wieder die Vereinigung der
Abhängigkeitsmengen der referenzierten Zeilen.

\subsubsection{Implizite Definitionen und Axiome}

Bei einer \emph{impliziten} Definition wird ein neues Symbol \(\sigma\)
nicht durch eine einzelne Gleichung festgelegt, sondern durch eine Menge
von Axiomen
\[
  \Phi(\sigma) = \{\phi_i(\sigma) \mid i \in I\},
\]
die die gewünschten Eigenschaften von \(\sigma\) beschreiben. Jedes
\(\phi_i(\sigma)\) kann dabei entweder als reine Formel oder in
Sequenzschreibweise (z.\,B.\ \(\Gamma_i \vdash \Delta_i\)) angegeben sein.

\begin{itemize}
  \item Ist \(\phi_i(\sigma)\) eine Formel \(\psi(\sigma)\), so lesen wir
        sie als Regel
        \[
          \vdash_{\phi_i(\sigma)}\; \psi(\sigma)
        \]
        ohne Voraussetzungen. In der Beweistabelle kann also eine Zeile
        \[
          \;\ (m)\ \psi(\sigma)\ \text{Ax.~u}
        \]
        stehen, sobald \(\psi(\sigma)\) zu den Axiomen \(\Phi(\sigma)\)
        gehört (Index \enquote{Ax.~u} = Nummer des Axioms).
  \item Ist \(\phi_i(\sigma)\) in Sequenzform \(\Gamma_i \vdash \Delta_i\)
        notiert, so wird sie wie ein Theorem als Regel
        \[
          \Gamma_i \;\vdash_{\phi_i(\sigma)}\; \Delta_i
        \]
        verwendet. In der Beweistabelle sieht dies genau so aus wie bei
        Theoremen: die Prämissen \(\Gamma_i\) werden in vorherigen Zeilen
        abgeleitet, und in der neuen Zeile erscheint \(\Delta_i\) mit dem
        Index der entsprechenden Axiomnummer.
\end{itemize}

Damit erweitern implizite Definitionen und Axiome das Regelsystem des
natürlichen Schließens: neben den \enquote{logischen} Regeln (für
\(\land,\lor,\rightarrow,\leftrightarrow,\neg,\forall,\exists,=\) usw.)
stehen uns zusätzlich alle in \(\Phi(\sigma)\) formulierten Axiome als
weitere, fest verdrahtete Schlussregeln zur Verfügung. In der Praxis
werden diese Axiome in diesem Skript häufig mit der
\verb|\FormulaDefDeltaK|-Umgebung eingeführt; ihre Nummern können dann in
Beweistabellen genauso als Regelindizes verwendet werden wie Theorem- oder
Definitionsnummern.


\section{Verkettungen}

\subsection{Allgemeine Formulierung der verketteten Regelanwendung}
In den bisherigen Kapiteln haben wir eine Vielzahl von Inferenzregeln eingeführt, die jeweils genau \emph{einen} logischen Schritt ausführen. In der praktischen Beweisführung ist es jedoch oft wünschenswert, mehrere dieser Regeln \emph{hintereinander} in einem einzigen Schluss anzuwenden, um den Beweisfluss kompakter und übersichtlicher zu gestalten. Dieses Vorgehen wird im Folgenden als \emph{verkettete Regelanwendung} bezeichnet.

\begin{definition}[Verkettete Regelanwendung]
Sei eine Zeile \((m)\) einer Beweistabelle gegeben, in der bereits eine Aussage \(P\) steht. Angenommen, es existiere eine endliche Folge von Regeln \(R_1, R_2, \dots, R_k\), so dass man durch \emph{hintereinandergeschaltete Anwendung} dieser Regeln auf \(P\) eine Aussage \(Q\) gewinnt.

\paragraph{Annahmen}
\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & P & \dots \\
\end{array}
\]

\paragraph{Schluss}
\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
   i & (n) & Q & R_1R_2\cdots R_k(m) \\
\end{array}
\]
oder präziser, falls Platz vorhanden ist:
\[
\begin{array}{llll}
   i 
   & (n) 
   & Q 
   & R_1 \,\circ\, R_2 \,\circ\,\cdots\,\circ\, R_k \;(m) \\
\end{array}
\]
Hierbei bedeutet \(R_1 \circ R_2 \circ \dots \circ R_k\), dass zuerst \(R_1\) auf Zeile \(m\) angewendet wird, dann \(R_2\) auf das \emph{Ergebnis} von \(R_1\) usw.
\end{definition}

\begin{remark}
Die verkettete Regelanwendung ist \emph{keine} neue logische Regel im Sinne eines Axioms oder einer Erweiterung des Kalküls, sondern eine reine \emph{Abkürzungsnotation}. Sie ändert nicht die \emph{Inhalte} eines Beweises, sondern \emph{lediglich} die Darstellung und Zusammenfassung mehrerer Einzelschritte in einer kompakten Zeile.
\end{remark}

\subsection{Kettennotation}
\begin{definition}[Verallgemeinerte Transitivität zweier Symbole \(\sigma_1\) und \(\sigma_2\)]
\label{rule:Chain}
Seien \(\sigma_1,\sigma_2\) zwei binäre Symbole, die in einer Domäne \(D\) definiert sind.  
Wenn gezeigt wurde, dass für alle \(x,y,z \text{ aus } D\) gilt:
\[
\bigl(x \;\sigma_1\; y, \quad y \;\sigma_2\; z\bigr)
\quad\vdash\quad
x \;\sigma_1\; z,
\]
dann sind \(\sigma_1\) und \(\sigma_2\) \emph{(rechts-)verträglich} im Sinne einer verallgemeinerten Transitivität. Aus dieser Eigenschaft resultiert, dass man \(\sigma_1\) und \(\sigma_2\) in einer \emph{Kette} zusammensetzen kann, um in einem Schritt vom Anfangs\- zum End-Objekt zu schließen.
\end{definition}

\noindent
\textbf{Ergänzung (mehrere Operatoren).}  
Seien nun \(\sigma_1, \sigma_2, \dots, \sigma_o\) verschiedene binäre Symbole (Operatoren oder Relationen), für die alle passenden Transitivitätsaussagen dieser Art vorliegen. Insbesondere gelte für jedes \(i\in\{1,\ldots,o\}\):
\[
\bigl(x \;\sigma_1\; y \quad\land\quad y \;\sigma_i\; z\bigr)
\;\vdash\;
x \;\sigma_1\; z.
\]
Damit können wir nun aus einer ganzen Kettenfolge
\[
x_1 \;\sigma_{k_1}\; x_2,\quad
x_2 \;\sigma_{k_2}\; x_3,\quad
\dots,\quad
x_n \;\sigma_{k_n}\; x_{n+1}
\]
in einem \emph{abkürzenden} Schritt folgern, dass
\[
x_1 \;\sigma_1\; x_{n+1}
\]
gilt, sofern jeder Übergang durch die obigen Verträglichkeits- beziehungsweise Transitivitätseigenschaften gerechtfertigt ist.

\begin{remark}[Kettenregel \rChain{}]
Um diese verkettete Anwendung auch in einer Beweistabelle übersichtlich darzustellen, können wir eine Regel \(\rChain{}\) einführen. Sie verknüpft die Zeilen \(m_1,\dots,m_n\) des Beweises zu einem einzigen Schluss. 
\end{remark}

\noindent
\textbf{Formale Darstellung in der Beweistabelle}:  
Angenommen, wir haben folgende \(n\) Zeilen, in denen jeweils \(\sigma_{k_i}\) bereits abgeleitet wurde:

    \[
	\begin{array}{llclll}
            \multicolumn{6}{l}{\textbf{Zeile } m \text{:}}\\
             i_1 &  (m)  & \multicolumn{3}{l}{x_1\sigma_{k_1} x_2} & \dots \\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+1 \text{:}}\\
             i_2 &  (m+1)  & \multicolumn{3}{l}{x_2\sigma_{k_2} x_3} & \dots \\
            \multicolumn{6}{c}{}\\
            \multicolumn{6}{c}{\vdots}\\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+(n-1) \text{:}}\\
             i_n &  (m+(n-1))  & \multicolumn{3}{l}{x_n\sigma_{k_n} x_{n+1}} & \dots \\   
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+n \text{:}}\\
             i_1,i_2,\dots,i_n &  (m+n)  & \multicolumn{3}{l}{x_1\sigma_{k_1} x_{n+1}} & \rChain{m_1,m_n} 
        \end{array}
    \]

Dann soll in einer \emph{neuen} Zeile \(m_{n+1}\) durch Anwendung von \(\rChain\{m_1,\dots,m_n\}\) abgekürzt folgen:
\[
i_1,\dots,i_n \,(m_{n+1})\colon
\quad
x_1 \;\sigma_1\; x_{n+1}.
\]

Hierbei sind \(\boldsymbol{i_1, \dots, i_n}\) die Annahmelisten, welche die offenen Annahmen bezeichnen, von denen jede Zeile abhängt. 


\noindent
\textbf{Abkürzende Notation}:  
Manchmal werden die Zwischenschritte nur angedeutet, also ab Zeile \(m_2\) lediglich das \(\sigma_{k_2}\) und das Objekt \(x_3\) notiert:

    \[
	\begin{array}{llclll}
            \multicolumn{6}{l}{\textbf{Zeile } m \text{:}}\\
             i_1 &  (m)  & x_1&\sigma_{k_1}& x_2 & \dots \\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+1 \text{:}}\\
             i_2 &  (m+1)  &  &\sigma_{k_2}& x_3 & \dots \\
            \multicolumn{6}{c}{}\\
            \multicolumn{6}{c}{\vdots}\\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m_n \text{:}}\\
             i_n &  (m_n)  & &\sigma_{k_n}&x_{n+1} & \dots \\   
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+n \text{:}}\\
             i_1,i_2,\dots,i_n &  (m+n)  & x_1&\sigma_{k_1}& x_{n+1} & \rChain{m_1,m_n} 
        \end{array}
    \]
    
\begin{remark}[Geordnete Operatorenmengen und erweiterte Kettennotation]
In manchen Beweissituationen treten mehrere binäre Operatoren \(\sigma_1, \dots, \sigma_n\) auf, die durch eine Kette verbunden werden können (z.\,B.\ \(\sigma_1 = \to\) und \(\sigma_2 = \leftrightarrow\)) und für die jeweils die passende \emph{rechts-Verträglichkeit} nachgewiesen wurde. Um festzulegen, \emph{welcher} dieser Operatoren im letzten Schritt maßgebend ist, notieren wir sie als geordnetes \(n\)-Tupel:
\[
\boldsymbol{\Theta} = (\sigma_1, \sigma_2, \ldots, \sigma_n),
\]
wobei \(\sigma_1\) vorrangig für den finalen Schluss verwendet wird, sofern alle nötigen Verträglichkeitsnachweise \(\sigma_1\)-\(\sigma_j\) vorliegen. Dies ermöglicht eine klare Priorisierung und eine einheitliche Referenz, ohne bei jeder Mischkette erneut angeben zu müssen, welcher Operator \(\sigma_i\) im Endschluss \(\sigma_1\) \textbf{dominiert}.

\smallskip

\textbf{Symmetrische Operatoren:} Falls zusätzlich ein Operator \(\sigma\) \emph{symmetrisch} ist (d.\,h.\ \(x \,\sigma\, y \vdash y \,\sigma\, x\)), kann man in einer Kettennotation stillschweigend die Reihenfolge der Operanden vertauschen, ohne jedes Mal explizit auf die Symmetrie-Eigenschaft verweisen zu müssen. In der Tupeldarstellung \(\boldsymbol{\Theta}\) kann dies beispielsweise durch ein kleines Symbol oder einen Index \(\sigma^*\) angedeutet werden, um zu verdeutlichen, dass \(\sigma\) in beide Richtungen anwendbar ist.
\end{remark}

\subsubsection{Behandlung mehrfacher Gleichheiten}
In der Praxis können Gleichheitsausdrücke mehrere Terme involvieren, wie beispielsweise \(a = b = c\). Solche Ausdrücke sind jedoch nicht direkt in der Prädikatenlogik darstellbar. Stattdessen werden sie durch eine Verkettung von binären Gleichheiten ausgedrückt, die mittels der Konjunktion \(\land\) verbunden sind. Der Ausdruck \(a = b = c\) wird somit zu \(a = b \land b = c\).

\begin{definition}
\[
\forall a, b, c \left( a = b = c \right) := \left( a = b \land b = c \right)
\]
\end{definition}

\paragraph{Einführungsregel für das Identitätssymbol dreier Gleichheiten:}
\label{rule:rIIb}

\[
\begin{array}{llll}
	i & (1) & a = b \land b = c & \dots \\
 	i & (2) & a = b = c & \rIIb{1} \\
\end{array}
\]

\[
\begin{array}{llll}
	i & (1) & a = b & \dots \\
        i & (2) & b = c & \dots \\
 	i,j & (3) & a = b = c & \rIIb{1,2} \\
\end{array}
\]

\[
\begin{array}{llll}
	i & (1) & a = b & \dots \\
        i & (2) & a = c & \dots \\
 	i,j & (3) & a = b = c & \rIIb{1,2} \\
\end{array}
\]

\(i\) und \(j\) sind dabei Listen von Annahmen.


\paragraph{Eliminierungsregel für das Identitätssymbol dreier Gleichheiten:}
\label{rule:rIEb}

\[
\begin{array}{llll}
	i & (1) & a = b = c & \dots \\
        i & (2) & a = b & \rIEb{1} \\
 	i & (3) & a = c & \rIEb{1} \\
        i & (4) & b = c & \rIEb{1} \\
\end{array}
\]

\(i\) ist dabei eine Liste von Annahmen.

\subsubsection{Direkte Anwendung von Gleichheitsregeln auf Prädikate}

Falls eine Regel oder ein Theorem mit der Bezeichnung \textit{RegelName} die Gleichheit \(a = b\) ausdrückt, gilt automatisch, dass für jedes Prädikat \(P(x)\), das entweder \(P(a)\) oder \(P(b)\) beschreibt, direkt geschlossen werden kann, dass \(P(b)\) aus \(P(a)\) folgt (und umgekehrt).

\paragraph{Formulierung:}
Falls eine Regel oder ein Theorem die Gleichheit \(a = b\) ausdrückt, so kann sie ebenso in folgendem Kontext verwendet werden:

\[
\begin{array}{llll}
	i & (1) & a = b & \text{\textit{RegelName}} \\
	i & (2) & P(a) & \dots \\
	i & (3) & P(b) & \text{\textit{RegelName}} \\
\end{array}
\]

Analog dazu:

\[
\begin{array}{llll}
	i & (1) & a = b & \text{\textit{RegelName}} \\
	i & (2) & P(b) & \dots \\
	i & (3) & P(a) & \text{\textit{RegelName}} \\
\end{array}
\]

\paragraph{Vorteile:}
- Die explizite Verwendung der Eliminierungsregel (\(\rIE{}\)) entfällt.
- Gleichheiten können direkt in Beweisen genutzt werden, wodurch Beweise kompakter und übersichtlicher werden.



\subsection{Regeln für das Nicht-Gleichheitszeichen}

\begin{definition}[Nicht-Gleichheitszeichen]
\label{rule:Neq}
\[\forall t,u(t\neq u\coloneqq \neg(t=u))\]
\end{definition}


\subsection{Vereinfachung für das Nicht-Gleichheitszeichen}
Das Symbol \(\neq\), das die Ungleichheit von Elementen darstellt, ist in seiner Bedeutung offensichtlich und direkt verständlich. Es bedeutet einfach, dass zwei Elemente nicht gleich sind. Aufgrund dieser direkten und intuitiven Bedeutung können wir in vielen Fällen auf separate Einführungs- und Eliminierungsregeln für \(\neq\) verzichten.

Die Notation \(t \neq u\) ist äquivalent zu \(\neg(t = u)\) und kann direkt verwendet werden, ohne dass eine formale Regel angewendet werden muss. Dies vereinfacht den Umgang mit der Ungleichheit in logischen Argumentationen und Beweisen.

Daher können wir in Zukunft die Verwendung von \(t \neq u\) als eine unmittelbare Folgerung von \(\neg(t = u)\) und umgekehrt ansehen, ohne explizit eine Regel anzuwenden.
\section{Metadefinition}
\subsection{Was ist eine Metadefinition?}


Wir haben bisher gezeigt, dass man \emph{Definitionen} in einem formalen Kalkül auch wie \emph{Regeln} verwenden kann: Im Beweis taucht dann etwa ein „Einführungsschritt“ auf (wenn wir von der definierten Seite zum definierenden Ausdruck wechseln wollen) oder ein „Eliminierungsschritt“ (umgekehrt).  

\medskip

\textbf{Metadefinitionen} (auch \emph{meta-sprachliche Definitionen} genannt) sind hingegen \emph{außerhalb} des eigentlichen Kalküls angesiedelt. Man kann sie sich als reine „Abkürzungsvereinbarungen“ auf der \emph{Meta-Ebene} vorstellen:

\begin{itemize}
\item Sie \emph{erweitern} nicht das formale System und werden \emph{nicht} als Inferenzregel im Beweis verwendet.
\item Stattdessen legen sie fest, dass gewisse Schreibweisen (z.\,B.\ \(\forall x \in A(P(x))\)) \emph{bloß} Kurzformen für bereits bekannte Standardformen (\(\forall x\,(x\in A \to P(x))\)) sind.
\item In der Praxis darf man solche Metadefinitionen \emph{jederzeit} und ohne gesonderte Begründung verwenden – weil sie das System nicht verändern, sondern nur unser Schreiben/Lesen vereinfachen.
\end{itemize}

\bigskip

\noindent
\textbf{Beispiel für eine Metadefinition:}  
Wir vereinbaren einmalig:
\[
t \,\neq\, u
\;\coloneqq\;
\neg\bigl(t = u\bigr).
\]
Dies sagt auf Meta-Ebene nichts anderes als: 
\enquote{Wenn wir \(a\neq b\) schreiben, meinen wir in Wahrheit \(\neg (a = b)\).}  
Daher benötigen wir keine gesonderten \emph{Einführungs-} und \emph{Eliminierungsregeln} für \(\neq\), sondern können direkt
\(t \neq u\) verwenden.  
Aus Sicht eines formalen Beweises ist das \(\neq\)-Symbol gar kein neuer Bestandteil des Kalküls, sondern nur ein bequemes Schreibkürzel.

\bigskip

\begin{remark}
\textbf{Fazit:} Ob eine Definition \emph{innerhalb} des formalen Systems (als Regel) gebraucht wird oder nur \emph{meta-sprachlich} als Schreibabkürzung, hängt davon ab, ob wir daraus im Beweis eigenständige Schritte ableiten (z.B.\ \(\to\)-Einführung) oder ob wir nur die Notation vereinfachen. 
\end{remark}

\subsection{Meta-Notation für bedingte Quantifizierung}
In vielen mathematischen Texten begegnet man Schreibweisen wie
\[
\forall x \in A(P(x))\text{ oder }\forall x \neq y(Q(x,y)).
\]
Formal bedeutet dies immer, dass \emph{vor} der Aussage eine Bedingung (z.B.\;$x\in A$ oder $x \neq y$) steht, und \emph{danach} der zu beweisende Teil (z.B.\;$P(x)$, $Q(x,y)$). Damit ist klar: ``Für alle $x$ \emph{mit} $x\in A$ gilt $P(x)$.''

\bigskip

Eine präzise Art, dies \emph{ohne} viele Einzeldefinitionen formal einzuführen, ist eine \textbf{meta-sprachliche Sammel-Definition}. 

\begin{definition}[Meta-Notation für bedingte Quantoren]
Seien $\alpha(x)$ und $\beta(x)$ zwei Formeln der Prädikatenlogik (wobei $x$ jeweils eine freie Variable sein kann). Wir \textbf{vereinbaren} folgende \emph{Schreibkürzel}:

\begin{enumerate}
  \item \[
    \forall(\alpha(x))(\beta(x))
    \quad\coloneqq\quad
    \forall x\bigl(\alpha(x)\to\beta(x)\bigr).
  \]
  \item \[
    \exists (\alpha(x))(\beta(x))
    \quad\coloneqq\quad
    \exists x\bigl(\alpha(x)\land\beta(x)\bigr).
  \]
    \item \[
    \exists! (\alpha(x))(\beta(x))
    \quad\coloneqq\quad
    \exists! x\bigl(\alpha(x)\land\beta(x)\bigr).
  \]
\end{enumerate}
%
Diese \textbf{Meta-Notation} ist nur eine abkürzende Schreibweise und erweitert die Logik \emph{nicht}: In Beweisen oder in unserem formalen Kalkül kann man jederzeit diese Ausdrücke in die Standardform (rechts) übersetzen – und umgekehrt.
\end{definition}

\subsection{Meta-Notation: Klammerwegfall bei assoziativen Operatoren}

\section{Meta-Regeln und ihre Anwendung}
\subsection{Was sind Meta-Regeln?}
\emph{Meta-Regeln} sind bereits bewiesene Theoreme oder Schlussmuster, die wir wie „fertige Werkzeuge“ nutzen. Sie \emph{erweitern} das formale System \emph{nicht}, sondern ermöglichen nur eine kürzere Beweisführung: 
\begin{itemize}
\item Nach einmaliger Nennung darf man sie an jedem passenden Ort stillschweigend verwenden.  
\item Die formale Korrektheit bleibt gewahrt, da alles auf bereits Bewiesenem beruht.
\end{itemize}

\subsection{Meta-Regeln versus formale Inferenzregeln}
\label{sec:metaRegelnVsInferenzregeln}
\begin{itemize}
\item \textbf{Formale Inferenzregeln} (z.B.\ $\land$-Einführung) beschreiben direkt zulässige Beweisschritte.
\item \textbf{Meta-Regeln} sagen nur, dass bereits Bewiesenes \emph{wie ein abgekürztes Argument} wiederverwendet werden darf.  
\end{itemize}

\subsection{Vorgehen in der Praxis}
In fortgeschrittenen Texten werden Meta-Regeln oft am Kapitel- oder Beweisanfang angekündigt und dann nur noch per Verweis benutzt, um Dopplungen zu vermeiden. Dies macht komplexe Beweise kürzer und übersichtlicher, ohne an formaler Strenge einzubüßen.


\end{document}