%============================================================
%  Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte
%============================================================

\documentclass[main.tex]{subfiles}

\ifSubfilesClassLoaded{
  \directlua{
    thmlookup.registry_path = "registry/_B01.registry.tsv"
    thmlookup.debug_path    = "registry/_B01.debug.log"
    thmlookup.prepare_run()
  }
}{}



\title{Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte}
\author{Martin Kunze}
\date{today}

\begin{document}
\maketitle
\tableofcontents
\raggedbottom

\chapter{Aussagenlogik und Prädikatenlogik}

% =========================================================
\section{Formale Sprachen und Syntax}

In diesem Kapitel betrachten wir Logik als \emph{formale Sprache}:
Wir legen ein Alphabet von Symbolen fest und beschreiben mit
\emph{Bildungsregeln}, welche endlichen Symbolketten wir als
\emph{Formeln} zulassen. 

Die folgenden Abschnitte führen zunächst die \emph{Aussagensprache}
(Aussagenlogik) und danach die \emph{Prädikatensprache erster Stufe}
(Prädikatenlogik) ein. In beiden Fällen interessiert uns hier nur
die \textbf{Syntax} der Formeln. Fragen nach \enquote{Wahrheit} oder
\enquote{Bedeutung} der Formeln (Semantik) werden in späteren
Kapiteln behandelt.

% =========================================================
\section{Aussagen und Prädikatenlogik}

\subsection{Nichtlogische Symbole}

\paragraph{Aussagevariablen.}
Aus der Menge der uns zur Verfügung stehenden Symbole wählen wir einige
als Platzhalter und bezeichnen diese als \emph{Aussagevariablen}
(oder \emph{Aussagensymbole}). Typische Bezeichnungen sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  A & A_0 & A_1 & \dots \\
  B & B_0 & B_1 & \dots \\
  C & C_0 & C_1 & \dots
\end{array}
\]

\paragraph{Variablen.}
Typische Bezeichnungen für (individuelle) Variablen sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  x & x_0 & x_1 & \dots \\
  y & y_0 & y_1 & \dots \\
  z & z_0 & z_1 & \dots
\end{array}
\]

\paragraph{Konstantensymbole.}
Typische Bezeichnungen für Konstantensymbole sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  c & c_0 & c_1 & \dots
\end{array}
\]

\paragraph{Funktionssymbole.}
Typische Bezeichnungen für Funktionssymbole sind
\[
  f, f_0, f_1, \dots,\quad g, g_0, g_1, \dots
\]
Dabei hat jedes Funktionssymbol eine feste Stelligkeit (z.\,B.\ 
einstellig, zweistellig usw.), die wir im Kontext voraussetzen.


\paragraph{Prädikatensymbole.}
Typische Bezeichnungen für Prädikatensymbole sind
\[
\begin{array}{l@{\dsep}l@{\dsep}l@{\dsep}l}
  P & P_0 & P_1 & \dots \\
  Q & Q_0 & Q_1 & \dots \\
  R & R_0 & R_1 & \dots
\end{array}
\]
Dabei hat jedes Prädikatensymbol eine feste Stelligkeit (z.\,B.\ 
einstellig, zweistellig usw.), die wir im Kontext voraussetzen.

\subsection{Logische Symbole}

Wir reservieren ferner die folgenden Symbole:
\begin{itemize}
  \item die \emph{(logischen) Junktoren}
    \[
      \neg,\quad \land,\quad \lor,\quad \rightarrow,\quad \leftrightarrow,
    \]
  \item die \emph{(logischen) Quantoren}
    \[
      \forall,\quad \exists
    \]
  \item das \emph{Gleichheitszeichen}
    \[
      =
    \]
  \item die \emph{Klammerzeichen}
    \[
      ( \quad )
    \]
\end{itemize}

Zusätzlich verwenden wir das Symbol \(\exists!\) für den
\emph{Eindeutigkeitsquantor}. Es gehört nicht zur Grundsprache
\(\mathcal L\), sondern wird als Abkürzung verstanden, die sich
durch die bereits vorhandenen Symbole \(\exists,\forall,=\) ausdrücken
lässt (siehe Abschnitt über abgeleitete Regeln).

\subsection{Terme}

Aus Variablen, Konstantensymbolen und Funktionssymbolen bilden wir
\emph{Terme}. Informell sind das Ausdrücke wie
\(x\), \(c\), \(f(x)\), \(g(f(x),c)\) usw. Die folgenden
Bildungsregeln fassen dies zusammen.

\FormulaDefDelta[Terme der Prädikatenlogik]{%
  \begin{array}[t]{@{}l@{}}
    \text{(i)}\; x \text{ ist ein Term},\\[0.2em]
    \text{(ii)}\; c \text{ ist ein Term},\\[0.2em]
    \text{(iii)}\; f(t_1,\dots,t_n) \text{ ist ein Term}.
  \end{array}
}{
  \DeltaRow{Variablen}{x}
  \DeltaRow{Konstantensymbole}{c}
  \DeltaRow{Funktionssymbole}{f}
  \DeltaRow{Terme}{t_1 \dsep \dots \dsep t_n}
}

\subsection{Aussagen der Logik}

Aus Aussagevariablen sowie aus Prädikatensymbolen und Termen
bilden wir die \emph{Aussagen der Logik}.

\FormulaDefDelta[Aussagen der Logik]{%
  \begin{array}[t]{@{}l@{}}
    \text{(i)}\; R \text{ ist eine Aussage},\\[0.3em]
    \text{(ii)}\; P(t_1,\dots,t_n) \text{ ist eine Aussage, falls } P
               \text{ ein }n\text{-stelliges Prädikat}\\
    \qquad\text{und } t_1,\dots,t_n \text{ Terme sind},\\[0.4em]
    \text{(iii)}\; t_1 = t_2 \text{ ist eine Aussage, falls } t_1,t_2
               \text{ Terme sind},\\[0.4em]
    \text{(iv)}\; \neg A \text{ ist eine Aussage},\\[0.2em]
    \text{(v)}\; (A \land B)\dsep (A \lor B)\dsep
       (A \rightarrow B)\dsep (A \leftrightarrow B)\\
       \qquad\text{ sind Aussagen},\\[0.4em]
    \text{(vi)}\; \forall x\,A \dsep \exists x\,A
       \text{ sind Aussagen}.
  \end{array}
}{
  \DeltaRow{Aussagevariablen}{R}
  \DeltaRow{Prädikatensymbole}{P \dsep Q}
  \DeltaRow{Terme}{t_1 \dsep \dots \dsep t_n}
  \DeltaRow{Variablen}{x}
  \DeltaRow{Quantoren}{\forall \dsep \exists \dsep \exists!}
  \DeltaRow{Aussagen}{A \dsep B}
}
\begin{remark}
Im weiteren Verlauf verwenden wir die Begriffe \enquote{Aussage}
und \enquote{Formel} weitgehend synonym: Eine \emph{wohlgeformte
Formel} der Sprache \(\mathcal L\) nennen wir oft kurz einfach
\enquote{Aussage}.

Zusätzlich benutzen wir die Schreibweise \(\exists!x\,A\) als
metasprachliche Abkürzung für eine bereits definierte Formel, die
nur die Quantoren \(\forall,\exists\) und das Gleichheitszeichen
\((=)\) verwendet. Das Symbol \(\exists!\) gehört also nicht zur
Grundsprache \(\mathcal L\), sondern nur zur Meta\-Notation, ähnlich
wie das Ungleichheitszeichen \(\neq\) (vgl.\ Abschnitt über
Metadefinitionen).
\end{remark}


\chapter{Beweistheorie}

% =========================================================
\section{Einleitung zur Beweistheorie}

In den vorherigen Kapiteln haben wir die \emph{Syntax} der
Aussagenlogik und der Prädikatenlogik als formale Sprachen
beschrieben. In diesem Kapitel interessiert uns nun, wie man mit
solchen Formeln \emph{systematisch Beweise} führt.

Unter \enquote{Beweistheorie} verstehen wir die Untersuchung von
Regelsystemen (\emph{Kalkülen}), mit deren Hilfe sich aus gegebenen
Prämissen neue Formeln ableiten lassen. Im Mittelpunkt dieses
Kapitels steht das \emph{Kalkül des natürlichen Schließens}, das
sich an der intuitiven menschlichen Argumentation orientiert, aber
präzise und formal formuliert ist.

Unser Ziel ist es, Beweise nicht mehr nur informell in Worten zu
führen, sondern als \emph{endliche, nachvollziehbare Ableitungen}
mit klar festgelegten Schlussregeln aufzuschreiben.

% =========================================================
\section{Formale Sprache und Notation}

Wir arbeiten im Folgenden mit einer festen formalen Sprache
\(\mathcal L\), etwa der in Kapitel \enquote{Aussagenlogik und
Prädikatenlogik} eingeführten Aussagensprache oder
Prädikatensprache erster Stufe. Die dort beschriebenen Symbole,
Terme und Aussagen bilden den syntaktischen Rahmen, in dem wir
unsere Beweise formulieren.

Die Objekte, mit denen wir in der Beweistheorie arbeiten, sind
ausschließlich \emph{wohlgeformte Formeln} (Aussagen) von
\(\mathcal L\). Zur Bezeichnung solcher Formeln verwenden wir
typischerweise Großbuchstaben
\[
  A,B,C,\dots
\]
sowie griechische Buchstaben
\[
  \varphi,\psi,\chi,\dots
\]
für \enquote{beliebige} Formeln. Mengen von Formeln bezeichnen wir
mit \(\Gamma,\Delta,\dots\) und sprechen von \emph{Prämissenmengen}
oder \emph{Kontexten}.

\begin{remark}
In diesem Kapitel arbeiten wir auf zwei Ebenen:
\begin{itemize}
  \item Die \emph{Objektsprache} \(\mathcal L\) besteht aus den
        wohlgeformten Formeln, die wir syntaktisch definiert haben.
        Auf diesen Formeln operiert das Kalkül direkt.
  \item Daneben verwenden wir eine \emph{Metasprache}, in der wir
        insbesondere ein Symbol \(\vdash\) für \enquote{Ableitbarkeit}
        sowie einige weitere Kurzschreibweisen für Beweise und
        Subbeweise einführen werden (z.\,B.\ für Hilfsbeweise und
        Eigenvariablenbedingungen). Diese Metasymbole gehören nicht zur
        Objektsprache \(\mathcal L\), sondern dienen nur dazu, Beweise
        im Kalkül kompakt zu beschreiben.
\end{itemize}
\end{remark}

% =========================================================
\section{Grundbegriffe: Kalkül, Beweis und Argument}

Bevor wir das konkrete Kalkül des natürlichen Schließens einführen,
fassen wir einige Grundbegriffe zusammen, die für alle Kalküle
gleichartig formuliert werden können.

\begin{definition}[Kalkül]
Ein \textbf{(logischer) Kalkül} \(\mathcal C\) besteht aus
\begin{enumerate}
  \item einer formalen Sprache \(\mathcal L\),
  \item einer (eventuell leeren) Menge \(\mathsf{Ax}\) von Formeln
        in \(\mathcal L\) (den \textbf{Axiomen}),
  \item einer Menge \(\mathsf{Reg}\) von \textbf{Schlussregeln}.
\end{enumerate}
Im \emph{Kalkül des natürlichen Schließens}, das wir im Folgenden
verwenden, nehmen wir \(\mathsf{Ax} = \emptyset\); alle inhaltlichen
Axiome (z.\,B.\ die ZFC-Axiome) werden später als Teile von Theorien
bzw.\ impliziten Definitionen eingeführt.
\end{definition}

\begin{definition}[Beweis]
Sei \(\mathcal C\) ein Kalkül in der Sprache \(\mathcal L\).
Ein \textbf{Beweis} einer Formel \(\varphi\) aus einer Menge
\(\Gamma\) von Formeln ist eine endliche Folge
\[
  \varphi_1,\varphi_2,\dots,\varphi_n
\]
von Formeln in \(\mathcal L\) mit den folgenden Eigenschaften:
\begin{itemize}
  \item jedes \(\varphi_i\) ist entweder
    \begin{itemize}
      \item ein Element aus \(\Gamma\) (eine \textbf{Annahme}),
      \item ein Axiom aus \(\mathsf{Ax}\) oder
      \item durch Anwendung einer Schlussregel aus vorher in der
            Folge vorkommenden Formeln gewonnen;
    \end{itemize}
  \item die letzte Formel ist \(\varphi_n = \varphi\).
\end{itemize}
In diesem Fall schreiben wir
\[
  \Gamma \vdash_{\mathcal C} \varphi
\]
und sagen: \enquote{\(\varphi\) ist aus \(\Gamma\) im Kalkül
\(\mathcal C\) ableitbar}. Ist der Kalkül aus dem Zusammenhang
klar, lassen wir den Index \(\mathcal C\) meist weg und schreiben
nur \(\Gamma \vdash \varphi\).
\end{definition}

\begin{definition}[Argument und Gültigkeit]
Ein \textbf{Argument} ist ein geordnetes Paar \((\Gamma,\varphi)\),
wobei \(\Gamma\) eine Menge von Formeln (die \textbf{Prämissen})
und \(\varphi\) eine einzelne Formel (die \textbf{Schlussfolgerung})
ist.

Das Argument \((\Gamma,\varphi)\) heißt \textbf{(syntaktisch)
gültig} (im Kalkül \(\mathcal C\)), falls
\[
  \Gamma \vdash_{\mathcal C} \varphi
\]
gilt, das heißt, wenn es einen Beweis von \(\varphi\) aus \(\Gamma\)
gemäß den Schlussregeln von \(\mathcal C\) gibt.
\end{definition}

In den folgenden Abschnitten fixieren wir nun ein konkretes Kalkül,
nämlich das Kalkül des natürlichen Schließens, und entwickeln eine
Notation, mit der Beweise sowohl tabellarisch als auch in einer
kompakten metalogischen Kurzschreibweise dargestellt werden können.

% =========================================================
\section{Kalkül des natürlichen Schließens}

\subsection{Einführung}

In den vorangegangenen Abschnitten haben wir allgemeine Begriffe wie
\emph{Kalkül}, \emph{Beweis} und \emph{gültiges Argument} eingeführt.
Nun fixieren wir einen ganz bestimmten Kalkül, der im weiteren Verlauf
als unser \enquote{Standardbeweissystem} dienen soll: das
\emph{Kalkül des natürlichen Schließens}.

Dieser Kalkül arbeitet in einer fest gewählten formalen Sprache
\(\mathcal L\) (etwa der in Kapitel \enquote{Aussagenlogik und
Prädikatenlogik} eingeführten Aussagensprache oder
Prädikatensprache erster Stufe) und besitzt
\[
  \mathsf{Ax} = \emptyset,
\]
verwendet also \emph{keine Axiome}, sondern ausschließlich eine
vorgegebene Menge von \emph{Schlussregeln}. Alle inhaltlichen Axiome
(z.\,B.\ die ZFC-Axiome) treten später getrennt als Teile von
Theorien auf.

Wann immer wir im Folgenden (ohne Zusatz) \enquote{\(\Gamma \vdash \varphi\)}
oder \enquote{Beweis} sagen, ist damit die Ableitbarkeit bzw.\ ein Beweis
im Kalkül des natürlichen Schließens gemeint.

% ---------------------------------------------------------
\subsection{Tabellarische Beweisdarstellung nach Lemmon}

Im Folgenden verwenden wir eine tabellarische Darstellung der Beweise
(nach Lemmon). Jede Zeile einer Beweistabelle hat die Form
\[
  \begin{array}{llll}
    I & (m) & P & \text{Regelname } j_1,\dots,j_\ell
  \end{array}
\]
und ist wie folgt zu lesen:
\begin{itemize}
  \item \(m\) ist die \emph{Zeilennummer} (eine natürliche Zahl),
  \item \(P\) ist die in dieser Zeile auftretende Formel,
  \item \(I\) ist eine endliche Menge von Zeilennummern, die die noch offenen
        \emph{Annahmen} dieser Zeile kodiert,
  \item \(\text{Regelname } j_1,\dots,j_\ell\) gibt an, welche Schlussregel
        angewendet wurde und auf welche Zeilen \(j_1,\dots,j_\ell\) sich diese
        Anwendung bezieht.
\end{itemize}

In Worten: Eine Beweistabelle ist nichts anderes als eine Liste
von Zeilen. Jede Zeile enthält eine Formel, außerdem merken wir,
von welchen Annahmen diese Zeile noch abhängt und mit welcher
Schlussregel sie gewonnen wurde.

Eine Zeile ist eine \emph{Annahme}, wenn sie nur aus sich selbst abhängt und
noch keinen Schluss aus vorherigen Zeilen darstellt:
\[
  \{i\} \ (i)\ P \ \rA
\]
Hier ist \(P\) eine beliebige Formel, \(i\) ist die Zeilennummer, und
\(I=\{i\}\) markiert, dass die Zeile \(i\) nur von sich selbst als offener
Annahme abhängt.

\begin{definition}[Beweistabelle]
Eine \emph{Beweistabelle} ist eine endliche Sequenz von Zeilen
\[
  Z_1,\dots,Z_N,
\]
wobei jede Zeile \(Z_m\) (\(1 \le m \le N\)) die Form
\[
  Z_m = (I_m,\,(m),\,P_m,\,\text{Regelname}_m\,j_1,\dots,j_\ell)
\]
hat und folgenden Bedingungen genügt:
\begin{enumerate}
  \item \textbf{Annahmen.} Eine Zeile \(Z_i\) ist Annahme, wenn sie die Form
    \[
      \{i\}\ (i)\ P_i\ \rA
    \]
    \label{rule:A}
    hat.
  \item \textbf{Schlussregeln.} Jede nicht als Annahme eingeführte Zeile
    \(Z_m\) entsteht durch Anwendung einer der festgelegten Schlussregeln
    (oder eines bereits bewiesenen Theorems/einer Definition) auf vorherige
    Zeilen \(Z_{j_1},\dots,Z_{j_\ell}\) mit \(j_r < m\). Die Menge \(I_m\) der
    offenen Annahmen ergibt sich dabei aus den Mengen \(I_{j_1},\dots,I_{j_\ell}\)
    gemäß der jeweiligen Schlussregel.
\end{enumerate}
Eine Beweistabelle \emph{beweist} eine Formel \(R\) unter Annahmen
\(P_1,\dots,P_n\), wenn die letzte Zeile \(Z_N\) die Formel \(R\) enthält
und ihre Abhängigkeitsmenge \(I_N\) genau die Zeilennummern der Annahmen
\(P_1,\dots,P_n\) umfasst.
\end{definition}

% ---------------------------------------------------------
\subsection{Metalogische Kurznotation}

Die tabellarische Darstellung ist sehr präzise, aber für Erklärungen oft
zu feinmaschig. Daher verwenden wir eine vereinfachte \emph{metalogische
Notation}, die nur noch offene Annahmen, Hilfsbeweise und bestimmte
Nebenbedingungen sichtbar macht.

\begin{definition}[Sequenzen \(P_1,\dots,P_n \vdash R\)]
Seien \(P_1,\dots,P_n,R\) Formeln. Wir schreiben
\[
  P_1,\dots,P_n \vdash R,
\]
wenn es eine Beweistabelle gibt, deren letzte Zeile die Formel \(R\) enthält
und deren offene Annahmen genau \(P_1,\dots,P_n\) sind (in irgendeiner
Reihenfolge). Allgemeiner schreiben wir für eine Menge \(\Gamma\) von Formeln
\[
  \Gamma \vdash R,
\]
wenn es eine Beweistabelle mit letzter Zeile \(R\) gibt, deren offene Annahmen
genau die Formeln aus \(\Gamma\) sind.

In allen Ausdrücken der Form \(P_1,\dots,P_n \vdash R\) sind die
\(P_i\) also immer \emph{Formeln} der Sprache \(\mathcal L\). Zusätzliche
Symbole wie \([\,]\), \(\vdots\) oder \(\mid_x\) werden nur als
metasprachliche Markierungen an solchen Formeln angebracht.
\end{definition}

\begin{definition}[Syntaktische Äquivalenz \(\eqvdash\)]
Seien \(P\) und \(Q\) Formeln der Sprache \(\mathcal L\).
Wir schreiben
\[
  P \eqvdash Q,
\]
wenn sowohl \(P \vdash Q\) als auch \(Q \vdash P\) gilt. In diesem Fall
sagen wir, \(P\) und \(Q\) seien \emph{(syntaktisch) äquivalent} im
Kalkül des natürlichen Schließens.

Die Notation \(\eqvdash\) ist rein metasprachlich: Sie gehört nicht zur
Objektsprache \(\mathcal L\), sondern fasst nur kurz zusammen, dass zwei
Formeln wechselseitig aus einander herleitbar sind. In Formelschemata
werden wir Schreibweisen wie
\[
  P \eqvdash Q
\]
als Abkürzung für das Paar von Sequenzen \(P \vdash Q\) und
\(Q \vdash P\) verwenden.
\end{definition}

\begin{definition}[Subbeweise]
Seien \(P\) und \(Q\) Formeln. Wir schreiben
\[
  [P]\vdots Q,
\]
wenn es in einer Beweistabelle einen \emph{Subbeweis} gibt, der mit einer
Annahmezeile
\[
  \{k\}\ (k)\ P\ \rA
\]
beginnt und in einer Zeile mit Formel \(Q\) endet.

Wir erweitern diese Notation auf endlich viele Annahmen, indem wir
\[
  [P_1,\dots,P_k]\vdots Q
\]
schreiben, wenn es einen Subbeweis gibt, der mit den Annahmezeilen
\[
  \{k_1\}\ (k_1)\ P_1\ \rA,\quad
  \dots,\quad
  \{k_k\}\ (k_k)\ P_k\ \rA
\]
beginnt und in einer Zeile mit Formel \(Q\) endet. Der bisherige Fall
\([P]\vdots Q\) ist dabei der Spezialfall \(k=1\).

Wenn wir in einer Sequenz
\[
  P_1,\dots,P_{j-1},\,[S_1,\dots,S_k]\vdots Q,\,P_{j+1},\dots,P_n \vdash R
\]
schreiben, ist damit gemeint, dass
\begin{itemize}
  \item die zugrunde liegende Formel an der \(j\)-ten Stelle \(Q\) ist und
  \item es zu dieser Formel in der Beweistabelle einen Subbeweis gibt, der
        mit den Annahmen \(S_1,\dots,S_k\) beginnt und in \(Q\) endet.
\end{itemize}
Die Klammerung \([S_1,\dots,S_k]\vdots Q\) ist also nur eine Markierung für
diese besondere Situation, keine neue Art von Formel.
\end{definition}

\begin{example}
  Die Notation \([P]\vdots Q\) soll man sich so vorstellen:
  Wir machen einen Hilfsbeweis, in dem wir \(P\) annehmen
  und am Ende \(Q\) folgern. Diesen Block können wir später
  in einer Schlussregel (z.\,B.\ bei \(\rightarrow I\)) als
  Baustein verwenden.
\end{example}

\begin{definition}[Eigenvariablenbedingung \(P(x)\mid_x\)]
Sei \(P(x)\) eine Formel mit einer freien Variable \(x\). Wir schreiben
\[
  P_1,\dots,P_{j-1},\,P(x)\mid_x,\,P_{j+1},\dots,P_n \vdash R,
\]
wenn
\begin{itemize}
  \item die zugrunde liegende Formel an der \(j\)-ten Stelle genau \(P(x)\)
        ist und
  \item es eine Beweistabelle mit letzter Zeile \(R\) gibt, deren offene
        Annahmen genau \(P_1,\dots,P_n\) sind und in der \(x\) in keiner
        der Annahmen \(P_i\) mit \(i\neq j\) frei vorkommt.
\end{itemize}
Die Schreibweise \(P(x)\mid_x\) ist damit eine Kurzform für die übliche
Eigenvariablenbedingung; sie verändert die Liste der Annahmen
\(P_1,\dots,P_n\) nicht, sondern markiert nur den Eintrag \(P(x)\).
\end{definition}

\begin{definition}[Subbeweis mit Eigenvariablenbedingung \(P(x)\vdots Q\mid_x\)]
Seien \(P(x)\) und \(Q\) Formeln. Wir schreiben
\[
  P(x)\vdots Q\mid_x,
\]
wenn es einen Subbeweis \([P(x)]\vdots Q\) gibt, bei dem zusätzlich gilt:
\begin{itemize}
  \item In allen offenen Annahmen von \(Q\) außerhalb der speziellen Annahme
        \(P(x)\) kommt \(x\) nicht frei vor, und
  \item in der Schlussformel \(Q\) kommt \(x\) nicht frei vor.
\end{itemize}
Wenn wir diese Notation innerhalb einer Sequenz \(P_1,\dots,P_n \vdash R\)
verwenden, ist immer gemeint, dass an der betreffenden Stelle die Formel
\(Q\) steht und für den Beweis die oben beschriebene Situation vorliegt.
\end{definition}

\begin{remark}
Die Notationen \([P]\vdots Q\), \(P(x)\mid_x\) und \(P(x)\vdots Q\mid_x\)
erzeugen also keine neuen Arten von Formeln. Sie sind metasprachliche
Zusätze, mit denen wir bestimmte Eigenschaften der zugehörigen
Beweistabellen (Subbeweise, Eigenvariablenbedingungen) knapp
kennzeichnen. Die eigentlichen Annahmen bleiben immer Formeln
\(P_1,\dots,P_n\).
\end{remark}

% ---------------------------------------------------------
\subsection{Abstrakte Schreibweise für Schlussregeln}

Metalogisch beschreiben wir eine Schlussregel in der abstrakten Form
\[
  P_1,\dots,P_n \;\vdash_\Delta\; R.
\]
Dies ist so zu lesen:
\begin{quote}
  \(\Delta\) ist eine Schlussregel, die aus den Formeln
  \(P_1,\dots,P_n\) eine Formel \(R\) als neue Zeile ableiten darf.
\end{quote}
Die abstrakte Notation blendet die genaue tabellarische Form (Indizes,
Zeilennummern, Referenzen) aus. Sie sagt nur, \emph{welche} Formeln als
Voraussetzungen und welche Formel als Schluss auftreten.

In komplexeren Regeln können in dieser Notation auch die oben
eingeführten Markierungen vorkommen, etwa
\([P]\vdots Q\), \(P(x)\mid_x\) oder \(P(x)\vdots Q\mid_x\). In solchen
Fällen beschreibt ein Ausdruck
\[
  S_1,\dots,S_n \;\vdash_\Delta\; R
\]
eine Kombination aus offenen Annahmen, Subbeweisen und
Eigenvariablenbedingungen, wie in der vorherigen Untersektion erklärt.

% ---------------------------------------------------------
\subsection{Regelschemata und ihre tabellarische Gestalt}

\begin{remark}
Dieser Abschnitt ist technischer als die vorherigen. Er ist vor
allem dafür gedacht, später wirklich exakt nachweisen zu können,
dass jede unserer Regeln in Beweistabellen korrekt umgesetzt
werden kann. Wer zunächst nur ein Gefühl für die Beweisregeln
bekommen möchte, kann diesen Abschnitt beim ersten Lesen
überspringen und später zurückkehren.
\end{remark}

Schlussregeln formulieren wir im Allgemeinen in der Form
\[
  S_1,\dots,S_n \;\vdash_\Delta\; R,
\]
wobei jedes \(S_i\) eine der folgenden Schema-Premissen ist:
\begin{itemize}
  \item eine Formel \(P\),
  \item ein markierter Subbeweis \([P]\vdots Q\) (oder allgemeiner
        \([P_1,\dots,P_k]\vdots Q\)),
  \item eine Formel mit Eigenvariablenbedingung \(P(x)\mid_x\),
  \item ein Subbeweis mit Eigenvariablenbedingung \(P(x)\vdots Q\mid_x\).
\end{itemize}

Die Intuition ist:
\begin{quote}
  Immer wenn in einer Beweistabelle die in \(S_1,\dots,S_n\) beschriebene
  Konstellation realisiert ist, darf eine neue Zeile mit Formel \(R\)
  nach der Regel \(\Delta\) eingeführt werden.
\end{quote}

Für den einfachsten Fall, in dem alle \(S_i\) nur Formeln \(P_i\) sind,
kann man die Verbindung zur tabellarischen Darstellung so illustrieren:

\begin{RuleSchema}
\[
P_1,\dots,P_n \;\vdash_\Delta\; R
\]

\[
\leadsto\;
\boxed{%
  \begin{array}{llll}
    I_1&(m_{i_1})&P_{i_1}&\cdots \\
    I_2&(m_{i_2})&P_{i_2}&\cdots \\
       &        &\vdots  &        \\
    I_n&(m_{i_n})&P_{i_n}&\cdots \\
    I  &(m)      &R      &\Delta(m_{i_1},\dots,m_{i_n}) \\
  \end{array}
}
\]

\[
I := I_1 \cup \dots \cup I_n.
\]
\end{RuleSchema}

Hier markieren die Zeilen mit \(P_{i_1},\dots,P_{i_n}\) die Stellen in
der Beweistabelle, an denen die Premissen des Regelschemas tatsächlich
auftreten; die Mengen \(I_1,\dots,I_n\) kodieren die jeweils offenen
Annahmen dieser Zeilen. Die Schlusszeile mit Formel \(R\) trägt als
Abhängigkeitsmenge die Vereinigung aller bisherigen Abhängigkeitsmengen.

Tritt in einem Regelschema anstelle einer bloßen Formel \(P_j\) ein
Subbeweis \([A]\vdots P_j\) auf, so bedeutet dies tabellarisch, dass
die entsprechende Zeile
\[
  \begin{array}{llll}
    I_j & (m_{i_j}) & P_j & \cdots
  \end{array}
\]
in der obigen Box durch einen Block der Form
\[
\boxed{%
  \begin{array}{llll}
    k   & (k)       & A   & \rA   \\[0.2ex]
        &           &\vdots&      \\[0.2ex]
    I_s & (m_{i_s}) & P_j & \cdots
  \end{array}
}
\]
ersetzt wird. Dabei gilt:
\begin{itemize}
  \item \(k\) ist die Zeilennummer der Annahme \(A\) mit
        Abhängigkeitsmenge \(\{k\}\),
  \item \(m_{i_s}\) ist die Zeilennummer der Schlusszeile des Subbeweises
        mit Formel \(P_j\),
  \item \(I_s\) ist die zu dieser Schlusszeile gehörige
        Abhängigkeitsmenge und enthält insbesondere den Index \(k\).
\end{itemize}
Beim Übergang zur Schlusszeile mit Formel \(R\) wird die Annahme
\(A\) \emph{entladen}, indem man \(k\) aus dieser Menge entfernt.
Statt \(I_j\) verwendet man also die bereinigte Menge
\[
  I_j' := I_s \setminus \{k\}.
\]
Die Abhängigkeitsmenge der Schlusszeile ist dann
\[
  I := I_1 \cup \dots \cup I_{j-1} \cup I_j' \cup I_{j+1} \cup \dots \cup I_n.
\]

\medskip

Liegt in einem Regelschema ein Subbeweis mit mehreren Annahmen
\[
  [A_1,\dots,A_r]\vdots P_j
\]
vor, so beginnt der entsprechende Block analog mit den Annahmezeilen
\[
\boxed{%
  \begin{array}{llll}
    \{k_1\} & (k_1) & A_1 & \rA \\[0.2ex]
           &       &\vdots&     \\[0.2ex]
    \{k_r\} & (k_r) & A_r & \rA
  \end{array}
}
\]
wobei \(I_s\) dann alle zu diesen Annahmen gehörigen Indizes
\(k_1,\dots,k_r\) enthält. Beim Entladen werden diese gemeinsam aus
\(I_s\) entfernt.

\medskip

Wenn eine Schema-Premisse in der abstrakten Notation als
\(P(x)\mid_x\) notiert ist, so betrachten wir wieder die
entsprechende Zeile
\[
  \begin{array}{llll}
    I_j & (m_{i_j}) & P(x) & \cdots
  \end{array}
\]
in der Beweistabelle. Die Markierung \(P(x)\mid_x\) bedeutet dann
tabellarisch:
\begin{itemize}
  \item Die Zeile \(m_{i_j}\) trägt die Formel \(P(x)\),
  \item für jede Zeilennummer \(\ell \in I_j\), deren Zeile eine
        \emph{Annahme} ist und mit \(m_{i_j}\) als offene Annahme
        verbunden bleibt, kommt die Variable \(x\) in der dortigen
        Formel nicht frei vor.
\end{itemize}
Mit anderen Worten: In allen offenen Annahmen, von denen die Zeile
\(m_{i_j}\) abhängt, ist \(x\) (abgesehen von der Formel \(P(x)\)
selbst) nicht frei. Dies ist genau die Eigenvariablenbedingung, die
bei der Allquantor-Einführung \(\forall I\) verwendet wird.

\medskip

Tritt schließlich in einem Regelschema eine Schema-Premisse der Form
\(P(x)\vdots Q\mid_x\) auf, so kombinieren wir die beiden oben
beschriebenen Situationen. Tabellarisch wird die entsprechende
Zeile
\[
  \begin{array}{llll}
    I_j & (m_{i_j}) & Q & \cdots
  \end{array}
\]
durch einen Subbeweisblock
\[
\boxed{%
  \begin{array}{llll}
    k   & (k)       & P(x) & \rA   \\[0.2ex]
        &           &\vdots&       \\[0.2ex]
    I_s & (m_{i_s}) & Q    & \cdots
  \end{array}
}
\]
ersetzt, wobei wiederum \(m_{i_s}\) die Schlusszeile des Subbeweises
ist und \(I_s\) die zugehörige Abhängigkeitsmenge. Die Markierung
\(\mid_x\) steht dabei für die zusätzliche Eigenvariablenbedingung:
\begin{itemize}
  \item In allen offenen Annahmen, deren Zeilennummer in
        \(I_s \setminus \{k\}\) liegt, kommt \(x\) nicht frei vor,
  \item in der Schlussformel \(Q\) kommt \(x\) ebenfalls nicht frei vor.
\end{itemize}
Beim Übergang zur Schlusszeile mit Formel \(R\) wird wie oben die
Annahme \(P(x)\) entladen, indem man \(k\) aus \(I_s\) entfernt und
die bereinigte Menge
\[
  I_j' := I_s \setminus \{k\}
\]
an die Stelle von \(I_j\) setzt. Die Gesamtabhängigkeitsmenge der
Schlusszeile erhält man dann wieder durch Vereinigung aller
auftretenden Indexmengen (mit \(I_j\) ersetzt durch \(I_j'\)).

\medskip

In den nachfolgenden Abschnitten formulieren wir alle konkreten
Schlussregeln des natürlichen Schließens in dieser Kurznotation.
Die Beispiele werden jeweils zeigen, wie die Regelschemata in
Beweistabellen konkret aussehen und wie Subbeweise sowie
Eigenvariablenbedingungen in der tabellarischen Darstellung
realisiert werden.
% =========================================================
\section{Sätze, Axiome und Definitionen}

\begin{DeltaContext}{In diesem Abschnitt verwendete Symbole}
  \DeltaRow{Aussagen}{A \dsep B \dsep P_1 \dsep \dots \dsep P_n \dsep R \dsep \varphi}
  \DeltaRow{Prämissenmengen}{\Gamma}
  \DeltaRow{Mengen}{M \dsep N \dsep X \dsep Y}
  \DeltaRow{Funktionen}{F \dsep G}
\end{DeltaContext}

In diesem Abschnitt gehen wir systematischer darauf ein,
wie wir im Skript wichtige Aussagen hervorheben und welche
Rollen \enquote{Theoreme}, \enquote{Axiome} und \enquote{Definitionen}
dabei spielen. Wer sich zunächst auf die praktische Verwendung
konzentrieren möchte, kann die späteren Abschnitte über implizite
Definitionen und das Iota-Symbol beim ersten Lesen überspringen.

Im weiteren Verlauf des Skripts werden vor allem
\begin{itemize}
  \item \textbf{Axiome} mathematischer Theorien (z.\,B.\ ZFC),
  \item \textbf{Sätze/Theoreme} (ggf.\ auch Lemma, Korollar),
  \item \textbf{Definitionen} neuer Begriffe
\end{itemize}
hervorgehoben und nummeriert.

Jeder solcher Block hat im Wesentlichen zwei Bestandteile:
\begin{enumerate}
  \item einen \textbf{formalen Kern}, also entweder
        \begin{itemize}
          \item eine einzelne Formel \(\varphi\) in \(\mathcal L\) oder
          \item eine Sequenz\-Aussage \(P_1,\dots,P_n \vdash R\),
                ggf.\ mit den in der vorigen Sektion eingeführten
                Markierungen \([P]\vdots Q\), \(P(x)\mid_x\),
                \(P(x)\vdots Q\mid_x\), wenn es um
                \emph{metalogische} Aussagen über das Kalkül geht;
        \end{itemize}
  \item kurze \textbf{Kontextzeilen}, in denen wir angeben, wie die
        auftretenden Buchstaben zu lesen sind, z.\,B.
        \[
          \text{Mengen: } M,N \qquad
          \text{Funktionen: } F\colon M\to N.
        \]
\end{enumerate}
% (B01.tex) Kapitel "Beweistheorie", Section "Sätze, Axiome und Definitionen"
% Direkt nach der Aufzählung, die die Kontextzeilen erklärt,
% und vor \begin{definition}[Theorem]

Die Kontextzeilen sind metasprachliche Angaben zum Eintrag.
Meist sind es reine \emph{Deklarationen} (Typisierung/Sortierung der freien
Buchstaben). In einigen Abschnitten verwenden wir zusätzlich
\emph{Kontextprämissen}; diese gelten im jeweiligen Eintrag als offene
Annahmen und dürfen im Beweis wie Prämissen benutzt werden.

\subsubsection{Kontextzeilen: Deklarationen und Kontextprämissen}

\begin{remark}
Die Zeilen oberhalb einer formalen Aussage nennen wir \emph{Kontextzeilen}.
Wir unterscheiden:
\begin{itemize}
\item \emph{Deklarationen}: legen Parameter/Symbole fest (ohne logischen Gehalt).
\item \emph{Kontextprämissen}: sind im Kontextblock durch \(\triangleright\) markiert und
gelten im gesamten Eintrag als offene Voraussetzungen.
\end{itemize}
Ein Eintrag mit formaler Aussage \(\Gamma \vdash \varphi\) und Kontextblock \(\Delta\)
wird als
\[
  \mathsf{Prem}(\Delta),\,\Gamma \vdash \varphi
\]
verstanden, wobei \(\mathsf{Prem}(\Delta)\) genau die im Kontextblock mit
\(\triangleright\) markierten Aussagen bezeichnet.
Im Beweis dürfen Kontextprämissen ohne eigene \rA-Zeile verwendet werden.
\end{remark}




\begin{definition}[Theorem]
Ein \textbf{Theorem} ist im weiteren Sinn jede hervorgehobene
Aussage, deren formaler Kern entweder
\begin{itemize}
  \item eine Formel \(\varphi\) in \(\mathcal L\) oder
  \item eine Sequenz\-Aussage \(P_1,\dots,P_n \vdash R\) (ggf.\ mit
        Markierungen wie \([P]\vdots Q\) oder \(P(x)\mid_x\))
\end{itemize}
ist und für die es im Kalkül des natürlichen Schließens einen
Beweis gibt.

Im Text wird ein Theorem durch eine Überschrift wie
\[
  \text{Theorem 3.188}
\]
gekennzeichnet, gefolgt von
\begin{itemize}
  \item dem Kontext (z.\,B.\ \enquote{Mengen:
        \(M,N\)}, \enquote{Funktionen: \(F\colon M\to N\)}),
  \item und der eigentlichen Aussage (Formel oder Sequenz), z.\,B.
        \[
          (x,y)\in F \;\vdash\; (x,y)\in M\times N
        \]
        oder
        \[
          P_1\lor P_2\lor P_3,\; [P_1]\vdots R,\; [P_2]\vdots R,\;
          [P_3]\vdots R \;\vdash\; R.
        \]
\end{itemize}
Danach folgt gewöhnlich der Beweis, meist in tabellarischer Form.
\end{definition}

\begin{definition}[Axiom]
Ein \textbf{Axiom} ist eine Formel \(\varphi\) der Sprache
\(\mathcal L\), die wir in einer Theorie \emph{ohne Beweis} als
gültig voraussetzen. Im Sinne der oben gegebenen Kalkül\-Definition
(\(\mathsf{Ax}\subseteq \mathrm{Formeln}(\mathcal L)\)) sind Axiome
also stets \emph{Formeln}, keine Sequenzen.

Im Text wird ein Axiom durch eine Überschrift wie
\[
  \text{Axiom 3.8 (Menge geordneter Paare)}
\]
gekennzeichnet. 

Es folgt der Kontext, z.\,B.\ in der Form
\[
  \text{Mengen: } M,N
  \qquad
  \text{Relationen/Funktionen: } F \subseteq M \times N.
\]
Danach folgt die betreffende Formel \(\varphi\).

Wir verwenden die Kurznotation \(\vdash\), \([P]\vdots Q\),
\(\mid_x\) bei Axiomen im Allgemeinen \emph{nicht}; wo wir Axiome
gelegentlich in Sequenzform umformulieren, ist dies ausdrücklich
als \emph{metalogische} Umschreibung zu verstehen, nicht als Teil
der eigentlichen Axiomformulierung.
\end{definition}

\begin{remark}
Damit bleiben die \enquote{aussagenlogischen Schlussregeln} des
natürlichen Schließens klar von Axiomen getrennt: Sie gehören
zur Menge \(\mathsf{Reg}\) des Kalküls und werden mit Hilfe der
metalogischen Kurznotation beschrieben, sind aber selbst
\emph{keine} Axiome einer Theorie. Der Begriff des Kalküls aus
der oben gegebenen Definition bleibt dadurch unverändert korrekt.
\end{remark}

\begin{definition}[Definition]
Eine \textbf{Definition} führt einen neuen Begriff oder ein neues
Symbol ein, indem angegeben wird, durch welche Eigenschaften es
bestimmt ist. Im Text wird eine Definition durch eine Überschrift
wie
\[
  \text{Definition 3.5 (Teilmenge)}
\]
gekennzeichnet. Danach folgen der Kontext (z.\,B.\ \enquote{Mengen:
\(M,N\)}) und eine Formel, die den neuen Begriff beschreibt, etwa
\[
  M \subseteq N \coloneqq \forall x\,(x\in M \rightarrow x\in N).
\]
In diesem Beispiel wird das Symbol \(\subseteq\) eingeführt und
als Abkürzung für eine bereits bekannte Formel erklärt.

In Definitionsblöcken verwenden wir in der Regel keine
Subbeweis\- oder Eigenvariablen\-Markierungen wie \([P]\vdots Q\)
oder \(\mid_x\), da Definitionen vor allem neue Schreibweisen
fixieren. Streng genommen wäre ihre Verwendung dort aber möglich,
da auch Definitionen letztlich durch Formeln in \(\mathcal L\)
charakterisiert werden.
\end{definition}

% =========================================================
\section{Arten von Definitionen}

\begin{DeltaContext}{In diesem Abschnitt verwendete Symbole}
  \DeltaRow{Aussagen}{A \dsep B \dsep C \dsep \varphi}
  \DeltaRow{Prädikatensymbole}{P \dsep Q \dsep R}
  \DeltaRow{Terme}{t_1 \dsep \dots \dsep t_n}
  \DeltaRow{Neue Symbole}{S \dsep \sigma \dsep \iota}
\end{DeltaContext}

In diesem Abschnitt beschreiben wir, in welcher Form wir neue
Symbole zur bereits festgelegten Sprache \(\mathcal L\) hinzufügen.
Alle Definitionen sind dabei \emph{syntaktisch} zu verstehen:
Das zugrundeliegende logische Kalkül (insbesondere die
Schlussregeln des natürlichen Schließens) bleibt unverändert, wir
führen lediglich neue Schreibweisen ein, die durch bereits
vorhandene Ausdrücke erklärt werden.

\subsection{Explizite Definitionen}

\begin{definition}[Explizite Definition]
Sei \(\varphi(t_1,\dots,t_n)\) eine wohlgeformte Formel der
Sprache \(\mathcal L\), in der Terme \(t_1,\dots,t_n\) vorkommen
dürfen, und sei \(S\) ein neues \(n\)-stelliges Symbol (z.\,B.\ ein
neues Prädikatensymbol oder ein neues Funktionssymbol).

Eine \textbf{explizite Definition} von \(S\) schreiben wir in
metasprachlicher Notation als
\[
  S(t_1,\dots,t_n) \coloneqq \varphi(t_1,\dots,t_n).
\]
Damit vereinbaren wir: Überall dort, wo der Ausdruck
\(S(t_1,\dots,t_n)\) vorkommt, darf er als Abkürzung für
\(\varphi(t_1,\dots,t_n)\) gelesen werden – und umgekehrt.
Das Symbol \(\coloneqq\) gehört dabei nicht zur Sprache
\(\mathcal L\), sondern kennzeichnet lediglich eine Definition.
\end{definition}

\begin{remark}
Formal kann man eine explizite Definition durch eine Formel
\[
  \forall t_1,\dots,t_n\,
    \bigl( S(t_1,\dots,t_n) \leftrightarrow
           \varphi(t_1,\dots,t_n) \bigr)
\]
in der Sprache \(\mathcal L\) ausdrücken. Für unser Kalkül
interpretieren wir eine solche Definition syntaktisch über die
beiden \emph{definitorischen Regelschemata}
\[
  \varphi(t_1,\dots,t_n) \vdash S(t_1,\dots,t_n)
  \qquad\text{und}\qquad
  S(t_1,\dots,t_n) \vdash \varphi(t_1,\dots,t_n).
\]
Das bedeutet: In Beweisen dürfen wir \(S(t_1,\dots,t_n)\)
jederzeit durch\\ \(\varphi(t_1,\dots,t_n)\) ersetzen und umgekehrt.

Ein typisches Beispiel ist die Definition der Teilmengenrelation
\[
  A \subseteq B \coloneqq \forall x\,(x\in A \rightarrow x\in B).
\]
Syntaktisch erlaubt uns diese Definition, zwischen
\(A \subseteq B\) und \(\forall x\,(x\in A \rightarrow x\in B)\)
hin- und herzuschalten.
\end{remark}

\subsection{Partielle Definitionen}

\begin{definition}[Partielle Definition]
Seien \(C(t_1,\dots,t_n)\) und\\ \(\varphi(t_1,\dots,t_n)\) wohldefinierte
Aussagen in der Sprache \(\mathcal L\), in denen Terme
\(t_1,\dots,t_n\) vorkommen dürfen, und sei \(S\) wieder ein neues
\(n\)-stelliges Symbol.

Eine \textbf{partielle Definition} von \(S\) schreiben wir
metasprachlich als
\[
  C(t_1,\dots,t_n) \rightarrow
  \bigl(S(t_1,\dots,t_n) \coloneqq \varphi(t_1,\dots,t_n)\bigr).
\]
Damit wird \(S(t_1,\dots,t_n)\) nur \emph{unter der Bedingung}
\(C(t_1,\dots,t_n)\) als Abkürzung für \(\varphi(t_1,\dots,t_n)\)
verstanden; außerhalb des durch \(C\) beschriebenen Bereichs bleibt
\(S\) unbestimmt.
\end{definition}

\begin{remark}
Auch partielle Definitionen können wir syntaktisch über
Regelschemata fassen. Aus
\[
  C(t_1,\dots,t_n) \rightarrow
  \bigl(S(t_1,\dots,t_n) \leftrightarrow \varphi(t_1,\dots,t_n)\bigr)
\]
ergeben sich etwa die beiden Regeln
\[
  C(t_1,\dots,t_n),\; \varphi(t_1,\dots,t_n)
    \vdash S(t_1,\dots,t_n)
\]
\[
  C(t_1,\dots,t_n),\; S(t_1,\dots,t_n)
    \vdash \varphi(t_1,\dots,t_n).
\]
Explizite Definitionen erhält man als Spezialfall durch die stets
wahre Bedingung \(C(t_1,\dots,t_n)\), also informell
\(C \equiv \text{\enquote{immer wahr}}\).
\end{remark}

\subsection{Implizite Definitionen}

\begin{definition}[Implizite Definition]
Sei \(\sigma\) ein neues Symbol (z.\,B.\ ein Prädikaten- oder
Funktionssymbol). Eine endliche Menge von Formeln
\[
  \Phi(\sigma) = \{\phi_1(\sigma),\dots,\phi_k(\sigma)\}
\]
in einer erweiterten Sprache, in der \(\sigma\) vorkommen darf,
heißt \textbf{implizite Definition} von \(\sigma\), wenn wir
vereinbaren:
\[
  \sigma \text{ soll genau so beschaffen sein, dass alle }
  \phi_i(\sigma) \text{ gelten.}
\]
Die Formeln in \(\Phi(\sigma)\) spielen dann die Rolle von
\enquote{Axiomen}, die den Begriff \(\sigma\) charakterisieren.
\end{definition}

\begin{remark}
Wichtige Beispiele für implizite Definitionen in unserem Skript
sind:
\begin{itemize}
  \item die Zermelo–Fraenkel-Axiome als implizite Definition
        des zweistelligen Prädikats \(\in\) (Begriff der Menge),
  \item die Axiome
        \[
          F \subseteq A \times B,\quad
          (x,y)\in F,\,(x,z)\in F \vdash y=z,\quad
          x\in A \vdash \exists y\,(x,y)\in F
        \]
        als implizite Definition des Begriffs \enquote{Funktion}
        \(F\colon A\to B\).
\end{itemize}
Ob eine gegebene Axiomenmenge \(\Phi(\sigma)\) tatsächlich eine
Interpretation von \(\sigma\) \emph{existierend} und
\emph{eindeutig} festlegt, ist eine Frage der Semantik der
jeweiligen Theorie. Diese Fragen werden wir erst später, insbesondere
im Mengenlehre-Band, präzise behandeln.

In den Beispielen schreiben wir gelegentlich Sequenzen wie
\((x,y)\in F,\,(x,z)\in F \vdash y=z\) als Kurzform für Aussagen,
die sich durch eine einzelne Formel ausdrücken lassen, etwa
\[
  \forall x,y,z\;\bigl(((x,y)\in F \land (x,z)\in F) \rightarrow y=z\bigr).
\]
Die eigentlichen Axiome einer Theorie sind stets Formeln in
\(\mathcal L\); Sequenzschreibweisen dienen nur der
metasprachlichen Darstellung.
\end{remark}

\begin{remark}
Viele rekursive Definitionen (etwa die Definition von Addition
und Multiplikation auf den natürlichen Zahlen) lassen sich als
Spezialfälle impliziter Definitionen auffassen: Die Gleichungen
für Rekursionsanfang und Rekursionsschritt bilden zusammen die
Menge \(\Phi(\sigma)\). Ob diese Gleichungen eine eindeutige
Funktion bestimmen, ergibt sich dann aus allgemeinen Existenz- und
Eindeutigkeitssätzen (z.\,B.\ dem Dedekindschen
Rekursionstheorem), die wir erst nach Einführung der natürlichen
Zahlen im Mengenlehre-Band formulieren.
\end{remark}

\subsection{Das Iota-Symbol und Iota-Definitionen}

In vielen Situationen möchten wir ein Objekt bezeichnen, das durch
eine Eigenschaft eindeutig charakterisiert ist. Dazu verwenden wir
ein spezielles Bindungssymbol.

\begin{definition}[Iota-Symbol]
Sei \(P(x)\) eine Aussage über \(x\). Falls es \emph{genau ein}
Objekt mit dieser Eigenschaft gibt, schreiben wir
\[
  \iota x\,P(x)
\]
für \enquote{das eindeutige \(x\), für das \(P(x)\) gilt}. Formal
setzen wir voraus, dass die Existenz- und Eindeutigkeitsaussage
\[
  \exists! x\,P(x)
\]
in der betreffenden Theorie bereits bewiesen oder als Axiom
vorausgesetzt ist.
\end{definition}

\begin{definition}[Iota-Definition]
Sei \(P(x)\) eine wohldefinierte Eigenschaft und \(\sigma\) ein
neues Konstantensymbol. Wenn \(\exists! x\,P(x)\) gilt, können wir
\[
  \sigma \coloneqq \iota x\,P(x)
\]
als \textbf{Iota-Definition} von \(\sigma\) einführen. Dabei ist
\(\sigma\) das \emph{Definiendum} und \(\iota x\,P(x)\) das
\emph{Definiens}. Syntaktisch interpretieren wir dies wie bei
expliziten Definitionen: Überall, wo \(\sigma\) vorkommt, darf
stattdessen der Ausdruck \(\iota x\,P(x)\) stehen und umgekehrt.
\end{definition}

\begin{remark}
Iota-Definitionen sind ein Spezialfall expliziter Definitionen
für Konstanten: eine bewiesene oder geforderte Aussage der Form
\(\exists! x\,P(x)\) wird in einem neuen Symbol \(\sigma\)
\enquote{gebündelt}. Typische Beispiele sind:
\begin{itemize}
  \item die Definition der leeren Menge als
        \(\emptyset \coloneqq \iota O\,\forall x\,(x\notin O)\),
  \item die Definition von Supremum, Infimum oder anderen
        eindeutig bestimmten Objekten in geordneten Strukturen.
\end{itemize}
\end{remark}

\subsection{Schematische Schreibweise mit Parametern}

In vielen Axiomen und Sätzen lassen wir einige Symbole (etwa \(A,B,F,x\))
\emph{frei} im formalen Kern stehen und geben in den Kontextzeilen
nur an, wie diese Symbole zu lesen sind, z.\,B.

\DeltaBlockFromRows{
  \DeltaRow{Mengen}{A \dsep B}
  \DeltaRow{Funktionen}{F\colon A \to B}
}
\leavevmode\newline
Solche Blöcke sind stets \emph{schematisch} zu verstehen: Die freien
Buchstaben \(A,B,F,\dots\) stehen für beliebige Objekte der jeweils
angegebenen Art. Formal entspricht dies einer stillschweigenden
Allquantifikation über diese Parameter.

\begin{example}[Extensionalität]
Das Axiom der Extensionalität notieren wir etwa als
\[
  \forall x\,(x \in A \leftrightarrow x \in B) \vdash A = B,
\]
mit Kontextzeile:

\DeltaBlockFromRows{
  \DeltaRow{Mengen}{A \dsep B}
}
\leavevmode\newline
Die präzise Lesart in der Sprache der Mengenlehre ist
\[
  \forall A\,\forall B\,
    \bigl( \forall x\,(x \in A \leftrightarrow x \in B)
           \rightarrow A = B \bigr).
\]
Die Sequenzschreibweise ist also eine metasprachliche Kurzform
für diese vollständig quantifizierte Formel, wobei \(A,B\) als
beliebige, aber feste Mengen zu verstehen sind.
\end{example}

\begin{remark}
Allgemein gilt: In den Kontextzeilen eines Theorems oder Axioms
werden die freien Buchstaben des formalen Kerns aufgelistet und
ihrem Typ zugeordnet (Mengen, Funktionen, Prämissenmengen usw.).
Eine Aussage der Form
\[
  \Phi(A_1,\dots,A_n) \vdash \Psi(A_1,\dots,A_n)
\]
ist dann als Kurzform der vollständig quantifizierten Formel
\[
  \forall A_1 \dots \forall A_n\,
  \bigl(\Phi(A_1,\dots,A_n) \rightarrow
        \Psi(A_1,\dots,A_n)\bigr)
\]
zu verstehen (gegebenenfalls ergänzt um weitere in den
Kontextzeilen genannte Bedingungen).

In Beweisen arbeiten wir meist direkt mit der Sequenzschreibweise:
Sobald für konkrete Objekte \(A_1,\dots,A_n\) die Voraussetzung
\(\Phi(A_1,\dots,A_n)\) gezeigt ist, darf die Schlussformel
\(\Psi(A_1,\dots,A_n)\) mit Verweis auf das entsprechende Theorem
oder Axiom eingeführt werden. Die dazu gehörigen Allquantor- und
Implikationsschritte werden nicht jedes Mal ausgeschrieben, sondern
durch das schematische \(\vdash\) mitabgedeckt.
\end{remark}


\section{Übersicht über die elementaren Schlussregeln}

\begin{center}
  \renewcommand{\arraystretch}{1.3}
  \begin{tabularx}{\textwidth}{@{}l l X@{}}
    \toprule
    Symbol & Regeltyp & Abstraktes Regelschema \\
    \midrule
    % --- Konjunktion ---
    $\land$
      & Einführung
      & \label{rule:AI}%
        \(P,\;Q \;\vdash_{\land I}\; P \land Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:AE1}%
        \(P \land Q \;\vdash_{\land E_1}\; P\),\quad
        \label{rule:AE2}%
        \(P \land Q \;\vdash_{\land E_2}\; Q\) \\[0.9ex]

    % --- Disjunktion ---
    $\lor$
      & Einführung
      & \label{rule:OI1}%
        \(P \;\vdash_{\lor I_1}\; P \lor Q\),\quad
        \label{rule:OI2}%
        \(Q \;\vdash_{\lor I_2}\; P \lor Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:OE}%
        \(P \lor Q,\; [P]\vdots R,\; [Q]\vdots R
          \;\vdash_{\lor E}\; R\) \\[0.9ex]

    % --- Implikation ---
    $\rightarrow$
      & Einführung
      & \label{rule:RI}%
        \([P]\vdots Q \;\vdash_{\rightarrow I}\; P \rightarrow Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:RE}%
        \(P \rightarrow Q,\; P \;\vdash_{\rightarrow E}\; Q\) \\[0.9ex]

    % --- Äquivalenz ---
    $\leftrightarrow$
      & Einführung
      & \label{rule:LRI}%
        \(P \rightarrow Q,\; Q \rightarrow P
          \;\vdash_{\leftrightarrow I}\; P \leftrightarrow Q\) \\[0.6ex]
      & Eliminierung
      & \label{rule:LRE1}%
        \(P \leftrightarrow Q \;\vdash_{\leftrightarrow E_1}\;
          P \rightarrow Q\),\quad
        \label{rule:LRE2}%
        \(P \leftrightarrow Q \;\vdash_{\leftrightarrow E_2}\;
          Q \rightarrow P\) \\[0.9ex]

    % --- Negation und Widerspruch ---
    $\neg,\;\bot$
      & Einführung von \(\bot\)
      & \label{rule:BI}%
        \(P,\;\neg P \;\vdash_{\bot I}\; \bot\) \\[0.6ex]
      & Einführung von \(\neg\)
      & \label{rule:CI}%
        \([P]\vdots \bot \;\vdash_{\neg I}\; \neg P\) \\[0.6ex]
      & Eliminierung von \(\neg\)
      & \label{rule:CE}%
        \(\neg P,\; \bot \;\vdash_{\neg E}\; P\) \\[0.9ex]

    % --- Allquantor ---
    $\forall$
      & Einführung
      & \label{rule:UI}%
        \(P(x)\mid_x \;\vdash_{\forall I}\; \forall x\,P(x)\) \\[0.6ex]
      & Eliminierung
      & \label{rule:UE}%
        \(\forall x\,P(x) \;\vdash_{\forall E}\; P(t)\) \\[0.9ex]

    % --- Existenzquantor ---
    $\exists$
      & Einführung
      & \label{rule:EI}%
        \(P(t) \;\vdash_{\exists I}\; \exists x\,P(x)\) \\[0.6ex]
      & Eliminierung
      & \label{rule:EE}%
        \(\exists x\,P(x),\; P(x)\vdots Q\mid_x
          \;\vdash_{\exists E}\; Q\) \\[0.9ex]

    % --- Identität ---
    $=$
      & Einführung
      & \label{rule:II}%
        \(\vdash_{= I}\; t = t\) \\[0.6ex]
      & Eliminierung
      & \label{rule:IE}%
        \(t = u,\; P(t) \;\vdash_{= E}\; P(u)\) \\
    \bottomrule
  \end{tabularx}
\end{center}

\subsection{Weitere (abgeleitete) Schlussregeln}

Neben den elementaren Regeln aus dem letzten Abschnitt verwenden wir
gelegentlich noch abgeleitete Regeln für die alternative Disjunktion \(\lxor\)
und den Eindeutigkeitsquantor \(\exists!\).
Beide Operatoren werden in unserem System nicht als primitive Symbole
verstanden, sondern über bereits bekannte Formeln definiert
(zum Beispiel lässt sich \(\lxor\) mit Hilfe von \(\land,\lor,\neg\) und
\(\exists!\) mit Hilfe von \(\exists,\forall,=\) ausdrücken).

\begin{center}
\renewcommand{\arraystretch}{1.25}
\begin{tabularx}{\textwidth}{@{}llX@{}}
\toprule
Symbol & Regeltyp & Abstraktes Regelschema \\ 
\midrule
$\lxor$
  & \label{rule:XOrI1}Einführung 1 
  & \[
      P \land \neg Q \;\vdash_{\lxor I_1}\; P \lxor Q
    \] \\[0.6ex]
  & \label{rule:XOrI2}Einführung 2
  & \[
      \neg P \land Q \;\vdash_{\lxor I_2}\; P \lxor Q
    \] \\[0.6ex]
  & \label{rule:XOrE}Eliminierung
  & \[
      P \lxor Q,\; [P,\neg Q]\vdots R,\; [\neg P,Q]\vdots R
      \;\vdash_{\lxor E}\; R
    \] \\[0.8ex]
$\exists!$
  & \label{rule:UEI}Einführung
  & \[
      \exists x\,P(x),\;
      [P(a),P(b)]\vdots a = b
      \;\vdash_{\exists! I}\; \exists! x\,P(x)
    \] \\[0.8ex]
  & \label{rule:UEE}Eliminierung
  & \[
      \exists! x\,P(x),\;
      [P(a),\forall y\,(P(y)\rightarrow a=y)]\vdots Q\mid_a
      \;\vdash_{\exists! E}\; Q
    \] \\
\bottomrule
\end{tabularx}
\end{center}
\begin{remark}
In den Regelschemata für den Eindeutigkeitsquantor \(\exists!\) gehen
wir stillschweigend davon aus, dass die in den Subbeweisen verwendeten
Variablen (etwa \(a,b\)) als Eigenvariablen gewählt werden, d.\,h. sie
kommen außerhalb dieser Subbeweise nicht frei vor. Formal lassen sich
die Regeln aus einer geeigneten expliziten Definition von \(\exists!\)
ableiten.
\end{remark}




\section{Metanotation und Metaregeln}

\subsection{Was ist eine Metadefinition?}

Wir haben bisher gesehen, dass man \emph{Definitionen} im formalen
Kalkül wie \emph{Regeln} verwenden kann: Im Beweis taucht dann etwa
ein „Einführungsschritt“ auf (wenn wir von der definierten Seite zum
definierenden Ausdruck wechseln) oder ein „Eliminierungsschritt“
(umgekehrt).

\medskip

\textbf{Metadefinitionen} (auch \emph{metasprachliche Definitionen})
liegen dagegen \emph{außerhalb} des eigentlichen Kalküls. Man kann sie
sich als reine „Abkürzungsvereinbarungen“ auf der \emph{Meta-Ebene}
vorstellen:

\begin{itemize}
  \item Sie \emph{erweitern} das formale System nicht und treten
        \emph{nicht} als eigene Inferenzregeln im Beweis auf.
  \item Stattdessen legen sie fest, dass wir gewisse Schreibweisen
        (z.\,B.\ \(t \neq u\) oder Quantoren mit einer Bedingung)
        nur als Kurzformen für bereits bekannte Standardformen
        verwenden.
  \item In Beweisen dürfen solche Metadefinitionen jederzeit stillschweigend
        benutzt werden, weil sie nur die Notation vereinfachen, nicht die
        zugrundeliegende Logik verändern.
\end{itemize}

\subsection{Meta-Notation für das Nicht-Gleichheitszeichen}

\begin{definition}[Meta-Notation für Ungleichheit]
\label{def:neq-meta}
Seien \(t\) und \(u\) beliebige Terme. Wir führen das
\emph{Nicht-Gleichheitszeichen} als metasprachliche Abkürzung ein durch
\[
  t \neq u \;\coloneqq\; \neg\bigl(t = u\bigr).
\]
Das Symbol \(\neq\) gehört damit nicht zur eigentlichen Objektsprache
\(\mathcal L\), sondern ist nur eine Kurzschreibweise:
Überall, wo \(t \neq u\) steht, kann ebenso gut \(\neg(t = u)\)
geschrieben werden, und umgekehrt.
\end{definition}

\begin{remark}
Wir brauchen für \(\neq\) keine eigenen Schlussregeln: In Beweisen
arbeiten wir immer mit der zugrundeliegenden Formel \(\neg(t = u)\).
\(\neq\) ist lediglich eine bequemere Schreibweise.
\end{remark}


\subsection{Meta-Regeln und ihre Anwendung}

\emph{Meta-Regeln} sind bereits bewiesene Theoreme oder allgemeine
Schlussmuster, die wir später wie „fertige Werkzeuge“ verwenden.
Sie \emph{erweitern} das formale System nicht, sondern dienen nur
dazu, Beweise kürzer und übersichtlicher aufzuschreiben.

\begin{itemize}
  \item Nach einmaliger Einführung darf eine Meta-Regel an jeder
        passenden Stelle im Beweis stillschweigend benutzt werden.
  \item Die formale Korrektheit bleibt gewahrt, weil jede Meta-Regel
        selbst im Kalkül des natürlichen Schließens bewiesen wurde
        (oder auf Axiomen beruht).
\end{itemize}

Später werden wir einige besonders häufig verwendete Meta-Regeln
gesondert hervorheben (z.\,B.\ Varianten des indirekten Beweises
oder Beweisschemata für \enquote{Fallunterscheidung}) und im Text
darauf verweisen, wenn wir sie anwenden.

\subsection{Meta-Regel: Ersetzung äquivalenter Teilausdrücke}


Neben den bisher genannten Meta-Regeln verwenden wir im weiteren
eine Meta-Regel, die das Bikonditional \(\leftrightarrow\) ähnlich
wie das Gleichheitszeichen behandelt.

\begin{definition}[Meta-Regel der Äquivalenzersetzung]\label{rule:LRSubst}
Seien \(P\) und \(Q\) Formeln der Sprache \(\mathcal L\), und sei
\(\varphi(P)\) eine Formel, in der \(P\) an einer ausgezeichneten
Stelle als (Teil-)Formel vorkommt. Dann verwenden wir das folgende
metalogische Regelschema:
\[
  P \leftrightarrow Q,\; \varphi(P) \;\vdash\; \varphi(Q).
\]

Analoge gilt in umgekehrter Richtung:
\[
  P \leftrightarrow Q,\; \varphi(Q) \;\vdash\; \varphi(P).
\]

Die Schreibweise \(\varphi(P)\) ist dabei rein metasprachlich:
Sie steht für eine beliebige Formel, in der an einer markierten
Stelle \(P\) als Teilausdruck vorkommt; \(\varphi(Q)\) entsteht
durch Ersetzung genau dieser ausgezeichneten Vorkommensstelle von
\(P\) durch \(Q\).
\end{definition}

\begin{remark}
Diese Meta-Regel ist vollständig aus den elementaren Regeln für
\(\leftrightarrow\) ableitbar:
Aus \(P \leftrightarrow Q\) folgen zunächst \(P \rightarrow Q\)
und \(Q \rightarrow P\) mittels \(\leftrightarrow E_1\) und
\(\leftrightarrow E_2\). Durch wiederholte Anwendung der
Implikationselimination \((\rightarrow E)\) in einem geeigneten
Hilfsbeweis lässt sich dann zeigen, dass aus einem Beweis von
\(\varphi(P)\) auch ein Beweis von \(\varphi(Q)\) entsteht (und
umgekehrt). Die Meta-Regel erweitert das Kalkül also nicht, sondern
fasst nur ein allgemeines, bereits beweisbares Schlussmuster in
kompakter Form zusammen.

In Beweistabellen können wir die Anwendung dieser Meta-Regel
ggf.\ durch einen eigenen Regellabel (etwa
\(\text{\(\leftrightarrow\)-Subst}\)) kennzeichnen; formal handelt
es sich jedoch um die Verwendung eines bereits bewiesenen
Theorems und nicht um eine neue elementare Schlussregel.
\end{remark}

\subsection{Meta-Regel: Kettenschreibweise für transitive Relationen}
\label{rule:Chain}

\begin{remark}[Kettenschreibweise für transitive Relationen]
Viele der in der Logik verwendeten zweistelligen Ausdrücke verhalten
sich (wie wir später noch präzise zeigen werden) transitiv auf einer
geeigneten Klasse von Objekten. Typische Beispiele sind
\begin{itemize}
  \item die Implikation \(\rightarrow\) und das Bikonditional
        \(\leftrightarrow\) auf Formeln,
  \item die Gleichheit \(=\) auf Termen.
\end{itemize}
Für solche Relationen verwenden wir metasprachlich eine
\emph{Kettenschreibweise}: Aus einer Folge
\[
  X_0 \mathsf R X_1,\; X_1 \mathsf R X_2,\; \dots,\;
  X_{n-1} \mathsf R X_n
\]
machen wir kurz
\[
  X_0 \mathsf R X_1 \mathsf R \dots \mathsf R X_n.
\]
Diese Schreibweise ist nur eine Abkürzung für die iterierte Anwendung
des entsprechenden Transitivitätssatzes. Konkret sprechen wir etwa von
einer \enquote{Implikationskette}
\[
  P_0 \rightarrow P_1 \rightarrow \dots \rightarrow P_n,
\]
von einer \enquote{\(\leftrightarrow\)-Kette}
\[
  P_0 \leftrightarrow P_1 \leftrightarrow \dots \leftrightarrow P_n
\]
oder von einer \enquote{Gleichheitskette}
\[
  t_0 = t_1 = \dots = t_n.
\]
\end{remark}


\end{document}