%============================================================
%  Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte
%============================================================

\documentclass[main.tex]{subfiles}


\title{Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte}
\author{Martin Kunze}
\date{today}

\begin{document}
\maketitle
\tableofcontents
\raggedbottom

%\listoftheorems
\chapter{Aussagenlogik und Prädikatenlogik}

\section{Definitionen im Allgemeinen}

Eine Definition ist eine präzise Festlegung der Bedeutung eines Begriffs. Sie gibt an, welche Eigenschaften und Merkmale etwas besitzen muss, damit wir es eindeutig identifizieren können. In der Mathematik und Logik verwenden wir Definitionen, um Begriffe zu formalisieren und sicherzustellen, dass alle Beteiligten eine gemeinsame Grundlage haben, wenn sie über diese Begriffe sprechen.

Im weiteren Verlauf des Textes werden wir hauptsächlich \textbf{Nominaldefinitionen} verwenden. Eine Nominaldefinition legt fest, wie ein bestimmter Begriff oder Ausdruck innerhalb eines formalen Systems verwendet werden soll. Es handelt sich um sprachliche Festlegungen, die uns helfen, Begriffe klar und eindeutig zu definieren. Nominaldefinitionen bieten eine \textbf{informelle} oder \textbf{intuitive} Beschreibung eines Begriffs, um das Verständnis zu erleichtern, bevor wir ihn formal einführen.

Später im Text, insbesondere bei der Einführung formaler Konzepte wie in der Aussagenlogik oder der Mengenlehre, werden wir auf \textbf{explizite Definitionen} zurückgreifen. Explizite Definitionen liefern eine formale Grundlage für Begriffe, indem sie präzise Kriterien angeben, die erfüllt sein müssen, damit ein Objekt oder eine Aussage eindeutig als Instanz des definierten Begriffs gelten kann.

Da wir uns im nächsten Abschnitt mit der formalen Struktur von Aussagen und ihren Beziehungen befassen werden, ist es hilfreich, diesen allgemeinen Begriff der Definition im Hinterkopf zu behalten. In der Logik verwenden wir Definitionen, um präzise festzulegen, was wir unter einer Aussage und ihren Komponenten verstehen.

\section{Aussagenlogik}

Im Folgenden führen wir die grundlegenden Begriffe der Aussagenlogik ein, die zunächst in Form von \textbf{Nominaldefinitionen} erklärt werden. Diese Definitionen legen fest, wie wir die zentralen Begriffe wie Aussage, atomare Aussage, logische Operatoren und zusammengesetzte Aussage verwenden. Durch die Nominaldefinitionen erhalten wir eine sprachliche Grundlage für unser Verständnis.

In späteren Kapiteln werden diese Begriffe mithilfe von \textbf{expliziten Definitionen} formalisiert. Die expliziten Definitionen erlauben es uns, Aussagen und ihre logischen Verknüpfungen formal zu beschreiben, wodurch eine präzise mathematische Behandlung ermöglicht wird.

Die Aussagenlogik ist ein Bereich der Logik, der sich mit Aussagen und den logischen Beziehungen zwischen ihnen befasst.

\begin{definition}[Aussage]
Eine Aussage ist eine Behauptung, die entweder wahr oder falsch sein kann.
\end{definition}

In der Aussagenlogik verwenden wir Symbole, um Aussagen darzustellen. Zum Beispiel könnten wir die Symbole \(p\) und \(q\) verwenden, um zwei verschiedene Aussagen darzustellen.

\begin{definition}[Atomare Aussage]
Eine atomare Aussage ist eine Aussage, die nicht weiter zerlegt werden kann. Sie bildet die einfachste Einheit in der Aussagenlogik. Beispiele für atomare Aussagen sind \(p\) und \(q\).
\end{definition}


Um die Aussagenlogik genauer zu beschreiben, betrachten wir zwei zentrale Aspekte:

\subsection{Syntax}

Die \textbf{Syntax} der Aussagenlogik beschreibt die formalen Regeln, nach denen gültige Ausdrücke (Formeln) gebildet werden können. Sie legt fest, welche Kombinationen aus atomaren Aussagen, logischen Operatoren und Klammern zulässig sind.

Die wesentlichen syntaktischen Elemente sind:
\begin{itemize}
    \item \textbf{Atomare Aussagen:} Diese bilden die Grundbausteine und werden durch Symbole wie \(p, q, r, \dots\) dargestellt.
    \item \textbf{Logische Operatoren (Junktoren):} Hierzu zählen \(\neg\) (Negation), \(\land\) (Konjunktion), \(\lor\) (Disjunktion) und \(\rightarrow\) (Implikation).
    \item \textbf{Klammern:} Diese werden verwendet, um die Reihenfolge der Operationen in komplexen Ausdrücken eindeutig festzulegen.
\end{itemize}

Die Syntax bezieht sich nur auf die Struktur der Ausdrücke und trifft keine Aussage über deren Bedeutung. Dies ist Gegenstand der Semantik.

\begin{definition}[Zusammengesetzte Aussage]
Eine zusammengesetzte Aussage entsteht durch die Verknüpfung atomarer Aussagen mittels logischer Operatoren.
\end{definition}

\subsubsection{Notation zusammengesetzter Aussagen}

In der Aussagenlogik verwenden wir standardmäßig die \textbf{Infixnotation}, bei der die logischen Operatoren zwischen den atomaren Aussagen stehen. Um die Reihenfolge der Operationen in komplexen Ausdrücken eindeutig zu machen, können Klammern verwendet werden. In der reinen Infixnotation stehen die Operatoren jedoch einfach zwischen den Operanden ohne Klammern, wobei die Priorität der Operatoren die Reihenfolge der Auswertung bestimmt.

\begin{definition}[Infixnotation]
Die \textbf{Infixnotation} ist eine Notation, in der die Operatoren zwischen den atomaren Aussagen stehen. In einfachen Ausdrücken ist die Reihenfolge der Auswertung durch die Priorität der Operatoren festgelegt. Klammern werden verwendet, um die Reihenfolge explizit zu machen, wenn dies erforderlich ist, um Mehrdeutigkeit zu vermeiden.

\textbf{Beispiel ohne Klammern:} 
\[
p \land q \lor r
\]
Hier wird zuerst \(p \land q\) berechnet, da die Konjunktion eine höhere Priorität als die Disjunktion hat.

\textbf{Beispiel mit Klammern:} 
\[
(p \land q) \lor r
\]
Hier machen die Klammern die Reihenfolge explizit und verdeutlichen, dass \(p\) und \(q\) zuerst verknüpft werden, bevor das Ergebnis mit \(r\) durch \(\lor\) kombiniert wird.
\end{definition}

Die \textbf{reine Infixnotation ohne Klammern} funktioniert nur in Fällen, in denen die Priorität der Operatoren die Auswertung eindeutig bestimmt. Bei komplexeren Ausdrücken, bei denen die Reihenfolge nicht allein durch Prioritäten festgelegt werden kann, sind Klammern unerlässlich. Zum Beispiel kann der Ausdruck \((p \lor q) \land r\) in der reinen Infixnotation nicht korrekt dargestellt werden, da \(\land\) eine höhere Priorität hat als \(\lor\). Ohne Klammern würde er als \(p \lor (q \land r)\) interpretiert.

\subsubsection{Priorität der logischen Operatoren}

Auch ohne Klammern gibt es eine feste Reihenfolge, in der die logischen Operatoren ausgewertet werden. Diese Priorität bestimmt, welche Operatoren zuerst ausgewertet werden, wenn keine Klammern gesetzt sind. Die folgende Liste zeigt die Priorität der grundlegenden logischen Operatoren (von höchster zu niedrigster Priorität):

\begin{enumerate}
    \item \textbf{Negation} (\(\neg\)): Die Negation hat die höchste Priorität und wird vor allen anderen Operatoren ausgewertet. Zum Beispiel wird in \(\neg p \land q\) zuerst \(\neg p\) berechnet, dann \(p \land q\).
    \item \textbf{Konjunktion} (\(\land\)): Die Konjunktion hat eine höhere Priorität als die Disjunktion. In \(p \land q \lor r\) wird zuerst \(p \land q\) ausgewertet, dann \(q \lor r\).
    \item \textbf{Disjunktion} (\(\lor\)): Die Disjunktion hat eine geringere Priorität als die Konjunktion, wird jedoch vor der Implikation ausgewertet.
    \item \textbf{Implikation} (\(\rightarrow\)): Die Implikation wird erst nach den Konjunktionen und Disjunktionen ausgewertet.
\end{enumerate}

\textbf{Beispiele:}
\begin{example}
    \item In \(\neg (p \lor q)\) wird zuerst die Disjunktion \(p \lor q\) ausgewertet und dann die Negation darauf angewendet.
    \item In \(p \land (q \rightarrow r)\) wird zuerst \(q \rightarrow r\) ausgewertet und anschließend die Konjunktion mit \(p\) gebildet.
\end{example}

\paragraph{Warum Klammern verwenden?}

Obwohl es feste Regeln für die Priorität der logischen Operatoren gibt, empfehlen wir die Verwendung von Klammern, um komplexe Ausdrücke klarer und lesbarer zu machen. Klammern helfen dabei, Missverständnisse zu vermeiden und sicherzustellen, dass der Ausdruck eindeutig interpretiert wird. Besonders bei langen oder verschachtelten Ausdrücken kann dies die Übersichtlichkeit erheblich verbessern.

\begin{remark}
In der reinen Infixnotation ohne Klammern kann es bei bestimmten Ausdrücken zu Mehrdeutigkeiten kommen, wenn die Priorität der Operatoren nicht ausreicht, um die Reihenfolge der Auswertung eindeutig festzulegen. Deshalb ist die Verwendung von Klammern in solchen Fällen unverzichtbar, um sicherzustellen, dass der Ausdruck korrekt interpretiert wird.
\end{remark}

\subsubsection{Weitere Notationen}

Neben der Infixnotation mit Klammern, die wir in diesem Skript als Standardnotation verwenden, gibt es in der Logik noch weitere Notationen, die zur Darstellung von logischen Ausdrücken verwendet werden. Diese Notationen unterscheiden sich darin, wie die Reihenfolge der Operationen dargestellt wird, und haben in verschiedenen Bereichen ihre Vorteile. Im Folgenden stellen wir zwei weitere gängige Notationen vor, die in der mathematischen Logik und der Informatik verwendet werden.

\begin{itemize}
    \item \textbf{Polnische Notation (Präfixnotation)}: In dieser Notation werden die Operatoren vor den Operanden geschrieben. Klammern sind hier nicht sinnvoll, da die Reihenfolge der Operationen durch die Position der Symbole eindeutig festgelegt wird.
    
    \textbf{Beispiel}: Anstelle von \((p \land q) \lor r\) wird \(\lor \land p q r\) geschrieben. In dieser Darstellung steht der Operator immer vor den Operanden, was die Klammerung unnötig macht.
    
    \item \textbf{Umgekehrte Polnische Notation (Postfixnotation)}: In dieser Notation, die häufig in der Informatik verwendet wird, stehen die Operatoren hinter den Operanden. Auch hier sind keine Klammern notwendig, da die Reihenfolge der Operationen durch die Position der Symbole eindeutig bestimmt wird.
    
    \textbf{Beispiel}: Anstelle von \((p \land q) \lor r\) wird \(\land p q \lor r\) geschrieben. Der Operator kommt nach den Operanden, was die Auswertung von links nach rechts ermöglicht.
\end{itemize}

\textbf{Vergleich der Notationen:} 
Die Wahl der Notation hängt vom Kontext und den Anforderungen der jeweiligen Anwendung ab. In der Logik und Mathematik ist die Infixnotation am gebräuchlichsten, da sie intuitiv und gut lesbar ist. Die polnische und die umgekehrte polnische Notation haben ihre Vorteile in der Informatik, insbesondere bei der Auswertung durch Computer, da sie keine Klammern benötigen und effizienter ausgewertet werden können.

In diesem Skript verwenden wir standardmäßig die \textbf{Infixnotation mit vollständiger Klammerung}, um die Struktur von Aussagen klar darzustellen.

\subsection{Semantik}

Die \textbf{Semantik} der Aussagenlogik befasst sich mit der Bedeutung und der Bewertung von Aussagen. Insbesondere wird festgelegt, wie einer Aussage ein Wahrheitswert (\textit{wahr} oder \textit{falsch}) zugeordnet wird.

\subsubsection{Wahrheitswerttabellen}

Ein zentrales Konzept der Aussagenlogik ist die Verwendung von sogenannten Wahrheitswerttabellen, um die Wahrheitsbedingungen einer zusammengesetzten Aussage zu analysieren. Eine Wahrheitswerttabelle legt für jede Kombination der Wahrheitswerte der beteiligten atomaren Aussagen den Wahrheitswert der zusammengesetzten Aussage fest. Auf diese Weise kann die Bedeutung komplexer Aussagen systematisch erfasst werden, ohne auf die inhaltliche Bedeutung der atomaren Aussagen einzugehen.

Für die Semantik der Aussagenlogik gelten hiernach folgende Prinzipien:
\begin{itemize}
    \item \textbf{Atomare Aussagen:} Jeder atomaren Aussage wird ein Wahrheitswert zugewiesen.
    \item \textbf{Logische Operatoren:} Die Bedeutung zusammengesetzter Aussagen wird durch die Wahrheitswerte ihrer Bestandteile und die Regeln der Operatoren festgelegt. Beispielsweise gilt:
    \begin{align*}
        \text{Wahrheitstabelle für \(\land\):} & \quad 
        \begin{array}{c|c|c}
            p & q & p \land q \\
            \hline
            \text{wahr} & \text{wahr} & \text{wahr} \\
            \text{wahr} & \text{falsch} & \text{falsch} \\
            \text{falsch} & \text{wahr} & \text{falsch} \\
            \text{falsch} & \text{falsch} & \text{falsch}
        \end{array}
    \end{align*}
\end{itemize}

\section{Prädikatenlogik}
\subsection{Syntax der Prädikatenlogik}

Die Syntax der Prädikatenlogik definiert die Struktur und Formation von Aussagen oder Ausdrücken in der Prädikatenlogik. Im Gegensatz zur Aussagenlogik erlaubt die Prädikatenlogik, über Objekte in einer Domäne zu sprechen und Eigenschaften sowie Beziehungen zwischen diesen auszudrücken.

\begin{definition}[Domäne]
Die \textbf{Domäne} (auch \textbf{Grundmenge} genannt) ist die nicht-leere Menge von Objekten, über die in einer prädikatenlogischen Struktur gesprochen wird. Die Objekte der Domäne sind die möglichen Werte, die Variablen in prädikatenlogischen Ausdrücken annehmen können.
\end{definition}

\begin{definition}[Term]
Ein \textbf{Term} ist ein Ausdruck, der ein Objekt in der Domäne beschreibt. Terme sind die Grundbausteine prädikatenlogischer Ausdrücke und repräsentieren Objekte in der Domäne. Es gibt drei Hauptarten von Termen:

\begin{itemize}
    \item \textbf{Variablen}: Eine Variable steht für ein beliebiges Objekt in der Domäne. Beispiele für Variablen sind \(x, y, z\). Zum Beispiel beschreibt der Term \(x\) ein beliebiges Objekt in der Domäne.

    \item \textbf{Konstanten}: Eine Konstante bezeichnet ein bestimmtes, festes Objekt in der Domäne. Beispiele für Konstanten sind \(a, b, c\). Zum Beispiel repräsentiert \(a\) ein spezifisches Objekt in der Domäne, wie z.B. eine bestimmte Person oder Zahl.

    \item \textbf{Funktionssymbole}: Ein Funktionssymbol beschreibt eine Operation, die auf Termen ausgeführt wird und einen neuen Term ergibt. Ein Funktionssymbol wird auf eine feste Anzahl von Termen (den sogenannten Argumenten) angewendet. Beispiele für Funktionssymbole sind \(f, g, h\). Zum Beispiel könnte \(f(a)\) eine Funktion sein, die das Objekt \(a\) in ein anderes Objekt der Domäne abbildet, etwa \(f(a)\) als die Mutter von \(a\) in einer Domäne von Personen.
\end{itemize}

\textbf{Beispiel für Terme}:
\begin{itemize}
    \item Der Ausdruck \(x\) ist ein Term, der eine Variable darstellt.
    \item Der Ausdruck \(a\) ist ein Term, der eine Konstante darstellt.
    \item Der Ausdruck \(f(x)\) ist ein Term, der eine Funktion darstellt, die auf der Variable \(x\) basiert.
\end{itemize}

\end{definition}

\begin{definition}[Prädikat]
Ein \textbf{Prädikat} ist eine Funktion, die eine bestimmte Eigenschaft oder Beziehung zwischen Objekten der Domäne beschreibt. Prädikate nehmen eine feste Anzahl von Termen als Argumente und bilden daraus eine Aussage. Diese Aussagen können dann entweder wahr oder falsch sein, abhängig von der Interpretation der Prädikate und der Terme in der Domäne.

Prädikate werden häufig durch Großbuchstaben (wie \(P, Q, R\)) dargestellt. Es gibt eine Unterscheidung zwischen Aussagen mit Konstanten und Variablen:

\begin{itemize}
    \item Wenn ein Prädikat nur mit **Konstanten** als Argumenten verwendet wird, kann die Wahrheit der Aussage unmittelbar bestimmt werden. Beispiel: \(R(5, 3)\), wobei \(R(x, y)\) die Beziehung "größer als" beschreibt, ist wahr, da \(5 > 3\).
    
    \item Wenn ein Prädikat mit **Variablen** als Argumenten verwendet wird, hängt der Wahrheitswert von der Interpretation der Variablen ab. Das bedeutet, dass erst durch die Zuordnung von Objekten der Domäne zu den Variablen \(x\) und \(y\) festgelegt wird, ob die Aussage wahr oder falsch ist. Beispiel: Die Aussage \(R(x, y)\) (mit \(R(x, y)\) = "größer als") kann nicht als wahr oder falsch festgelegt werden, solange wir nicht wissen, welche Werte für \(x\) und \(y\) eingesetzt werden.
\end{itemize}

Prädikate können folgende Stelligkeit haben:
\begin{itemize}
\item 	\textbf{Einstellig (Unär)}: Ein einstelliges Prädikat beschreibt eine Eigenschaft eines einzelnen Objekts der Domäne. Zum Beispiel kann  ausdrücken, dass  eine bestimmte Eigenschaft besitzt, wie etwa \enquote{ist eine gerade Zahl}.
\item 	\textbf{Zweistellig (Binär)}: Ein zweistelliges Prädikat beschreibt eine Beziehung zwischen zwei Objekten der Domäne. Solche Prädikate werden auch als \textbf{binäre Relationen} bezeichnet, da sie eine Relation zwischen zwei Objekten herstellen. Zum Beispiel beschreibt  eine Beziehung zwischen  und , wie etwa \enquote{ist größer als}.

\item 	\textbf{Dreistellig (Ternär) oder höherer Stelligkeit}: Prädikate können auch drei oder mehr Argumente haben, um komplexere Beziehungen zwischen mehreren Objekten auszudrücken. Zum Beispiel beschreibt  eine dreistellige Relation zwischen  und , wie etwa \\enquote{liegt zwischen  und}.
\end{itemize}

\textbf{Beispiele für Prädikate}:
\begin{itemize}
    \item Das Prädikat \(P(x)\) könnte ausdrücken, dass \(x\) eine gerade Zahl ist. \(P(2)\) wäre wahr, da 2 eine gerade Zahl ist, aber \(P(3)\) wäre falsch.
    \item Das Prädikat \(R(x, y)\) könnte die Beziehung \enquote{ist größer als} ausdrücken. Zum Beispiel wäre \(R(5, 3)\) wahr, da \(5 > 3\), aber \(R(2, 4)\) wäre falsch, da \(2\) nicht größer als \(4\) ist.
    \item Ein ternäres Prädikat \(S(x, y, z)\) könnte ausdrücken: \(x\) \enquote{liegt zwischen} \(y\) und \(z\). Zum Beispiel wäre \(S(5, 3, 7)\) wahr, weil \(5\) zwischen \(3\) und \(7\) liegt.
    \item Ein Beispiel für ein Prädikat mit einer Funktionsanwendung wäre \(P(f(x))\), wobei \(f(x)\) eine Funktion ist, die das Doppelte von \(x\) zurückgibt. Wenn \(P(y)\) ausdrückt, dass \(y\) eine gerade Zahl ist, dann überprüft \(P(f(x))\), ob das Doppelte von \(x\) gerade ist.
    \item Ein weiteres Beispiel mit Konstanten: Das Prädikat \(Q(x)\) könnte ausdrücken, dass \(x\) größer als 10 ist. Wenn \(a = 7\), wäre \(Q(a)\) falsch, weil 7 nicht größer als 10 ist. Wenn \(b = 12\) ist, wäre \(Q(b)\) wahr.
\end{itemize}

Prädikate erlauben es uns, über Eigenschaften von Objekten in der Domäne und deren Beziehungen zu sprechen, was die Prädikatenlogik mächtiger und flexibler als die Aussagenlogik macht.
\end{definition}
\begin{remark}
In diesem Skript wird gelegentlich die Notation \(Px\) anstelle von \(P(x)\) verwendet, insbesondere wenn eindeutig ist, dass \(P\) ein Prädikat ist, das auf die Variable \(x\) angewendet wird. Ebenso wird nach dem Allquantor \(\forall\) manchmal die Klammer weggelassen, wenn klar erkennbar ist, dass das Prädikat zum Quantor gehört. Diese Vereinfachung dient der Übersichtlich-keit und wird nur dann verwendet, wenn keine Verwechslungsgefahr besteht.
\end{remark}

\begin{definition}[Gleichheit]
Das \textbf{Gleichheitszeichen} (\(=\)) ist ein spezielles binäres Prädikat in der Prädikatenlogik, das die Identität zweier Terme ausdrückt. Für zwei Terme \(s\) und \(t\) bedeutet \(s = t\), dass \(s\) und \(t\) auf dasselbe Objekt in der Domäne verweisen.

\textbf{Beispiele für Gleichheit}:
\begin{itemize}
    \item \(a = a\) ist immer wahr, da jede Konstante gleich sich selbst ist.
    \item Wenn \(f(x)\) eine Funktion ist, die \(x\) auf ein bestimmtes Objekt abbildet, dann \(f(a) = b\) bedeutet, dass das Ergebnis der Funktion \(f\) bei Eingabe \(a\) das Objekt \(b\) ist.
    \item In einer Domäne von Zahlen könnte \(x = y\) bedeuten, dass die Zahlen, die durch \(x\) und \(y\) repräsentiert werden, identisch sind.
\end{itemize}
\end{definition}


\begin{definition}[Quantoren]
Quantoren sind Symbole, die den Umfang einer Aussage in der Prädikatenlogik angeben, indem sie definieren, für welche Objekte in der Domäne die Aussage gilt. Es gibt zwei Haupttypen von Quantoren:

\begin{itemize}
    \item \textbf{Allquantor} (\(\forall\)): Der Allquantor drückt aus, dass eine Aussage für \textbf{alle} Objekte in der Domäne wahr ist. Beispiel: \(\forall x P(x)\) bedeutet, dass \(P(x)\) für jedes Objekt \(x\) in der Domäne gilt. Wenn \(P(x)\) bedeutet \enquote{\(x\) ist eine gerade Zahl}, würde \(\forall x P(x)\) bedeuten \enquote{Alle \(x\) in der Domäne sind gerade Zahlen}.
    
    \item \textbf{Existenzquantor} (\(\exists\)): Der Existenzquantor drückt aus, dass es \textbf{mindestens ein} Objekt in der Domäne gibt, für das die Aussage wahr ist. Beispiel: \(\exists x P(x)\) bedeutet, dass es mindestens ein Objekt \(x\) in der Domäne gibt, für das \(P(x)\) wahr ist. Wenn \(P(x)\) bedeutet \enquote{\(x\) ist eine gerade Zahl}, würde \(\exists x P(x)\) bedeuten \enquote{Es gibt mindestens ein \(x\) in der Domäne, das eine gerade Zahl ist}.
\end{itemize}
\end{definition}

\textbf{Beispiele für Quantoren}:
\begin{itemize}
    \item \(\forall x P(x)\): Diese Aussage besagt, dass die Eigenschaft \(P(x)\) für jedes \(x\) in der Domäne wahr ist. Beispiel: \(\forall x (x > 0)\) könnte ausdrücken, dass alle Objekte \(x\) in der Domäne größer als 0 sind.
    \item \(\exists x P(x)\): Diese Aussage besagt, dass es mindestens ein \(x\) in der Domäne gibt, für das \(P(x)\) wahr ist. Beispiel: \(\exists x (x > 10)\) könnte ausdrücken, dass es mindestens ein Objekt \(x\) gibt, das größer als 10 ist.
\end{itemize}

\begin{definition}[Gültigkeitsbereich eines Quantors]
Der \textbf{Gültigkeitsbereich eines Quantors} ist der Teil eines prädikatenlogischen Ausdrucks, auf den der Quantor wirkt. Wenn ein Quantor der Form \(\forall x\) oder \(\exists x\) eine Variable \(x\) einführt, dann gilt der Quantor für alle Vorkommen von \(x\) innerhalb einer bestimmten Teilformel des Ausdrucks, die seinen Gültigkeitsbereich darstellt. Dieser Bereich endet in der Regel an der nächsten Klammer oder am Ende des Ausdrucks.

\textbf{Beispiele:}
\begin{itemize}
    \item In der Aussage \(\forall x (P(x) \land Q(y))\) ist der Gültigkeitsbereich des Quantors \(\forall x\) die Teilformel \(P(x) \land Q(y)\). Innerhalb dieses Bereichs ist \(x\) gebunden, während \(y\) frei ist.
    \item In der Aussage \(\exists y (\forall x (R(x, y)) \rightarrow P(z))\) ist der Gültigkeitsbereich von \(\exists y\) die gesamte Aussage \(\forall x (R(x, y)) \rightarrow P(z)\). Innerhalb dieses Bereichs ist \(y\) gebunden, während \(z\) frei bleibt.
\end{itemize}
\end{definition}

\begin{definition}[Gebundene Variable]
Eine Variable in einem prädikaten-logischen Ausdruck ist \textbf{gebunden}, wenn sie im Gültigkeitsbereich eines Quantors steht, der diese Variable einführt. Das bedeutet, dass der Quantor die Werte der Variablen festlegt und somit beeinflusst, für welche Objekte in der Domäne die Aussage gilt.

\textbf{Beispiele:}
\begin{itemize}
    \item In der Aussage \(\forall x P(x)\) ist die Variable \(x\) gebunden, weil sie im Gültigkeits-bereich des Quantors \(\forall x\) steht.
    \item In der Aussage \(\exists y (Q(x) \land R(y))\) ist \(y\) gebunden durch \(\exists y\), während \(x\) eine freie Variable bleibt.
\end{itemize}
\end{definition}

\begin{definition}[Freie Variable]
Eine Variable in einem prädikatenlogischen Ausdruck ist \textbf{frei}, wenn sie nicht durch einen Quantor (\(\forall\) oder \(\exists\)) gebunden ist. Ein Ausdruck mit freien Variablen ist keine vollständige Aussage, da die Variablen nicht festgelegt sind.

\textbf{Beispiele:}
\begin{itemize}
    \item In dem Ausdruck \(P(x)\) ist die Variable \(x\) \textbf{frei}, da sie nicht durch einen Quantor gebunden ist. Solange \(x\) frei ist, kann der Wahrheitswert des Ausdrucks nicht bestimmt werden.
    
    \item In der Aussage \(\forall y (P(x) \land Q(y))\) ist die Variable \(x\) frei, während \(y\) durch den Allquantor \(\forall y\) gebunden ist.
\end{itemize}
\end{definition}

\begin{definition}[Symbol]
In der Prädikatenlogik ist ein \textbf{Symbol} ein grundlegendes Element der formalen Sprache, das verwendet wird, um Ausdrücke zu bilden. Symbole lassen sich in zwei Hauptkategorien unterteilen:

\begin{itemize}
    \item \textbf{Logische Symbole}: Diese umfassen die logischen Verbindungszeichen und Quantoren, die die Struktur der Aussagen bestimmen. Beispiele sind:
    \begin{itemize}
        \item \(\neg\) (Negation)
        \item \(\land\) (Konjunktion)
        \item \(\lor\) (Disjunktion)
        \item \(\rightarrow\) (Implikation)
        \item \(\leftrightarrow\) (Äquivalenz)
        \item \(\forall\) (Allquantor)
        \item \(\exists\) (Existenzquantor)
    \end{itemize}
    
    \item \textbf{Nicht-logische Symbole}: Diese beziehen sich auf die spezifische Domäne und umfassen:
    \begin{itemize}
        \item \textbf{Konstantensymbole}: Bezeichnen spezifische Objekte in der Domäne, z.B. \(a, b, c\).
        \item \textbf{Funktionssymbole}: Stellen Funktionen dar, die auf Objekte der Domäne angewendet werden, z.B. \(f, g, h\).
        \item \textbf{Prädikatssymbole}: Beschreiben Eigenschaften oder Relationen zwischen Objekten, z.B. \(P, Q, R\).
        \item \textbf{Variablen}: Stehen für beliebige Objekte in der Domäne, z.B. \(x, y, z\).
    \end{itemize}
\end{itemize}

Symbole sind die Bausteine, aus denen komplexere Ausdrücke und Aussagen der Prädikatenlogik aufgebaut werden.
\end{definition}

\begin{definition}[Atomare Formel und Satz in der Prädikatenlogik]
\label{def:atomare_formel}
\mbox{}
\begin{enumerate}
    \item \textbf{Atomare Formel.}  
    Eine \emph{atomare Formel} (oder \emph{atomare Aussage}) in der Prädikatenlogik ist ein Ausdruck der Form
    \[
        P(t_1, t_2, \ldots, t_n),
    \]
    wobei \(P\) ein \(n\)-stelliges Prädikatssymbol und \(t_1, t_2, \ldots, t_n\) Terme sind.  
    Falls die verwendete Sprache Gleichheit enthält, zählt auch ein Ausdruck der Form \(t_1 = t_2\) zu den atomaren Formeln.  
    \emph{Wichtig:} Eine atomare Formel enthält keine logischen Junktoren (z.\,B.\(\wedge, \lor\)) und auch keine Quantoren (z.\,B.\(\forall, \exists\)).

    \item \textbf{Satz (geschlossene Formel).}  
    Ein \emph{Satz} (oder \emph{geschlossene Formel}) ist eine wohlgeformte Formel, in der alle Variablen \emph{gebunden} sind. Das heißt, es gibt keine freien Variablen mehr. Beispielsweise ist \(\forall x\, P(x)\) eine geschlossene Formel (ein Satz), jedoch \emph{keine} atomare Formel, weil der Quantor \(\forall x\) auftritt.
\end{enumerate}

\begin{example}
\leavevmode
\begin{itemize}
    \item \(\;P(a)\) \quad (atomare Formel, da \(a\) eine Konstante ist)
    \item \(\;P(x)\) \quad (atomare Formel, aber \emph{kein Satz}, da \(x\) frei ist)
    \item \(\;\forall x\,P(x)\) \quad (geschlossene Formel / Satz, \emph{nicht} atomar wegen \(\forall\))
    \item \(\;\exists y\,R(y,a)\) \quad (geschlossene Formel / Satz, \emph{nicht} atomar wegen \(\exists\))
\end{itemize}
\end{example}

\begin{hint}
Ein Ausdruck wie \(P(x)\) hat eine freie Variable \(x\) und ist deshalb \emph{nicht} als wahr oder falsch entscheidbar, solange \(x\) nicht gebunden (durch einen Quantor) oder durch eine Konstante ersetzt ist. Er ist wohl eine \emph{atomare Formel}, aber eben kein \emph{Satz} im strengen Sinn.
\end{hint}
\end{definition}

\begin{definition}[Singuläre Aussage]
Eine \textbf{singuläre Aussage} ist eine atomare Aussage, bei der alle Variablen durch Konstanten ersetzt wurden. Diese Aussagen beziehen sich auf spezifische Objekte in der Domäne und können einen festen Wahrheitswert annehmen.

\begin{example}
    \(P(a)\), \quad \(R(a, b)\)
\end{example}

Hier sind \(a\) und \(b\) Konstanten, und die Aussagen \(P(a)\) und \(R(a, b)\) können wahr oder falsch sein, je nachdem, wie die Prädikate in der Domäne interpretiert werden.
\end{definition}

\begin{definition}[Universelle Aussage]
Eine \textbf{universelle Aussage} ist eine atomare Aussage, die durch einen \textbf{Allquantor} (\(\forall\)) eine Behauptung über alle Objekte in der Domäne trifft. Alle in der Aussage vorkommenden Variablen sind durch den Allquantor gebunden.

\begin{example}
    \(\forall x P(x)\), \quad \(\forall x \forall y R(x, y)\)
\end{example}

Hier gilt \(P(x)\) oder \(R(x, y)\) für alle Objekte in der Domäne. Der Wahrheitswert hängt davon ab, ob die Prädikate für jedes Objekt oder jedes Paar von Objekten in der Domäne zutreffen.
\end{definition}

\begin{definition}[Existenzielle Aussage]
Eine \textbf{existenzielle Aussage} ist eine atomare Aussage, die durch einen \textbf{Existenzquantor} (\(\exists\)) die Existenz von mindestens einem Objekt in der Domäne behauptet, für das die Aussage gilt. Alle in der Aussage vorkommenden Variablen sind durch den Existenzquantor gebunden.

\begin{example}
    \(\exists x P(x)\), \quad \(\exists x \exists y R(x, y)\)
\end{example}

Hier wird behauptet, dass es mindestens ein Objekt \(x\) oder ein Paar von Objekten \(x, y\) gibt, für das \(P(x)\) oder \(R(x, y)\) wahr ist.
\end{definition}

\begin{definition}[Zusammengesetzte Aussage in der Prädikatenlogik]
Eine \textbf{zusammengesetzte Aussage} in der Prädikatenlogik entsteht durch die Verknüpfung von atomaren Aussagen oder anderen zusammengesetzten Aussagen mittels logischer Operatoren. Diese Operatoren sind die Negation (\(\neg\)), die Konjunktion (\(\land\)), die Disjunktion (\(\lor\)), die Implikation (\(\rightarrow\)) und die Äquivalenz (\(\leftrightarrow\)).

\begin{example}
\[
\neg P(a), \quad P(a) \land Q(b), \quad \forall x (P(x) \rightarrow Q(x))
\]
Hier ist \(\neg P(a)\) eine zusammengesetzte Aussage, da sie eine Negation der atomaren Aussage \(P(a)\) ist. \(P(a) \land Q(b)\) ist eine Konjunktion zweier atomarer Aussagen, und \(\forall x (P(x) \rightarrow Q(x))\) ist eine universelle Aussage, die eine Implikation zwischen \(P(x)\) und \(Q(x)\) enthält.
\end{example}
\end{definition}

\subsection{Infixnotation in der Prädikatenlogik}

In der Prädikatenlogik verwenden wir, wie in der Aussagenlogik, standardmäßig die \textbf{Infixnotation}, bei der die logischen Operatoren zwischen den Aussagen und Prädikaten stehen. Zusätzlich zur Verknüpfung von Aussagen durch logische Operatoren verwenden wir Quantoren, um über Objekte in einer Domäne zu sprechen. 

\begin{definition}[Infixnotation in der Prädikatenlogik]
Die \textbf{Infixnotation} ist eine Notation, in der die logischen Operatoren zwischen den atomaren Aussagen und Prädikaten stehen. Die Struktur einer prädikatenlogischen Aussage wird durch die Verwendung von Quantoren, logischen Operatoren und eventuell Klammern eindeutig festgelegt. Klammern können verwendet werden, um die Reihenfolge der Operationen explizit zu machen.

\textbf{Beispiele für Infixnotation in der Prädikatenlogik:}
\begin{example}
    \[
    P(a) \land Q(b), \quad \forall x (P(x) \rightarrow Q(x)), \quad \exists y (R(x, y) \lor S(y, z))
    \]
    Im ersten Beispiel \(P(a) \land Q(b)\) stehen die Konjunktion (\(\land\)) zwischen zwei atomaren Aussagen \(P(a)\) und \(Q(b)\). Im zweiten Beispiel \(\forall x (P(x) \rightarrow Q(x))\) wird die universelle Quantifikation verwendet, um eine Aussage über alle \(x\) in der Domäne zu treffen. Im dritten Beispiel \(\exists y (R(x, y) \lor S(y, z))\) wird der Existenzquantor genutzt, um die Existenz eines Objekts \(y\) zu behaupten, für das die Disjunktion \(R(x, y) \lor S(y, z)\) wahr ist.
\end{example}

Die Reihenfolge der Operatoren richtet sich nach den gleichen Prioritäts-regeln wie in der Aussagenlogik, wobei Quantoren immer die höchste Priorität haben.
\end{definition}

\begin{remark}
Wie in der Aussagenlogik kann es in der Prädikatenlogik notwendig sein, Klammern zu verwenden, um Mehrdeutigkeiten zu vermeiden. Zum Beispiel wird der Ausdruck \(\forall x P(x) \land Q(x)\) anders interpretiert als \(\forall x (P(x) \land Q(x))\), da der Quantor \(\forall x\) im zweiten Fall auf die gesamte Konjunktion wirkt.
\end{remark}

\subsection{Infixnotation in der Prädikatenlogik}

Wie in der Aussagenlogik verwenden wir in der Prädikatenlogik standardmäßig die \textbf{Infixnotation}, bei der die logischen Operatoren zwischen den prädikaten-logischen Ausdrücken stehen.

\chapter{Beweistheorie}

\section{Einleitung zur Beweistheorie}
Beweistheorie ist ein zentraler Bestandteil der formalen Logik, der sich mit den Methoden und Prinzipien befasst, mit denen logische Aussagen bewiesen werden können. Durch die systematische Anwendung von Regeln können wir die Gültigkeit von Aussagen innerhalb eines logischen Systems feststellen. In diesem Kapitel werden wir das Kalkül des natürlichen Schließens als eine der grundlegenden Beweisformen kennenlernen und anwenden.

\section{Formale Sprache}

\begin{definition}[Formale Sprache]
Eine \textbf{formale Sprache} \(\mathcal{L}\) besteht aus zwei Hauptkomponenten:

\begin{enumerate}
    \item \textbf{Alphabet} \( \Sigma \): Eine endliche Menge von \textbf{Symbolen} (z.\,B.\ Buchstaben, Zeichen, Operatoren), die die Grundbausteine der Sprache bilden.
    \item \textbf{Syntaxregeln}: Regeln, die festlegen, wie die Symbole aus \( \Sigma \) kombiniert werden dürfen, um \textbf{wohlgeformte Formeln} (Wff) der Sprache zu bilden. Diese Regeln definieren die Struktur der zulässigen Ausdrücke in der Sprache.
\end{enumerate}

Eine \textbf{wohlgeformte Formel} ist eine endliche Zeichenkette aus Symbolen des Alphabets \( \Sigma \), die den Syntaxregeln der formalen Sprache \(\mathcal{L}\) entspricht.
\end{definition}

\begin{remark}
Die \textbf{Prädikatenlogik} und die \textbf{Aussagenlogik} sind zentrale Beispiele für formale Sprachen. Sie erfüllen die oben genannten Kriterien, indem sie jeweils ein spezifisches Alphabet und klare Syntaxregeln definieren, die die Konstruktion wohlgeformter Formeln ermöglichen.
\end{remark}

\subsection{Beispiele für Formale Sprachen}

Um die Definition einer formalen Sprache zu verdeutlichen, betrachten wir zwei grundlegende logische Systeme: die \textbf{Aussagenlogik} und die \textbf{Prädikatenlogik}.

\subsubsection{Aussagenlogik}

\begin{itemize}
    \item \textbf{Alphabet} \( \Sigma \): Besteht aus
    \begin{enumerate}
        \item \textbf{Aussagevariablen}: Symbole wie \( p, q, r, \ldots \), die atomare Aussagen repräsentieren.
        \item \textbf{Logische Operatoren}: 
        \begin{itemize}
            \item \( \neg \) (Nicht)
            \item \( \land \) (Und)
            \item \( \lor \) (Oder)
            \item \( \rightarrow \) (Impliziert)
            \item \( \leftrightarrow \) (Genau dann wenn)
        \end{itemize}
        \item \textbf{Klammern}: \( (, ) \), die zur Strukturierung von Ausdrücken verwendet werden.
    \end{enumerate}
    
    \item \textbf{Syntaxregeln}: Bestimmen, wie Aussagevariablen und Operatoren kombiniert werden dürfen, um \textbf{wohlgeformte Formeln} zu bilden. Beispiele hierfür sind:
    \begin{itemize}
        \item Eine Aussagevariable allein ist eine wohlgeformte Formel, z.\,B.\ \( p \).
        \item Wenn \( \phi \) eine wohlgeformte Formel ist, dann ist \( \neg \phi \) ebenfalls eine wohlgeformte Formel.
        \item Wenn \( \phi \) und \( \psi \) wohlgeformte Formeln sind, dann sind auch \( \phi \land \psi \), \( \phi \lor \psi \), \( \phi \rightarrow \psi \) und \( \phi \leftrightarrow \psi \) wohlgeformte Formeln.
        \item Klammern werden verwendet, um die Struktur und Priorität der Operatoren zu definieren, z.\,B.\ \( (p \land q) \rightarrow r \).
    \end{itemize}
\end{itemize}

\subsubsection{Prädikatenlogik}

\begin{itemize}
    \item \textbf{Alphabet} \( \Sigma \): Enthält die folgenden Komponenten:
    \begin{enumerate}
        \item \textbf{Individuenkonstanten}: Symbole, die spezifische Objekte in der Domäne repräsentieren, z.\,B.\ \( a, b, c, \ldots \).
        \item \textbf{Variablen}: Symbole wie \( x, y, z, \ldots \), die beliebige Elemente der Do-mäne darstellen können.
        \item \textbf{Funktionssymbole}: Symbole wie \( f, g, h, \ldots \), die Funktionen mit festgelegter Anzahl der Argumente repräsentieren, z.\,B.\ \( f(x), g(x, y) \).
        \item \textbf{Prädikate}: Symbole wie \( P, Q, R, \ldots \), die Relationen oder Eigenschaften ausdrücken und ebenfalls eine festgelegte Arity haben, z.\,B.\ \( P(x), Q(x, y) \).
        \item \textbf{Quantoren}: \( \forall \) (Für alle) und \( \exists \) (Es existiert), die die Bereiche der Variablen einschränken.
        \item \textbf{Logische Operatoren}: Wie in der Aussagenlogik, einschließlich \( \neg \) (Nicht), \( \land \) (Und), \( \lor \) (Oder), \( \rightarrow \) (Impliziert), \( \leftrightarrow \) (Genau dann wenn).
        \item \textbf{Gleichheitszeichen}: \( = \), das die Gleichheit zweier Terme ausdrückt.
        \item \textbf{Klammern}: \( (, ) \), die zur Strukturierung von Ausdrücken verwendet werden.
    \end{enumerate}
    
    \item \textbf{Syntaxregeln}: Regeln, die festlegen, wie die Symbole aus \( \Sigma \) kombiniert werden dürfen, um \textbf{wohlgeformte Formeln} (Wff) der Sprache zu bilden. Diese Regeln definieren die Struktur der zulässigen Ausdrücke in der Sprache.
\end{itemize}

\section{Grundbegriffe: Kalkül und Beweis}

Bevor wir uns dem Kalkül des natürlichen Schließens zuwenden, ist es wichtig, die grundlegenden Begriffe \textit{Kalkül} und \textit{Beweis} präzise zu definieren.

\begin{definition}[Kalkül]
Ein \textbf{Kalkül} (auch \textit{formales Kalkül} oder \textit{formales System} genannt) ist ein strukturiertes System, das aus folgenden Komponenten besteht:

\begin{enumerate}
    \item \textbf{Formale Sprache} \(\mathcal{L}\): Bestehend aus einem Alphabet von Symbolen und Syntaxregeln, die bestimmen, wie wohlgeformte Formeln gebildet werden.
    \item \textbf{Axiome} und/oder \textbf{Annahmen} (Prämissen): Eine Menge von wohlgeformten Formeln in der Sprache \(\mathcal{L}\), die ohne Beweis als wahr angenommen werden.
    \item \textbf{Inferenzenregeln}: Regeln, die festlegen, wie aus gegebenen Formeln neue Formeln abgeleitet werden können.
\end{enumerate}

Die \textbf{Axiome} und \textbf{Annahmen} sind wohlgeformte Formeln, die als Ausgangspunkt dienen. Die \textbf{Inferenzenregeln} ermöglichen es, innerhalb des Kalküls systematisch neue Aussagen zu beweisen.
\end{definition}

\begin{definition}[Beweis]
Ein \textbf{Beweis} in einem Kalkül ist eine endliche Folge von Aussagen
\[
\phi_1, \phi_2, \ldots, \phi_n
\]
wobei jede Aussage \(\phi_i\) entweder eine \textbf{Annahme} (Prämisse), ein \textbf{Axiom} ist oder sich durch Anwendung einer Inferenzenregel auf vorhergehende Aussagen \(\phi_{j}\) (mit \(j < i\)) ableiten lässt. Die letzte Formel \(\phi_n\) des Beweises ist die zu beweisende Aussage.
\end{definition}

\begin{definition}[Argument]
Ein \textbf{Argument} in der Logik besteht aus einer Menge von Aussagen, den sogenannten \textbf{Prämissen}, und einer Aussage, der \textbf{Schlussfolgerung}. Die Prämissen sollen die Schlussfolgerung unterstützen oder begründen.

Formal kann ein Argument als geordnetes Paar \((\Gamma, \phi)\)  definiert werden, wobei \(\Gamma\) eine Menge von Aussagen (die Prämissen) und \(\phi\) eine einzelne Aussage (die Schlussfolgerung) ist.

Ein Argument \((\Gamma, \phi)\) wird als \textbf{gültig} bezeichnet, wenn es eine Ableitung der Schlussfolgerung \(\phi\) aus den Prämissen in \(\Gamma\) gemäß den Regeln des Kalküls gibt.

\end{definition}


\section{Definition einer Theorie}

Eine \textbf{Theorie} in der Prädikatenlogik ist ein formales System, das aus einer Menge von Aussagen besteht, die als Axiome dienen. Aus diesen Axiomen können mittels logischer Schlussregeln weitere Aussagen bewiesen werden.

\begin{definition}[Theorie]
Eine \textbf{Theorie} \(\mathcal{T}\) in der Prädikatenlogik besteht aus einem \textbf{Axiomensystem} \(\Sigma\) und umfasst alle Aussagen \(\phi\) in der Sprache \(\mathcal{L}\), für die gilt:
\[
\Sigma \vdash \phi
\]
Das bedeutet, dass die Aussage \(\phi\) beweisbar ist aus den Axiomen \(\Sigma\) unter Verwendung der festgelegten Schlussregeln.
\end{definition}

\begin{remark}
Der wesentliche Unterschied zwischen einem \textbf{Kalkül} und einer \textbf{Theorie} besteht darin, dass der Kalkül das formale System mit seiner \textbf{Sprache}, \textbf{Axiomen} und \textbf{Inferenzenregeln} definiert, während eine Theorie eine spezifische Menge von Axiomen innerhalb dieses Kalküls ist und alle daraus ableitbaren Aussagen umfasst.
\end{remark}

\section{Eigenschaften einer Theorie}

Die Eigenschaften \textbf{Konsistenz} und \textbf{Vollständigkeit} sind zentrale Merkmale einer Theorie. Diese werden im Folgenden separat definiert und formal beschrieben.

\subsection{Konsistenz}

\begin{definition}[Konsistenz]
Eine \textbf{Theorie} \(\mathcal{T}\) mit Axiomensystem \(\Sigma\) ist \textbf{konsistent}, wenn es keine Aussage \(\phi\) gibt, für die sowohl \(\Sigma \vdash \phi\) als auch \(\Sigma \vdash \neg \phi\) gilt.
\end{definition}

\begin{remark}
Eine Theorie ist konsistent genau dann, wenn sie keine widersprüchlichen Aussagen enthält. Das bedeutet, es ist nicht möglich, sowohl eine Aussage als auch ihr Gegenteil aus den Axiomen abzuleiten.
\end{remark}

\subsection{Vollständigkeit}

\begin{definition}[Vollständigkeit]
Eine \textbf{Theorie} \(\mathcal{T}\) mit Axiomensystem \(\Sigma\) ist \textbf{vollständig}, wenn für jede Aussage \(\phi\) in der Sprache \(\mathcal{L}\) entweder \(\Sigma \vdash \phi\) oder \(\Sigma \vdash \neg \phi\) gilt.
\end{definition}

\begin{remark}
Eine Theorie ist vollständig genau dann, wenn für jede Aussage entweder die Aussage selbst oder ihre Negation aus den Axiomen ableitbar ist.
\end{remark}

\section{Arten von Definitionen}

\subsection{Explizite Definitionen}

\begin{definition}[Explizite Definition]
Sei \(\varphi(x_1,\dots,x_n)\) ein bereits bekannter, wohldefinierter Ausdruck (z.\,B.\ ein Prädikat oder Term) in einer formalen Sprache \(\mathcal{L}\) und \(Q(x_1,\dots,x_n)\) ein \emph{neues} Symbol, das in \(\mathcal{L}\) bisher nicht vorkam. Dann nennen wir
\[
\forall x_1,\dots,x_n \bigl( Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n) \bigr)
\]
eine \textbf{explizite Definition} von \(Q\). In dieser Definition heißt:
\begin{itemize}
    \item \(Q\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item \(\varphi\) \textbf{Definiens} (der bereits bekannte Ausdruck).
\end{itemize}

\noindent
\subsubsection{Wohldefiniertheit der expliziten Definition} 
\begin{enumerate}
    \item Alle in \(\varphi\) vorkommenden Symbole (Variablen, Konstanten, Funktions- oder Prädikatsymbole) sind bereits bekannt \emph{und} ihrerseits wohldefiniert.
    \item Das neue Symbol \(Q\) kommt in \(\varphi\) selbst nicht vor (keine Zirkularität).
    \item Für jede mögliche Belegung der Variablen \(x_1,\dots,x_n\) existiert genau ein \(y\), sodass \(\varphi(x_1,\dots,x_n) = y\). Formal ausgedrückt:
    \[
    \forall x_1,\dots,x_n \, \forall y \, \forall z \, \bigl( \varphi(x_1,\dots,x_n) = y \land \varphi(x_1,\dots,x_n) = z \rightarrow y = z \bigr).
    \]
    \item Für jede mögliche Belegung der Variablen \(x_1, \dots, x_n\) ist \(\varphi(x_1,\dots,x_n)\) widerspruchsfrei und erfüllt das Prinzip des ausgeschlossenen Dritten. Formal:
    \[
    \forall x_1,\dots,x_n \, \neg \bigl( \varphi(x_1,\dots,x_n) \land \neg \varphi(x_1,\dots,x_n) \bigr) \quad \text{(Konsistenz)},
    \]
    sowie
    \[
    \forall x_1,\dots,x_n \, \bigl( \varphi(x_1,\dots,x_n) \lor \neg \varphi(x_1,\dots,x_n) \bigr) \quad \text{(Vollständigkeit)}.
    \]
\end{enumerate}
\end{definition}

\subsection{Partielle Definitionen}
\begin{definition}[Partielle Definition]
Sei \(\varphi(x_1,\dots,x_n)\) ein bereits bekannter, wohldefinierter Ausdruck (z.\,B.\ ein Prädikat oder Term) in einer formalen Sprache \(\mathcal{L}\), \(C(x_1,\dots,x_n)\) eine Bedingung (ein weiteres Prädikat), und \(Q(x_1,\dots,x_n)\) ein \emph{neues} Symbol, das in \(\mathcal{L}\) bisher nicht vorkam. Dann nennen wir
\[
\forall x_1,\dots,x_n \bigl( C(x_1,\dots,x_n) \rightarrow ( Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n) ) \bigr)
\]
eine \textbf{partielle Definition} von \(Q\). In dieser Definition heißt:
\begin{itemize}
    \item \(Q\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item \(\varphi\) \textbf{Definiens} (der bereits bekannte Ausdruck),
    \item \(C\) \textbf{Bedingung} (das Prädikat, unter dem die Definition gilt).
\end{itemize}

\noindent
\subsubsection{Wohldefiniertheit der partiellen Definition} \emph{wohldefiniert}, wenn
\begin{enumerate}
    \item Alle in \(\varphi\) und \(C\) vorkommenden Symbole (Variablen, Konstanten und Funktions- oder Prädikatsymbole) sind bereits bekannt \emph{und} ihrerseits wohldefiniert.
    \item Das neue Symbol \(Q\) kommt weder in \(\varphi\) noch in \(C\) selbst vor (keine Zirkularität).
    \item Für jede mögliche Belegung der Variablen \(x_1,\dots,x_n\), für die \(C(x_1,\dots,x_n)\) wahr ist, existiert genau ein \(y\), sodass \(\varphi(x_1,\dots,x_n) = y\). Formal:
    \[
    \begin{aligned}
    & \forall x_1,\dots,x_n \, \forall y \, \forall z \, 
       \bigl( C(x_1,\dots,x_n) \rightarrow \\
    &\qquad (\varphi(x_1,\dots,x_n) = y \land 
              \varphi(x_1,\dots,x_n) = z \rightarrow y = z ) \bigr).
    \end{aligned}
    \]
    \item Für jede mögliche Belegung der Variablen \(x_1, \dots, x_n\), für die \(C(x_1,\dots,x_n)\) wahr ist, gilt, dass \(\varphi(x_1,\dots,x_n)\) widerspruchsfrei und vollständig ist. Formal:
    \[
    \begin{aligned}
    & \forall x_1,\dots,x_n \, 
       \bigl( C(x_1,\dots,x_n) \rightarrow \\
    &\qquad \neg\bigl( \varphi(x_1,\dots,x_n) \land 
                       \neg \varphi(x_1,\dots,x_n) \bigr) \bigr)
       \quad \text{(Konsistenz)}.
    \end{aligned}
    \]
    sowie
    \[
    \begin{aligned}
    & \forall x_1,\dots,x_n \, 
       \bigl( C(x_1,\dots,x_n) \rightarrow \\
    &\qquad ( \varphi(x_1,\dots,x_n) \lor 
               \neg \varphi(x_1,\dots,x_n) ) \bigr)
       \quad \text{(Vollständigkeit)}.
    \end{aligned}
    \]
\end{enumerate}
\end{definition}

\subsection{Rekursive Definition}

\begin{definition}[Rekursive Definition]
Sei \(\sigma(x_1, \ldots, x_n)\) ein \emph{neues} Symbol, das in einer formalen Sprache \(\mathcal{L}\) eingeführt werden soll. Eine \textbf{rekursive Definition} von \(\sigma\) besteht aus zwei Teilen:

\begin{itemize}
    \item \textbf{Basisfall:} Eine oder mehrere explizite Festlegungen von \(\sigma\) für spezielle Werte der Variablen, beispielsweise:
    \[
    \sigma(a_1, \ldots, a_k) \coloneqq b \quad \text{für feste Werte } a_1, \ldots, a_k \text{ und } b.
    \]
    Hierbei sind \(a_1, \ldots, a_k\) konkrete Werte aus der Domäne \(D\) und \(b\) ein bereits bekannter Term oder Wert in \(\mathcal{L}\).
    
    \item \textbf{Rekursionsvorschrift:} Eine oder mehrere Regeln, die \(\sigma(x_1, \ldots, x_n)\) für allgemeine Werte der Variablen definieren, indem sie auf zuvor definierte Werte von \(\sigma\) Bezug nehmen. Dies erfolgt in der Form:
    \[
    \sigma(x_1, \ldots, x_n) \coloneqq f\big(\sigma(y_1, \ldots, y_m), z_1, \ldots, z_p\big),
    \]
    wobei \(y_1, \ldots, y_m\) eine Teilmenge von \(x_1, \ldots, x_n\) ist, \(f\) eine bekannte Funktion in der Sprache \(\mathcal{L}\), und \(z_1, \ldots, z_p\) bekannte Terme in \(\mathcal{L}\) sind. Die Terme \(z_1, \ldots, z_p\) dürfen nicht rekursiv auf \(\sigma\) zurückgreifen, können jedoch von den Variablen \(x_1, \ldots, x_n\) abhängen oder andere bekannte Größen in \(\mathcal{L}\) enthalten.
\end{itemize}

In dieser Definition heißt:
\begin{itemize}
    \item \(\sigma\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item Die Basisfälle und Rekursionsvorschriften zusammen bilden das \textbf{Definiens}.
\end{itemize}

\noindent
\subsubsection{Wohldefiniertheit der rekursiven Definition}
\begin{enumerate}
    \item \textbf{Terminierung der Rekursion:} Für jede mögliche Belegung der Variablen \(x_1, \ldots, x_n\) wird die Rekursion nach endlich vielen Schritten beendet. Formal:
    \[
    \forall x_1, \ldots, x_n \, \exists k \in \mathbb{N} \, \bigl( \text{\(\sigma(x_1, \ldots, x_n)\) wird nach \(k\) Schritten berechnet} \bigr).
    \]
    \item \textbf{Eindeutigkeit:} Für jede Belegung der Variablen \(x_1, \ldots, x_n\) gibt es genau einen Wert \(y\), sodass die Rekursionsvorschrift für \(\sigma(x_1, \ldots, x_n)\) erfüllt ist. Formal:
    \[
    \forall x_1, \ldots, x_n \, \forall y \, \forall z \, \bigl( \sigma(x_1, \ldots, x_n) = y \land \sigma(x_1, \ldots, x_n) = z \rightarrow y = z \bigr).
    \]
    \item \textbf{Konsistenz der Rekursionsvorschrift:} Für jede mögliche Belegung der Variablen \(x_1, \ldots, x_n\) erzeugt die Rekursionsvorschrift keinen Widerspruch. Formal:
    \[
    \forall x_1, \ldots, x_n \, \neg \bigl( \sigma(x_1, \ldots, x_n) \land \neg \sigma(x_1, \ldots, x_n) \bigr).
    \]
    \item \textbf{Vollständigkeit der Rekursionsvorschrift:} Für jede mögliche Belegung der Variablen \(x_1, \ldots, x_n\) existiert ein definierter Wert. Formal:
    \[
    \forall x_1, \ldots, x_n \, \bigl( \sigma(x_1, \ldots, x_n) \lor \neg \sigma(x_1, \ldots, x_n) \bigr).
    \]
    \item \textbf{Monotonie der Rekursion:} Die Rekursionsvorschrift bezieht sich nur auf kleinere oder gleichwertige Argumente, die gemäß einer festen Ordnungsrelation \(R\) definiert sind. Formal:
    \[
    \forall x_1, \ldots, x_n \, \forall y_1, \ldots, y_m \, \bigl( R((y_1, \ldots, y_m), (x_1, \ldots, x_n)) \bigr),
    \]
    wobei \(R\) die Terminierung sicherstellt.
\end{enumerate}
\end{definition}


\subsection{Implizite Definition}

Die \textbf{implizite Definition} ist eine Methode, neue Symbole oder Konzepte in einer Theorie einzuführen, indem ihre Eigenschaften durch Axiome festgelegt werden, anstatt sie direkt zu definieren.

\begin{definition}[Implizite Definition]
Eine \textbf{implizite Definition} eines neuen Symbols \(\sigma\) in einer Theorie \(\mathcal{T}\) besteht aus einer Menge von \textbf{Aussagen} \(\Phi(\sigma)\), die die Eigenschaften von \(\sigma\) festlegen.
In formalen Kalkülen dürfen diese Axiome durch \textbf{äquivalente Schlussregeln} ersetzt werden, die dieselben Eigenschaften syntaktisch ausdrücken, um die Anwendbarkeit zu erleichtern.

\end{definition}

\subsubsection{Wohldefiniertheit einer Impliziten Definition}

\begin{definition}[Wohldefiniertheit einer impliziten Definition]
Eine implizite Definition \(\Phi(\sigma)\) ist \emph{wohldefiniert}, wenn sie die folgenden Eigenschaften erfüllt:
\begin{enumerate}
    \item \textbf{Konsistenz:} Die Menge der Aussagen \(\Phi(\sigma)\) darf keine widersprüchlichen Bedingungen enthalten. Formal:
    \[
    \neg \exists \phi, \psi \in \Phi(\sigma) \, \bigl( \phi \land \neg \phi \bigr).
    \]

    \item \textbf{Existenz:} Es muss mindestens eine Interpretation von \(\sigma\) geben, die alle Aussagen in \(\Phi(\sigma)\) erfüllt. Formal:
    \[
    \exists \sigma' \, \forall \phi \in \Phi(\sigma) \, \bigl( \phi[\sigma' / \sigma] \bigr),
    \]
    wobei \(\phi[\sigma' / \sigma]\) die Aussage \(\phi\) mit der Interpretation \(\sigma'\) für das Symbol \(\sigma\) bezeichnet.

    \item \textbf{Eindeutigkeit:} Es darf höchstens eine Interpretation von \(\sigma\) geben, die alle Aussagen in \(\Phi(\sigma)\) erfüllt. Formal:
    \[
    \forall \sigma', \sigma'' \, \bigl( (\forall \phi \in \Phi(\sigma) \, \phi[\sigma' / \sigma]) \land (\forall \phi \in \Phi(\sigma) \, \phi[\sigma'' / \sigma]) \rightarrow \sigma' = \sigma'' \bigr).
    \]
\end{enumerate}
\end{definition}

\subsection{Das Iota-Symbol}

In manchen Fällen möchten wir einen Begriff oder ein Symbol definieren, der oder das eindeutig durch eine bestimmte Eigenschaft charakterisiert ist. Hier kommt das \textbf{Iota-Symbol} \( \iota \) zum Einsatz, das in der formalen Logik verwendet wird, um auf ein eindeutig bestimmtes Objekt Bezug zu nehmen.

\begin{definition}[Iota-Symbol (\( \iota \))]
Sei \( P(x) \) eine Aussage oder Eigenschaft über \( x \). Falls es genau ein \( x \) gibt, für das \( P(x) \) gilt, schreiben wir:
\[
\iota x \, P(x)
\]
und meinen damit \enquote{das eindeutige \( x \), für das \( P(x) \) gilt}.

Formal bedeutet dies:
\[
\exists! x \, P(x) \quad \text{und} \quad \iota x \, P(x) \text{ ist dieses eindeutige } x.
\]
Dabei steht \( \exists! x \, P(x) \) für \enquote{Es existiert genau ein \( x \), für das \( P(x) \) gilt} und ist definiert als:
\[
\exists x \, P(x) \land \forall y \, (P(y) \rightarrow y = x).
\]
\end{definition}

\paragraph{Definition einer neuen Konstante mittels \(\iota\)}

\begin{definition}[Iota-Definition]
Sei \(P(x)\) eine bereits bekannte und wohldefinierte Eigenschaft in einer formalen Sprache \(\mathcal{L}\). Sei \(\sigma\) ein \emph{neues} Symbol (z.\,B.\ eine neue Konstante), das in \(\mathcal{L}\) bisher nicht vorkam. Dann definieren wir
\[
\sigma \coloneqq \iota x\,P(x)
\]
\emph{genau dann}, wenn \(\exists!\,x\,P(x)\) (es existiert \emph{genau ein} \(x\), für das \(P(x)\) gilt). 

\noindent
In dieser Definition heißt:
\begin{itemize}
    \item \(\sigma\) \textbf{Definiendum} (das neu eingeführte Symbol),
    \item \(\iota x\,P(x)\) \textbf{Definiens} (der bereits bekannte Ausdruck mit dem Iota-Operator).
\end{itemize}

\noindent
\textbf{Wohldefiniertheit der Iota-Definition} setzt voraus:
\begin{enumerate}
    \item \(\exists!\,x\,P(x)\), d.\,h.\ es existiert \emph{genau ein} \(x\), für das \(P(x)\) gilt.
    \item Das neue Symbol \(\sigma\) kommt in \(\iota x\,P(x)\) selbst nicht vor (keine Zirkularität).
\end{enumerate}
\end{definition}


\section{Grundlegende Beweisprinzipien}

In diesem Abschnitt werden weiterführende Konzepte vorgestellt, die im Rahmen von Beweisen und der Entwicklung formaler Theorien eine zentrale Rolle spielen.


\begin{definition}[Theorem]
Ein \textbf{Theorem} ist eine Aussage, die innerhalb eines Kalküls unter Verwendung der definierten Inferenzenregeln und gegebenen Annahmen bewiesen wurde. Theoreme sind zentrale Bestandteile mathematischer Theorien und dienen als Bausteine für weiterführende Beweise.
\end{definition}

\begin{definition}[Lemma]
Ein \textbf{Lemma} ist ein unterstützender Satz, der im Verlauf des Beweisens eines Theorems verwendet wird. Lemmata dienen dazu, komplexere Beweise in überschaubare Schritte zu gliedern.
\end{definition}

\begin{definition}[Korollar]
Ein \textbf{Korollar} ist eine Aussage, die sich unmittelbar aus einem bereits bewiesenen Theorem oder Lemma ableiten lässt. Korollare sind oft direkte Konsequenzen der zuvor bewiesenen Aussagen.
\end{definition}
\begin{remark}
Die in Theoremen, Lemmata und Korollaren zu zeigenden Argumente notieren wir im Folgenden durch \(\Gamma \vdash \phi\). Dabei stellt \(\Gamma\) eine Aufzählung der Prämissen dar, die notwendig sind, um \(\phi\) zu zeigen.

\noindent
\textbf{Keine Annahmen:} Falls keine Annahmen für den Beweis notwendig sind, um \(\phi\) zu zeigen, notieren wir das Argument schlicht als \(\phi\). Dies impliziert, dass der Beweis aus dem \emph{leeren} Prämissenkontext \(\Gamma = \varnothing\) geführt werden kann, d.\,h.\ \(\varnothing \vdash \phi\).
Besteht \(\Gamma\) aus lediglich einer Annahme \(\psi\) und gilt neben \(\psi\vdash\phi\) auch \(\phi\vdash\psi\), so schreiben wir für beide Argumente schlicht: \(\psi\dashv\vdash \phi\).
\end{remark}

\begin{definition}[Hilfsdefinition]
Eine \textbf{Hilfsdefinition} ist eine unterstützende Definition, die im Verlauf der Entwicklung einer formalen Theorie eingeführt wird, um eine komplexere Hauptdefinition vorzubereiten oder zu vereinfachen. Hilfsdefinitionen können als Zwischenstufen betrachtet werden, die es ermöglichen, komplexe Begriffe in mehreren Schritten aufzubauen.
\end{definition}

\begin{remark}
Hilfsdefinitionen dienen dazu, Definitionen modular und über-sichtlich zu gestalten. Sie sind im Allgemeinen lokal auf den Kontext der Hauptdefinition beschränkt.
\end{remark}

\begin{definition}[Temporäre Definition]
Eine \textbf{temporäre Definition} ist eine Definition, die ausschließlich innerhalb eines Beweises eingeführt wird, um dessen Struktur zu vereinfachen und zu verdeutlichen. Diese Definition hat keine Bedeutung außerhalb des Beweises und wird nach Abschluss des Beweises nicht weiter verwendet.
\end{definition}

\begin{remark}
Temporäre Definitionen sind nützlich, um komplexe Beweisschritte zu modularisieren und zu vereinfachen. Sie werden nur im Rahmen eines einzelnen Beweises verwendet und danach verworfen.
\end{remark}

\section{Kalkül des natürlichen Schließens}

\subsection{Einführung}
Das Kalkül des natürlichen Schließens ist ein formales System, das in der Aussagen- und Prädikatenlogik verwendet wird, um Beweise zu führen. Es wurde entwickelt, um eine Methode zur Verfügung zu stellen, die der Art und Weise, wie Menschen intuitiv logische Schlussfolgerungen ziehen, so nahe wie möglich kommt.

In Bezug auf die oben definierte \textbf{Definition des Kalküls} stellt das natürliche Schließen ein spezifisches Kalkül dar, das \textbf{keine Axiome} verwendet, sondern sich vollständig auf eine festgelegte Menge von \textbf{Inferenzenregeln} stützt. Diese Inferenzenregeln sind die fundamentalen Bausteine des Kalküls und bestimmen, wie aus gegebenen Formeln neue Formeln abgeleitet werden können. Sie definieren die zulässigen Schritte innerhalb des Systems und gewährleisten die logische Konsistenz und Korrektheit der abgeleiteten Aussagen.

Ein \textbf{Beweis} im Kalkül des natürlichen Schließens ist somit eine endliche Folge von Formeln, bei der jede Formel entweder eine \textbf{Annahme} (Prämisse) ist oder sich durch Anwendung einer der Inferenzenregeln auf zuvor eingeführte Formeln ableiten lässt, gemäß der \textbf{Definition des Beweises}. Diese strukturierte Vorgehensweise stellt sicher, dass jeder Schritt des Beweises logisch korrekt ist und auf den festgelegten Regeln des Kalküls basiert.

\subsection{Beweise im Kalkül des natürlichen Schließens}

Im Kalkül des natürlichen Schließens werden Beweise oft in einer tabellarischen Form, der sogenannten \textbf{Beweistabelle}, dargestellt. Jede Zeile einer Beweistabelle stellt einen Ableitungsschritt dar, der eine logische Aussage zusammen mit einer Regel und den Referenzen auf die Zeilen enthält, auf die die Regel angewendet wird.

\subsubsection{Allgemeine Form einer Beweistabelle}

Die allgemeine Form einer Zeile in einer Beweistabelle ist:

\[
\begin{array}{llll}
	i_1, i_2, \ldots, i_k & (n) & P & \text{Regelname} \, j_1, j_2, \ldots, j_l \\
\end{array}
\]

Hier bedeutet:
\begin{itemize}
    \item \(i_1, i_2, \ldots, i_k\): Die Indizes der Annahmen, von denen die abgeleitete Aussage \(P\) abhängt.
    \item \((n)\): Die Zeilennummer, die den aktuellen Ableitungsschritt angibt.
    \item \(P\): Die abgeleitete Aussage in dieser Zeile.
    \item \textit{Regelname}: Der Name der angewendeten Inferenzregel oder das referenzierte Theorem/Definition.
    \item \(j_1, j_2, \ldots, j_l\): Die Zeilennummern der Aussagen, auf die die Regel angewendet wird.
\end{itemize}

\subsubsection{Beweistabelle mit Theoremen und Definitionen}

Um die Übersichtlichkeit zu erhöhen, können Theoreme und Definitionen als spezielle Inferenzregeln oder als referenzierte Schritte behandelt werden. Dies kann durch klare Kennzeichnung innerhalb der Beweistabelle erfolgen.

\begin{definition}[Beweistabelle]
Eine \textbf{Beweistabelle} ist eine endliche Sequenz von Zeilen \( \{Z_1, Z_2, \ldots, Z_n\} \), wobei jede Zeile \( Z_m \) (\(1 \leq m \leq n\)) durch die folgenden Bedingungen definiert ist:

\begin{enumerate}
    \item \textbf{Basisfall:} Die ersten Zeilen \( Z_1, Z_2, \ldots, Z_k \) entsprechen den Annahmen oder Axiomen des Kalküls.
    \item \textbf{Ableitungsschritte:} Für jede Zeile \( Z_m \) (\(m > k\)) gilt, dass \( Z_m \) durch Anwendung einer Inferenzregel, eines Theorems oder einer Definition auf eine oder mehrere vorhergehende Zeilen \( Z_{j_1}, Z_{j_2}, \ldots, Z_{j_l} \) (\(j_i < m\)) abgeleitet wird.
\end{enumerate}

Jede Zeile \( Z_m \) besteht aus:
\[
\begin{array}{llll}
	i_1, i_2, \ldots, i_k & (m) & P & \text{Regelname / Theorem / Definition} \, j_1, j_2, \ldots, j_l \\
\end{array}
\]
\end{definition}

\subsubsection{Beispiel für eine Beweistabelle}
Um das Prinzip zu veranschaulichen, betrachten wir einen einfachen Beweis für ein Argument der Aussagenlogik:

\[
P \rightarrow Q, P \vdash Q
\]

Die Beweistabelle für dieses Argument sieht folgendermaßen aus:

\[
\begin{array}{llll}
	1 & (1) & P \rightarrow Q & \rA \\
	2 & (2) & P & \rA \\
	1,2 & (3) & Q & \rRE{1,2} \\
\end{array}
\]

In dieser Tabelle:
\begin{itemize}
    \item Zeile 1: Die Annahme \(P \rightarrow Q\) wird eingeführt (\(\rA\), Annahme).
    \item Zeile 2: Die Annahme \(P\) wird eingeführt ( \(\rA \), Annahme).
    \item Zeile 3: Die Regel \(\rightarrow\)-Elimination (\(\rRE{}\)) wird angewendet, um \(Q\) aus den Zeilen 1 und 2 abzuleiten.
\end{itemize}



\subsection{Regeln für die Annahmeneinführung}
\label{rule:A}
Die Annahmeneinführung ist eine grundlegende Regel im Kalkül des natürlichen Schließens. Sie erlaubt es uns, eine Aussage als Annahme in den Beweis einzuführen. Diese Annahme kann dann in den folgenden Zeilen des Beweises verwendet werden, um weitere Aussagen abzuleiten.

Die Regel der Annahmeneinführung wird oft durch das Symbol \(A\) dargestellt. Es gibt keine spezifischen Bedingungen für die Anwendung dieser Regel, da sie einfach eine Aussage als Annahme in den Beweis einführt.

\[
\begin{array}{llll}	
i & (i) & P & \rA \\
\end{array}
\]

Hierbei repräsentiert \(i\) die Zeilennummer der Annahme, und \(P\) ist die Aussage, die als Annahme eingeführt wird.

Es ist wichtig zu beachten, dass Annahmen im Kalkül des natürlichen Schließens nicht unbedingt wahr sein müssen. Sie dienen lediglich als Ausgangspunkt für den Beweis. Wenn wir aus einer Annahme einen Widerspruch ableiten können, dann können wir schließen, dass die ursprüngliche Annahme falsch sein muss. Dies ist die Grundlage für den Beweis durch Widerspruch, eine wichtige Methode im Kalkül des natürlichen Schließens.

In einigen Fällen können wir eine Annahme auch wieder aufheben, wenn wir ihre Konsequenzen untersucht haben. Dies ist zum Beispiel die Grundlage für die Regel der Implikationseinführung, die es uns erlaubt, aus der Annahme \(P\) und der daraus abgeleiteten Aussage \(Q\) die Implikation \(P \rightarrow Q\) zu erzeugen. In diesem Fall sagen wir, dass die Annahme \(P\) für den Beweis der Implikation \(P \rightarrow Q\) entfernt oder aufgehoben wurde.


\subsection{Regeln für die Konjunktion}

\subsubsection{Einführung der Konjunktion}
\label{rule:AI}
Die Konjunktion, oft dargestellt durch das Symbol \(\land\), ist ein logischer Operator, der \enquote{und} bedeutet. Im Kalkül des natürlichen Schließens gibt es zwei grundlegende Regeln für die Konjunktion: die Einführungs- und die Eliminierungsregel.

\begin{definition}[Einführungsregel der Konjunktion]
Seien die Zeilen \( m \) und \( n \) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \( m \):}
\[
\begin{array}{llll}
    i & (m) & P & \dots \\
\end{array}
\]

\textbf{Zeile \( n \):}
\[
\begin{array}{llll}
    j & (n) & Q & \dots \\
\end{array}
\]

Die Einführungsregel \(\land I\) erlaubt die Ableitung von \( P \land Q \) in einer neuen Zeile \( k \). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i, j & (k) & P \land Q & \rAI{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m, n < k\), wobei \(m\) die Zeile ist, in der \(P\) abgeleitet wurde und \(n\) ist die Zeile in der \(Q\) abgeleitet wurde.
    \item Die Indizes \( i \) und \( j \) geben die Listen der Annahmen an, die für die Ableitungen in den Zeilen \( m \) und \( n \) verwendet wurden. 
\end{itemize}

\end{definition}

\subsubsection{Eliminierung der Konjunktion}
\label{rule:AE1}\label{rule:AE2}
Die Konjunktion \(\land\) erlaubt es, aus einer zusammengesetzten Aussage die einzelnen Bestandteile zu isolieren. Im Kalkül des natürlichen Schließens werden hierfür zwei Eliminierungsregeln definiert: \(\land E1\) und \(\land E2\).

\begin{definition}[Eliminierungsregeln der Konjunktion]
Sei die Zeile \(m\) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & P \land Q & \dots \\
\end{array}
\]

Die Eliminierungsregeln \(\land E1\) und \(\land E2\) erlauben es, aus \(P \land Q\) jeweils \(P\) oder \(Q\) abzuleiten. Dies wird wie folgt notiert:

\textbf{Eliminierung \(\land E1\):}
\[
\begin{array}{llll}
    i & (k) & P & \rAEa{m} \\
\end{array}
\]

\textbf{Eliminierung \(\land E2\):}
\[
\begin{array}{llll}
    i & (n) & Q & \rAEb{m} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < k, n\), wobei \(m\) die Zeile ist, in der \(P \land Q\) abgeleitet wurde.
    \item Der Index \(i\) repräsentiert die Liste der Annahmen, die für die Ableitung von \(P \land Q\) verwendet wurden. Diese Liste bleibt für die Ableitungen von \(P\) und \(Q\) unverändert.
\end{itemize}

Die Eliminierungsregeln ermöglichen es, eine Konjunktion in ihre Bestandteile zu zerlegen und jeweils nur einen der beiden Teile weiter zu verwenden.
\end{definition}

\subsection{Regeln für die Disjunktion}

\subsubsection{Einführung der Disjunktion}
\label{rule:OI1}\label{rule:OI2}
Die Disjunktion, oft dargestellt durch das Symbol \(\lor\), ist ein logischer Operator, der \enquote{oder} bedeutet. Im Kalkül des natürlichen Schließens gibt es zwei Einführungsregeln für die Disjunktion: \(\lor I1\) und \(\lor I2\).

\begin{definition}[Einführungsregeln der Disjunktion]
Sei die Zeile \(m\) einer Beweistabelle wie folgt definiert:

\textbf{Einführung \(\lor I1\):}
\[
\begin{array}{l l l l}
    i & (m) & P & \dots \\
\end{array}
\]

Die Regel \(\lor I1\) erlaubt die Ableitung von \(P \lor Q\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{l l l l}
    i & (k) & P \lor Q & \rOIa{m} \\
\end{array}
\]

\textbf{Einführung \(\lor I2\):}
\[
\begin{array}{l l l l}
    i & (m) & Q & \dots \\
\end{array}
\]

Die Regel \(\lor I2\) erlaubt die Ableitung von \(P \lor Q\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{l l l l}
    i & (k) & P \lor Q & \rOIb{m} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < k\), wobei \(m\) die Zeile ist, in der \(P\) bzw. \(Q\) abgeleitet wurde.
    \item Der Index \(i\) gibt die Liste der Annahmen an, die für die Ableitung in Zeile \(m\) verwendet wurden.
\end{itemize}

\end{definition}

\subsubsection{Eliminierung der Disjunktion}
\label{rule:OE}
Die Disjunktion \(\lor\) erlaubt es, aus einer zusammengesetzten Aussage mit mehreren Alternativen auf eine gemeinsame Konsequenz zu schließen. Im Kalkül des natürlichen Schließens wird hierfür die Eliminierungsregel \(\lor E\) definiert.

\begin{definition}[Eliminierungsregel der Disjunktion]
Sei die Zeile \(m\) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{l l l l}
    i & (m) & P \lor Q & \dots \\
\end{array}
\]

Die Eliminierung der Disjunktion erfolgt durch eine Fallunterscheidung mit zwei separaten Unterbeweistabellen, die wie folgt aufgebaut sind:

\paragraph{Fall 1: \(P\) führt zu \(R\)}
\[
\begin{array}{l l l l}
    n_1 & (n_1) & P & \rA \\
    j,n_1 & (k_1) & R & \dots \\
\end{array}
\]

\paragraph{Fall 2: \(Q\) führt zu \(R\)}
\[
\begin{array}{l l l l}
    n_2 & (n_2) & Q & \rA \\
    k,n_2 & (k_2) & R & \dots \\
\end{array}
\]

\textbf{Ableitung von \(R\):}
Nachdem beide Fälle betrachtet wurden, erlaubt die Regel \(\lor E\) die Ableitung von \(R\) in einer neuen Zeile \(k\):
\[
\begin{array}{l l l l}
    i,j,k & (k) & R & \rOE{m,n_1,k_1,n_2,k_2} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < n_1, n_1 < k_1, k_1 < k\).
    \item \(m < n_2, n_2 < k_2, k_2 < k\).
    \item Die Indizes \(i, j, k\) geben die Listen der Annahmen an, die für die Ableitungen in den Zeilen \(m, k_1, k_2\) verwendet wurden.
    \item Weder die Liste \(j\) der Annahmen der Zeile \(k_1\) die Annahme noch die Liste \(k\) der Annahmen der Zeile \(k_2\) enthalten die Annahmen \(n_1\) bzw. \(n_2\).
\end{itemize}

Die Eliminierungsregel ermöglicht es, eine Disjunktion aufzulösen, indem beide Fälle separat betrachtet und jeweils auf die gemeinsame Konsequenz \(R\) geschlossen wird.
\end{definition}

\begin{lemma}[Beispiel - Vertauschung der Disjunktion]
\( P \lor Q \vdash Q \lor P \)
\end{lemma}

\textbf{Erläuterung:} Dieses Theorem zeigt, dass die Reihenfolge in einer Disjunktion vertauscht werden kann. Der Beweis erfolgt durch Anwendung der Regel \(\lor E\) mit einer Fallunterscheidung. Hierzu wird jeweils der Fall \(P\) und der Fall \(Q\) separat betrachtet und in beiden Fällen gezeigt, dass \(Q \lor P\) gilt.

\begin{tabproof}
  \proofstep{1}{P \lor Q}{\rA}
  \proofcase[1]{P \vdash Q \lor P}
  \proofstep{2}{P}{\rA}
  \proofstep{2}{Q \lor P}{\rOIb{2}}
  \proofcase[2]{Q \vdash Q \lor P}
  \proofstep{4}{Q}{\rA}
  \proofstep{4}{Q \lor P}{\rOIa{4}}
  \proofstep{1}{Q \lor P}{\rOE{1,2,3,4,5}}
\end{tabproof}

\subsection{Regeln für die Implikation}

Die Implikation, oft dargestellt durch das Symbol \(\rightarrow\), ist ein logischer Operator, der \enquote{impliziert} oder \enquote{führt zu} bedeutet. Im Kalkül des natürlichen Schließens gibt es zwei grundlegende Regeln für die Implikation: die Einführungs- und die Eliminierungsregel.

\subsubsection{Einführung der Implikation}
\label{rule:RI}

\begin{definition}[Einführungsregel der Implikation]
Seien die Zeilen \( m \) und \( n \) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \( m \):}
\[
\begin{array}{llll}
    m & (m) & P & \rA \\
\end{array}
\]

\textbf{Zeile \( n \):}
\[
\begin{array}{llll}
    m,i & (n) & Q & \dots \\
\end{array}
\]

Die Einführungsregel \(\rightarrow I\) erlaubt die Ableitung von \( P \rightarrow Q \) in einer neuen Zeile \( k \). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i & (k) & P \rightarrow Q & \rRI{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < n < k\), wobei \(m\) die Zeile ist, in der \(P\) abgeleitet wurde, und \(n\) ist die Zeile, in der \(Q\) abgeleitet wurde.
    \item Die Menge der Annahmen \(i\) darf die Annahme \(m\) nicht enthalten.
\end{itemize}
\end{definition}

\subsubsection{Eliminierung der Implikation}
\label{rule:RE}

\begin{definition}[Eliminierungsregel der Implikation]
Seien die Zeilen \( m \) und \(n\) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \( m \):}
\[
\begin{array}{llll}
    i & (m) & P \rightarrow Q & \dots \\
\end{array}
\]

\textbf{Zeile \( n \):}
\[
\begin{array}{llll}
    j & (n) & P & \dots \\
\end{array}
\]

Die Eliminierungsregel \(\rightarrow E\) erlaubt es, aus \(P \rightarrow Q\) und \(P\) die Aussage \(Q\) in einer neuen Zeile \( k \) abzuleiten. Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i, j & (k) & Q & \rRE{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m, n < k\), wobei \(m\) die Zeile ist, in der \(P \rightarrow Q\) abgeleitet wurde, und \(n\) die Zeile, in der \(P\) abgeleitet wurde.
    \item Die Indizes \(i\) und \(j\) geben die Listen der Annahmen an, die für die Ableitungen in den Zeilen \(m\) und \(n\) verwendet wurden.
\end{itemize}
\end{definition}

\subsection{Regeln für die Äquivalenz}

\subsubsection{Einführung der Äquivalenz}
\label{rule:LRI}
Die Äquivalenz, oft dargestellt durch das Symbol \(\leftrightarrow\), ist ein logischer Operator, der \enquote{genau dann, wenn} bedeutet. Im Kalkül des natürlichen Schließens gibt es zwei grundlegende Regeln für die Äquivalenz: die Einführungs- und die Eliminierungsregel.

\begin{definition}[Einführungsregel der Äquivalenz]
Seien die Zeilen \( m \) und \( n \) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \( m \):}
\[
\begin{array}{llll}
    i & (m) & P \rightarrow Q & \dots \\
\end{array}
\]

\textbf{Zeile \( n \):}
\[
\begin{array}{llll}
    j & (n) & Q \rightarrow P & \dots \\
\end{array}
\]

Die Einführungsregel \(\leftrightarrow I\) erlaubt die Ableitung von \( P \leftrightarrow Q \) in einer neuen Zeile \( k \). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i, j & (k) & P \leftrightarrow Q & \rLRI{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m, n < k\), wobei \(m\) die Zeile ist, in der \(P \rightarrow Q\) abgeleitet wurde, und \(n\) die Zeile, in der \(Q \rightarrow P\) abgeleitet wurde.
    \item Die Indizes \( i \) und \( j \) bezeichnen die Listen der Annahmen, die für die Ableitungen in den Zeilen \( m \) und \( n \) verwendet wurden.
\end{itemize}

\end{definition}

\begin{definition}[Alternative Einführungsregel der Äquivalenz]
Seien \( m \), \( n \), \( o \) und \( p \) Zeilen einer Beweistabelle, die wie folgt definiert sind:

\textbf{Zeile \( m \):}
\[
\begin{array}{llll}
    i & (m) & P & \rA \\
\end{array}
\]

\textbf{Zeile \( n \):}
\[
\begin{array}{llll}
    i,j & (n) & Q & \dots \\
\end{array}
\]

\textbf{Zeile \( o \):}
\[
\begin{array}{llll}
    k & (o) & Q & \rA \\
\end{array}
\]

\textbf{Zeile \( p \):}
\[
\begin{array}{llll}
    k,l & (p) & P & \dots \\
\end{array}
\]

Die Einführungsregel \(\leftrightarrow I\) erlaubt die Ableitung von \( P \leftrightarrow Q \) in einer neuen Zeile \( w \). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    j,l & (w) & P \leftrightarrow Q & \rLRI{m,n,o,p} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item Die Indizes \( j \) und \( l \) bezeichnen die Listen der Annahmen, die für die Ableitungen in den Zeilen \( n \) bzw. \( p \) verwendet wurden.
\end{itemize}

\end{definition}

\subsubsection{Eliminierung der Äquivalenz}
\label{rule:LRE1}\label{rule:LRE2}
Die Äquivalenz \(\leftrightarrow\) erlaubt es, aus einer zusammengesetzten Aussage die beiden Richtungsimplikationen zu isolieren. Im Kalkül des natürlichen Schließens werden hierfür zwei Eliminierungsregeln definiert: \(\leftrightarrow E1\) und \(\leftrightarrow E2\).

\begin{definition}[Eliminierungsregeln der Äquivalenz]
Sei die Zeile \(m\) einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & P \leftrightarrow Q & \dots \\
\end{array}
\]

Die Eliminierungsregeln \(\leftrightarrow E1\) und \(\leftrightarrow E2\) erlauben es, aus \(P \leftrightarrow Q\) jeweils \(P \rightarrow Q\) oder \(Q \rightarrow P\) abzuleiten. Dies wird wie folgt notiert:

\textbf{Eliminierung \(\leftrightarrow E1\):}
\[
\begin{array}{llll}
    i & (k) & P \rightarrow Q & \rLREa{m} \\
\end{array}
\]

\textbf{Eliminierung \(\leftrightarrow E2\):}
\[
\begin{array}{llll}
    i & (n) & Q \rightarrow P & \rLREb{m} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < k, n\), wobei \(m\) die Zeile ist, in der \(P \leftrightarrow Q\) abgeleitet wurde.
    \item Der Index \(i\) repräsentiert die Liste der Annahmen, die für die Ableitung von \(P \leftrightarrow Q\) verwendet wurden. Diese Liste bleibt für die Ableitungen von \(P \rightarrow Q\) und \(Q \rightarrow P\) unverändert.
\end{itemize}

Die Eliminierungsregeln ermöglichen es, eine Äquivalenz in ihre Bestandteile zu zerlegen und jeweils nur eine der beiden Richtungsimplikationen weiter zu verwenden.
\end{definition}

\subsubsection{Ersetzungsregel der Äquivalenz}
\label{rule:LRSubst}
\begin{definition}[Abgeleitete Ersetzungsregel \(\leftrightarrow S\)]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & \phi \leftrightarrow \psi & \dots \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    j & (n) & \theta(\phi) & \dots \\
\end{array}
\]

Die Ersetzungsregel \(\leftrightarrow S\) erlaubt die Ableitung von \(\theta(\psi)\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i,j & (k) & \theta(\psi) & \rLRS{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m, n < k\), wobei \(m\) die Zeile ist, in der \(\phi \leftrightarrow \psi\) abgeleitet wurde, und \(n\) die Zeile, in der der Ausdruck \(\theta(\phi)\) vorliegt.
    \item Der Teil\textit{ausdruck} \(\phi\) in \(\theta(\phi)\) wird durch \(\psi\) ersetzt, sobald \(\phi \leftrightarrow \psi\) gilt.
    \item Die Indizes \(i, j\) repräsentieren die Listen der Annahmen, die für die Ableitung von \(\phi \leftrightarrow \psi\) bzw. \(\theta(\phi)\) verwendet wurden. Diese Listen bleiben unverändert.
\end{itemize}
\end{definition}

\begin{definition}[Abgeleitete Ersetzungsregel]
Gegeben sei in einer Beweistabelle:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & \phi \leftrightarrow \psi & \dots \\
\end{array}
\]

mit einer beliebigen wohldefinierten Formel \(\theta(\cdot)\). 

Die \(\leftrightarrow E\)-Regel (Erweiterte Ersetzungsregel) erlaubt es, in einer neuen Zeile \(k\) Folgendes einzuführen:
\[
\begin{array}{llll}
   i & (k) & \theta(\phi) \leftrightarrow \theta(\psi) & \rLRS{m}
\end{array}
\]
wobei
\begin{itemize}
    \item \(m < k\).
    \item In \(\theta(\cdot)\) wird \(\phi\) konsistent durch \(\psi\) ersetzt (und umgekehrt), da \(\phi \leftrightarrow \psi\) vorliegt.
    \item Der Index \(i\) (bzw. die Liste der Annahmen) wird aus Zeile \(m\) übernommen.
\end{itemize}
\end{definition}

\subsection{Regeln für den Widerspruch und die Negation}

Der Widerspruch, dargestellt durch das Symbol \(\bot\), und die Negation, dargestellt durch das Symbol \(\neg\), sind zentrale Bestandteile des Kalküls des natürlichen Schließens. Es gibt drei grundlegende Regeln in diesem Zusammenhang: die Einführungsregel des Widerspruchs, die Einführungsregel der Negation und die Eliminierungsregel der Negation.

\subsection{Regeln für den Widerspruch und die Negation}

Der Widerspruch, dargestellt durch das Symbol \(\bot\), und die Negation, dargestellt durch das Symbol \(\neg\), sind zentrale Bestandteile des Kalküls des natürlichen Schließens. Es gibt drei grundlegende Regeln in diesem Zusammenhang: die Einführungsregel des Widerspruchs, die Einführungsregel der Negation und die Eliminierungsregel der Negation.

\subsubsection{Einführung des Widerspruchs}
\label{rule:BI}

\begin{definition}[Einführungsregel des Widerspruchs]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & P & \dots \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    j & (n) & \neg P & \dots \\
\end{array}
\]

Die Einführungsregel \(\bot I\) erlaubt die Ableitung von \(\bot\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i, j & (k) & \bot & \rBI{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m, n < k\), wobei \(m\) die Zeile ist, in der \(P\) abgeleitet wurde, und \(n\) die Zeile, in der \(\neg P\) abgeleitet wurde.
    \item Die Indizes \(i\) und \(j\) geben die Listen der Annahmen an, die für die Ableitungen in den Zeilen \(m\) und \(n\) verwendet wurden.
\end{itemize}
\end{definition}

\subsubsection{Einführung der Negation}
\label{rule:CI}

\begin{definition}[Einführungsregel der Negation]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    m & (m) & P & \rA \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    m,j & (n) & \bot & \dots \\
\end{array}
\]

Die Einführungsregel \(\neg I\) erlaubt die Ableitung von \(\neg P\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    m & (k) & \neg P & \rCI{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < n < k\), wobei \(m\) die Zeile ist, in der \(P\) angenommen wurde, und \(n\) die Zeile, in der ein Widerspruch \(\bot\) abgeleitet wurde.
    \item Die Menge der Annahmen \(j\) darf die Annahme aus Zeile \(m\) nicht enthalten.
\end{itemize}
\end{definition}

\subsubsection{Eliminierung der Negation}
\label{rule:CE}

\begin{definition}[Eliminierungsregel der Negation]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    m & (m) & \neg P & \rA \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    j & (n) & \bot & \dots \\
\end{array}
\]

Die Eliminierungsregel \(\neg E\) erlaubt die Ableitung von \(P\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    m, j & (k) & P & \rCE{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < n < k\), wobei \(m\) die Zeile ist, in der \(\neg P\) als Annahme definiert wurde, und \(n\) die Zeile, in der ein Widerspruch \(\bot\) festgestellt wurde.
    \item Der Index \(m\) repräsentiert die Annahme von \(\neg P\), und \(j\) gibt die Listen der Annahmen an, die für die Ableitung von \(\bot\) verwendet wurden.
\end{itemize}
\end{definition}

\subsection{Regeln für den Allquantor}

Die Allquantifikation, dargestellt durch das Symbol \(\forall\), ist ein logischer Operator, der \enquote{für alle} bedeutet. Im Kalkül des natürlichen Schließens gibt es zwei grundlegende Regeln für die Allquantifikation: die Einführungs- und die Eliminierungsregel.

\subsubsection{Einführungsreggel der  Allquantifikation}
\label{rule:UI}
\begin{definition}[Einführungsregel der Allquantifikation]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & P(x) & \dots \\
\end{array}
\]

Die Einführungsregel \(\forall I\) erlaubt die Ableitung von \(\forall x P(x)\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i & (k) & \forall x P(x) & \rUI{m} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < k\), wobei \(m\) die Zeile ist, in der \(P(x)\) abgeleitet wurde.
    \item Die Variable \(x\) darf in den Annahmen der Zeile \(m\) nicht frei vorkommen.
    \item Der Index \(i\) repräsentiert die Liste der Annahmen, die für die Ableitung von \(P(x)\) verwendet wurden. Diese Liste bleibt für die Ableitung von \(\forall x P(x)\) unverändert.
\end{itemize}
\end{definition}

\subsubsection{Eliminierungsregel der  Allquantifikation}
\label{rule:UE}
\begin{definition}[Eliminierungsregel der Allquantifikation]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & \forall x P(x) & \dots \\
\end{array}
\]

Die Eliminierungsregel \(\forall E\) erlaubt die Ableitung von \(P(t)\) in einer neuen Zeile \(k\), wobei \(t\) ein beliebiger Term ist. Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i & (k) & P(t) & \rUE{m} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < k\), wobei \(m\) die Zeile ist, in der \(\forall x P(x)\) abgeleitet wurde.
    \item Der Term \(t\) kann eine Konstante oder ein komplexer Ausdruck aus Funktionssymbolen sein.
    \item Der Index \(i\) repräsentiert die Liste der Annahmen, die für die Ableitung von \(\forall x P(x)\) verwendet wurden. Diese Liste bleibt für die Ableitung von \(P(t)\) unverändert.
\end{itemize}
\end{definition}

\subsection{Regeln für den Existenzquantor}

Der Existenzquantor, oft dargestellt durch das Symbol \(\exists\), ist ein logischer Operator, der \enquote{es existiert} bedeutet. Im Kalkül des natürlichen Schließens gibt es zwei grundlegende Regeln für den Existenzquantor: die Einführungs- und die Eliminierungsregel.

\subsubsection{Einführungsregel des Existenzquantors}
\label{rule:EI}
\begin{definition}[Einführungsregel des Existenzquantors]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & P(t) & \dots \\
\end{array}
\]

Die Einführungsregel \(\exists I\) erlaubt die Ableitung von \(\exists x P(x)\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i & (k) & \exists x P(x) & \rEI{m} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < k\), wobei \(m\) die Zeile ist, in der \(P(t)\) abgeleitet wurde.
    \item Der Term \(t\) darf eine Konstante oder ein komplexer Ausdruck aus Funktionssymbolen sein.
    \item Der Index \(i\) repräsentiert die Liste der Annahmen, die für die Ableitung von \(P(t)\) verwendet wurden. Diese Liste bleibt für die Ableitung von \(\exists x P(x)\) unverändert.
\end{itemize}
\end{definition}

\subsubsection{Eliminierungsregel des Existenzquantors}
\label{rule:EE}
\begin{definition}[Eliminierungsregel des Existenzquantors]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & \exists x P(x) & \dots \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    n & (n) & P(t) & \rA \\
\end{array}
\]

\textbf{Zeile \(p\):}
\[
\begin{array}{llll}
    i,n & (p) & Q & \dots \\
\end{array}
\]

Die Eliminierungsregel \(\exists E\) erlaubt die Ableitung von \(Q\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i,n & (k) & Q & \rEE{m,n,p} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m < n < p < k\).
    \item Der Term \(t\) ist eine neue Variable, die in den bisherigen Zeilen des Beweises nicht vorkommt.
    \item Die Aussage \(Q\) darf \(t\) nicht enthalten.
    \item Weder die Liste \(i\) der Annahmen der Zeile \(m\) noch der Index \(n\) der Annahme der Zeile \(n\) dürfen die Variable \(t\) enthalten.
    \item Die Indizes \(i\) und \(n\) repräsentieren:
    \begin{itemize}
        \item \(i\) ist die Liste der Annahmen, die zur Ableitung von \(\exists x P(x)\) in Zeile \(m\) verwendet wurden.
        \item \(n\) ist der Index der Annahme, die in Zeile \(n\) getroffen wurde.
    \end{itemize}
\end{itemize}
\end{definition}

\subsection{Regeln für das Identitätssymbol}


Das Identitätssymbol, oft dargestellt durch das Symbol \(=\), wird in der Prädikaten-logik verwendet, um die Gleichheit von Termen auszudrücken. Es stellt sicher, dass zwei Terme, die durch das Identitätssymbol verbunden sind, als dasselbe Objekt behandelt werden können. Im Kalkül des natürlichen Schließens gibt es zwei grundlegende Regeln für das Identitätssymbol: die Einführungs- und die Eliminierungsregel.

\subsubsection{Einführungsregel für das Identitätssymbol}
\label{rule:II} 
\begin{definition}[Einführungsregel für das Identitätssymbol]
Die Einführungs-regel \(=I\) besagt, dass für jeden Term \(t\) die Aussage \(t = t\) wahr ist, da jedes Objekt mit sich selbst identisch ist. Dies wird wie folgt notiert:
\[
\begin{array}{lll}
    (m) & t = t & \rII \\
\end{array}
\]
Hierbei steht \(m\) für einen allgemeinen Zeilenindex.
\end{definition}

\subsubsection{Eliminierungsregel für das Identitätssymbol}
\label{rule:IE}
\begin{definition}[Eliminierungsregel für das Identitätssymbol]
Seien die Zeilen einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & t = u & \dots \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    j & (n) & P(t) & \dots \\
\end{array}
\]

Die Eliminierungsregel \(=E\) erlaubt die Ableitung von \(P(u)\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i,j & (k) & P(u) & \rIE{m,n} \\
\end{array}
\]


analoge Formulierung

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
    i & (m) & u = t & \dots \\
\end{array}
\]

\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
    j & (n) & P(t) & \dots \\
\end{array}
\]

Die Eliminierungsregel \(=E\) erlaubt die Ableitung von \(P(u)\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
    i,j & (k) & P(u) & \rIE{m,n} \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m, n < k\), wobei \(m\) die Zeile ist, in der \(t = u\) abgeleitet wurde, und \(n\) die Zeile, in der \(P(t)\) festgestellt wurde.
    \item Der Term \(t\) wird durch \(u\) ersetzt, wenn \(t = u\) gilt.
    \item Die Indizes \(i,j\) repräsentieren die Listen der Annahmen, die für die Ableitung von \(t = u\) und \(P(t)\) verwendet wurden. Diese Listen bleiben unverändert.
\end{itemize}
\end{definition}

\subsection{Regeln von Definitionen}

\subsubsection{Explizite Definition}
Wir betrachten den allgemeinen Fall, dass ein Symbol \(Q(x_1,\dots,x_n)\) explizit durch einen Ausdruck \(\varphi(x_1,\dots,x_n)\) definiert wird:

\begin{definition}[\(Q\) (explizit)]
\[
Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n)
\]    
\end{definition}

Hierbei ist \(Q(x_1,\dots,x_n)\) das neu eingeführte Symbol (Definiendum) und \(\varphi(x_1,\dots,x_n)\) der definierende Ausdruck (Definiens).

\paragraph{Eliminierungsregel für explizite Definitionen}
Sei die Zeile einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & Q(x_1,\dots,x_n) & \dots \\
\end{array}
\]

Die Eliminierungsregel erlaubt die Ableitung des definierenden Ausdrucks \(\varphi(x_1,\dots,x_n)\) in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
   i& (k) & \varphi(x_1,\dots,x_n) & ... \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m\) verweist auf die Zeile, in der \(Q(x_1,\dots,x_n)\) eingeführt wurde.
    \item Der Index \(i\) repräsentiert eine Liste von der Annahmen.
\end{itemize}

\paragraph{Einführungsregel für explizite Definitionen}
Sei die Zeile einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i& (m) & \varphi(x_1,\dots,x_n) & \dots \\
\end{array}
\]

Die Einführungsregel erlaubt die Ableitung des definierten Symbols 
\[
Q(x_1,\dots,x_n)
\] 
in einer neuen Zeile \(k\). Dies wird wie folgt notiert:
\[
\begin{array}{llll}
   i& (k) & Q(x_1,\dots,x_n) & ... \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \(m\) verweist auf die Zeile, in der \(\varphi(x_1,\dots,x_n)\) eingeführt wurde.
    \item Der Index \(i\) repräsentiert eine Liste von der Annahmen.
\end{itemize}

\subsubsection{Partielle Definition}
Wir betrachten nun den Fall einer \emph{partiellen Definition}, bei der ein neues Symbol \(Q(x_1,\dots,x_n)\) nur dann durch den Ausdruck \(\varphi(x_1,\dots,x_n)\) festgelegt wird, wenn eine Bedingung \(C(x_1,\dots,x_n)\) erfüllt ist. Formal:

\begin{definition}[\(Q\) (partiell)]
\label{CLpxSubOnewDotswxSubnRpToQLpxSubOnewDotswxSubnRpDefEqVarphiLpxSubOnewDotswxSubnRp}
\[
C(x_1,\dots,x_n)\rightarrow Q(x_1,\dots,x_n) \coloneqq \varphi(x_1,\dots,x_n)
\]
\end{definition}

Hierbei ist 
\begin{itemize}
    \item \(Q(x_1,\dots,x_n)\) das \emph{neu} eingeführte Symbol (\emph{Definiendum}), 
    \item \(\varphi(x_1,\dots,x_n)\) der bereits bekannte Ausdruck (\emph{Definiens}),
    \item \(C(x_1,\dots,x_n)\) die Bedingung, unter der die Definition gilt.
\end{itemize}

\paragraph{Eliminierungsregel für partielle Definitionen}
Wenn in einer Beweistabelle zwei Zeilen wie folgt vorliegen:

\[
\textbf{Zeile }m: 
\quad
\begin{array}{llll}
   i & (m) & Q(x_1,\dots,x_n) & \dots \\
\end{array}
\]

\[
\textbf{Zeile }n:
\quad
\begin{array}{llll}
   j & (n) & C(x_1,\dots,x_n) & \dots \\
\end{array}
\]

dann darf in einer neuen Zeile \(k\) \emph{(Elimination)} der definierende Ausdruck \(\varphi(x_1,\dots,x_n)\) abgeleitet werden. Wir notieren dies:

\[
\textbf{Zeile }k: 
\quad
\begin{array}{llll}
   i,j & (k) & \varphi(x_1,\dots,x_n) & \text{(part. Def.)}_{m,n} \\
\end{array}
\]

\paragraph{Einführungsregel für partielle Definitionen}
Analog dazu darf man in einer neuen Zeile \(k\) \emph{(Einf\"uhrung)} das definierte Symbol \(Q(x_1,\dots,x_n)\) ableiten, wenn man bereits \(\varphi(x_1,\dots,x_n)\) \emph{und} \(C(x_1,\dots,x_n)\) hergeleitet hat. Das hei\ss t, liegen folgende Zeilen vor:

\[
\textbf{Zeile }m: 
\quad
\begin{array}{llll}
   i & (m) & \varphi(x_1,\dots,x_n) & \dots \\
\end{array}
\]

\[
\textbf{Zeile }n: 
\quad
\begin{array}{llll}
   j & (n) & C(x_1,\dots,x_n) & \dots \\
\end{array}
\]

so kann in Zeile \(k\) gefolgert werden:

\[
\textbf{Zeile }k: 
\quad
\begin{array}{llll}
   i,j & (k) & Q(x_1,\dots,x_n) & \text{(part. Def.)}_{m,n} \\
\end{array}
\]

Dabei verweisen die Indizes \(m,n\) auf die Zeilen, in denen \(Q(x_1,\dots,x_n)\) bzw. \(\varphi(x_1,\dots,x_n)\) und \(C(x_1,\dots,x_n)\) abgeleitet wurden, während \(i,j\) für die jeweiligen Annahmelisten stehen.

\subsubsection{Rekursive Definition}
Wir betrachten den allgemeinen Fall, dass ein Symbol \(\sigma(x_1,\dots,x_n)\) rekursiv durch Basisfälle und eine Rekursionsvorschrift definiert wird:

\begin{definition}[\(\sigma\) (rekursiv)]
\begin{itemize}
    \item \textbf{Basisfall:}
    \[
    \sigma(a_1, \ldots, a_k) \coloneqq b,
    \]
    wobei \(a_1, \ldots, a_k\) konkrete Werte und \(b\) ein bereits bekannter Ausdruck sind.
    \item \textbf{Rekursionsvorschrift:}
    \[
    \sigma(x_1, \ldots, x_n) \coloneqq f\big(\sigma(y_1, \ldots, y_m), z_1, \ldots, z_p\big),
    \]
    wobei \(y_1, \ldots, y_m\) Teilmengen von \(x_1, \ldots, x_n\) und \(f\) wohldefinierte Funktionen sind.
\end{itemize}
\end{definition}

\paragraph{Eliminierungsregel für den Basisfall}
Sei die Zeile einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & \sigma(x_1, \ldots, x_n) & \dots \\
\end{array}
\]

Falls die Argumente von \(\sigma(x_1, \ldots, x_n)\) einem Basisfall entsprechen, kann der entsprechende Wert \(b\) abgeleitet werden. Dies wird wie folgt notiert:
\[
\begin{array}{llll}
   i & (k) & b & ... \\
\end{array}
\]

\paragraph{Eliminierungsregel für die Rekursionsvorschrift}
Sei die Zeile einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & \sigma(x_1, \ldots, x_n) & \dots \\
\end{array}
\]

Falls die Argumente von \(\sigma(x_1, \ldots, x_n)\) der Rekursionsvorschrift entsprechen, kann der entsprechende Ausdruck abgeleitet werden. Dies wird wie folgt notiert:
\[
\begin{array}{llll}
   i & (k) & f\big(\sigma(y_1, \ldots, y_m), z_1, \ldots, z_p\big) & ... \\
\end{array}
\]

\paragraph{Einführungsregel für den Basisfall}
Sei die Zeile einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & b & \dots \\
\end{array}
\]

Falls der Ausdruck \(b\) gegeben ist, kann das definierte Symbol \(\sigma(a_1, \ldots, a_k)\) abgeleitet werden. Dies wird wie folgt notiert:
\[
\begin{array}{llll}
   i & (k) & \sigma(a_1, \ldots, a_k) & ... \\
\end{array}
\]

\paragraph{Einführungsregel für die Rekursionsvorschrift}
Sei die Zeile einer Beweistabelle wie folgt definiert:

\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & f\big(\sigma(y_1, \ldots, y_m), z_1, \ldots, z_p\big) & \dots \\
\end{array}
\]

Falls der Ausdruck \(f\big(\sigma(y_1, \ldots, y_m), z_1, \ldots, z_p\big)\) gegeben ist, kann das definierte Symbol \(\sigma(x_1, \ldots, x_n)\) abgeleitet werden. Dies wird wie folgt notiert:
\[
\begin{array}{llll}
   i & (k) & \sigma(x_1, \ldots, x_n) & ... \\
\end{array}
\]

\paragraph{Zusatzregel: Vereinfachung der Rekursion}
Um die Übersichtlichkeit in Beweisen zu gewährleisten, können einzelne Zwischenschritte rekursiver Ableitungen ausgelassen werden. Dabei wird die Äquivalenz zwischen dem Endergebnis einer rekursiven Ableitung und der vollständigen Folge aller Zwischenschritte vorausgesetzt. Formal:
\[
\sigma(x_1, \ldots, x_n) \leftrightarrow
\left\{
\begin{alignedat}{2}
  & b && \quad \text{\makecell[l]{(nach endlicher Anwendung \\ der Rekursion)}}\\
  & \sigma(y_1, \ldots, y_m) && \quad \text{\makecell[l]{(Zwischenschritt \\ der Rekursion)}}\\
  & f\!\bigl(\sigma(y_1, \ldots, y_m),\, z_1, \ldots, z_p\bigr)
  && \quad \text{\makecell[l]{(Rekursionsschritt)}}
\end{alignedat}
\right.
\]
Zwischenschritte können jedoch bei Bedarf in die Beweistabelle eingefügt werden, um den Nachvollzug zu erleichtern.


\subsubsection{Implizite Definition}
Wir betrachten nun den Fall, dass ein \emph{neues} Symbol \(\sigma\) nicht \emph{direkt} (explizit) durch eine Gleichung eingeführt wird, sondern \emph{implizit} über bestimmte Axiome bzw. Eigenschaften, die \(\sigma\) erfüllen soll. Formal sprechen wir auch von einem \textbf{Axiomatisierungsverfahren} oder einer \textbf{impliziten Definition} \(\Phi(\sigma)\).

\begin{definition}[\(\sigma\) (implizit)]
\label{dfSigmaGenImplicitAxiom}
Sei \(\sigma\) ein neues Symbol (z.\,B. ein Prädikat, eine Konstante, ein Funktionssymbol oder ein Operatorsymbol), das in der formalen Sprache \(\mathcal{L}\) bisher nicht vorkam. Weiter sei
\[
\Phi(\sigma) \;=\; \{\phi_1(\sigma), \phi_2(\sigma), \dots\}
\]
eine Menge von Axiomen oder Aussagen, die \(\sigma\) charakterisieren. Dann nennen wir die Forderung, dass alle \(\phi_i(\sigma)\) in unserem Theoriekontext \(\mathcal{T}\) gelten,
\[
\forall i \in I:\quad \phi_i(\sigma) \quad \text{(für eine Indexmenge }I\text{)},
\]
eine \textbf{implizite Definition} von \(\sigma\).
\end{definition}

\paragraph{Anmerkung zum Gebrauch im Beweissystem}
Eine implizite Definition kann in \emph{vielen} Fällen nicht direkt in einer einzelnen Zeile der Beweistabelle stehen. Stattdessen wird das Symbol \(\sigma\) bereits \emph{vor} oder \emph{zum} Beginn eines formalen Beweises (oder ganz zu Anfang eines Abschnitts) \emph{vorausgesetzt}. 

Eine Beispielformulierung dafür könnte lauten:
\[
\text{\glqq Sei }\sigma\text{ ein Symbol, das die Axiome }\Phi(\sigma)\text{ erfüllt.\grqq}
\]

\paragraph{Regel (Implizite Definition)}
Liegt eine Aussage \(\phi_i(\sigma)\) in der Menge \(\Phi(\sigma)\) vor, so kann sie als gegeben angenommen werden und in einer neuen Zeile der Beweistabelle wie folgt notiert werden:

\textbf{Zeile }k:
\[
\begin{array}{llll}
   \ & (k) & \phi_i(\sigma) & ... \\
\end{array}
\]
\emph{Beachte:} Hierbei wird keine spezifische Ableitung durchgeführt, sondern \(\phi_i(\sigma)\) wird direkt als Axiom eingeführt.

\paragraph{Alternative Darstellung (Axiome als Schlussregeln)}
Axiome können in formalen Kalkülen des natürlichen Schließens oft in Form von Inferenzregeln formuliert werden, um die Anwendbarkeit in Beweisen zu erleichtern. Im Gegensatz zu „freien“ Axiomen, die ohne Prämissen gelten, können solche axiomatischen Regeln Abhängigkeiten (Annahmen) aufweisen, die in einem Beweis erfüllt sein müssen, bevor das Axiom angewendet werden kann.

\begin{definition}[Axiom-Nutzungsregel]
\label{dfSigmaGenImplicitRule}
Sei \(\Phi\) ein Axiom, das in einer formalen Sprache \(\mathcal{L}\) definiert ist und eine Aussage der Form 
\[
\Gamma \vdash \Delta
\]
besitzt, wobei \(\Gamma\) eine Menge von Prämissen und \(\Delta\) eine Konklusion ist. Die Axiom-Nutzungsregel erlaubt es, \(\Phi\) in einem Beweis wie folgt zu verwenden:

\paragraph{Annahmen}
\textbf{Zeile \(m_1\):}
\[
\begin{array}{llll}
   i_1& (m_1) & A_1 & \dots \\
\end{array}
\]

\textbf{Zeile \(m_2\):}
\[
\begin{array}{llll}
   i_2& (m_2) & A_2 & \dots \\
\end{array}
\]

\vdots

\textbf{Zeile \(m_k\):}
\[
\begin{array}{llll}
   i_k& (m_k) & A_k & \dots \\
\end{array}
\]

\paragraph{Schluss}
\[
\begin{array}{llll}
   i_1, i_2, \ldots, i_k & (n) & \Delta & ... \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \( \Gamma \) besteht aus den \( k \) Elementen \( \{A_1, A_2, \ldots, A_k\} \), die in separaten Zeilen dargestellt werden.
    \item \( m_1, m_2, \ldots, m_k \) sind die Zeilennummern, in denen die Prämissen \( \Gamma \) des Axioms \(\Phi\) erfüllt wurden.
    \item \( i_1, i_2, \ldots, i_k \) sind die Annahmen, von denen die Prämissen \( \Gamma \) abhängen.
    \item \( \Delta \) ist die Konklusion des Axioms \(\Phi\), die in der aktuellen Zeile \( n \) abgeleitet wird.
    \item \( n > m_k \) für alle \( k \), d. h. die Zeilennummer \( n \) der Konklusion ist größer als die Zeilennummern \( m_1, m_2, \ldots, m_k \) aller Annahmen.
\end{itemize}
\end{definition}

\begin{remark}
Die Axiom-Nutzungsregel betont die Anwendbarkeit von Axiomen in Beweisen, insbesondere wenn sie explizit Prämissen (\(\Gamma\)) voraussetzen. Solche Prämissen definieren den Kontext, in dem die Aussage des Axioms (\(\Delta\)) gültig ist. Diese Darstellung ist besonders hilfreich, wenn Axiome Äquivalenzen oder Bedingungen enthalten, die in spezifischen Situationen überprüft werden müssen.
\end{remark}


\subsubsection{Regel zur Iota-Definition}

Im Unterschied zu einer \emph{expliziten} oder \emph{impliziten} Definition wird die \(\iota\)-Konstante \(\sigma\) nicht erst \emph{im} Beweis selbst eingeführt, sondern bereits \emph{außerhalb} (meta-logisch) durch
\begin{definition}[\(\sigma\)]
\label{dfSigmaGenIota}
\[
\sigma \;\coloneqq\; \iota x \, P(x).
\]
\end{definition}
Dies setzt voraus, dass \(\exists!\,x\,P(x)\) (es existiert genau \emph{ein} \(x\), für das \(P(x)\) gilt). 

\paragraph{Iota-Regel (Schluss auf \(P(\sigma)\))}
Sobald die Konstante \(\sigma\) \textbf{durch Definition} als \(\sigma := \iota x \, P(x)\) feststeht, kann in der Beweistabelle direkt \(P(\sigma)\) notiert werden. Man benötigt dafür keine gesonderte Einführungs- oder Eliminierungszeile (\(\sigma\) steht ja bereits \emph{ausserhalb} des Beweises fest). 

Dies lässt sich als \emph{eine} Regel formulieren:
\[
\begin{array}{llll}
   & (k) & P(\sigma) & ... \\
\end{array}
\]



\subsection{Regeln zur Nutzung von Theoremen}
\label{rule:TheoremUsage}

Im Kalkül des natürlichen Schließens ist es oft nützlich, bereits bewiesene Theoreme in weiteren Beweisen zu verwenden. Um dies systematisch zu ermöglichen, führen wir die \textbf{Theorem-Nutzungsregel} ein. Diese Regel erlaubt es, ein zuvor bewiesenes Theorem als eine zusätzliche Inferenzregel in einem Beweis zu verwenden.

\begin{definition}[Theorem-Nutzungsregel]
\label{theoremUsageRule}
Sei \( T \) ein bewiesenes Theorem, das eine Aussage der Form \( \Gamma \vdash \Delta \) hat, wobei \( \Gamma \) eine Menge von Prämissen und \( \Delta \) eine Konklusion ist. Die Theorem-Nutzungsregel erlaubt es, \( T \) in einem Beweis wie folgt zu verwenden:

\paragraph{Annahmen}
\textbf{Zeile \(m_1\):}
\[
\begin{array}{llll}
   i_1& (m_1) & A_1 & \dots \\
\end{array}
\]

\textbf{Zeile \(m_2\):}
\[
\begin{array}{llll}
   i_2& (m_2) & A_2 & \dots \\
\end{array}
\]

\vdots

\textbf{Zeile \(m_k\):}
\[
\begin{array}{llll}
   i_k& (m_k) & A_k & \dots \\
\end{array}
\]

\paragraph{Schluss}
\[
\begin{array}{llll}
   i_1, i_2, \ldots, i_k & (n) & \Delta & ... \\
\end{array}
\]

Hierbei gilt:
\begin{itemize}
    \item \( \Gamma \) besteht aus den \( k \) Elementen \( \{A_1, A_2, \ldots, A_k\} \), die in separaten Zeilen dargestellt werden.
    \item \( m_1, m_2, \ldots, m_k \) sind die Zeilennummern, in denen die Prämissen \( \Gamma \) des Theorems \( T \) abgeleitet wurden.
    \item \( i_1, i_2, \ldots, i_k \) sind die Annahmen, von denen die Prämissen \( \Gamma \) abhängen.
    \item \( \Delta \) ist die Konklusion des Theorems \( T \), die in der aktuellen Zeile \( n \) abgeleitet wird.
    \item \( n > m_k \) für alle \( k \), d. h. die Zeilennummer \( n \) der Konklusion ist größer als die Zeilennummern \( m_1, m_2, \ldots, m_k \) aller Annahmen.
\end{itemize}
\end{definition}

\begin{remark}
Die Theorem-Nutzungsregel ermöglicht es, komplexe Schlussfolgerungen modular zu behandeln, indem man sie in kleinere, bereits bewiesene Teile zerlegt. Dies fördert die Wiederverwendbarkeit von Beweisen und erhöht die Übersichtlichkeit und Struktur der Beweistabelle.
\end{remark}


\begin{remark}[Alternative Darstellungen von Argumenten]
\quad
\begin{enumerate}
    \item \textbf{Argumente der Form \(\psi \dashv\vdash \phi\)}\\
    Handelt es sich um eine wechselseitige Ableitbarkeit \(\psi \dashv\vdash \phi\), so kann man sie in einer Beweiszeile auch als \(\psi \leftrightarrow \phi\) einführen. Dieser Schritt macht auf einer einzigen Zeile klar, dass \(\psi\) und \(\phi\) logisch äquivalent sind. Je nach Bedarf kann man die eine oder andere Richtung \(\psi \vdash \phi\) bzw.\ \(\phi \vdash \psi\) auch als einzelne Regel aus dieser Äquivalenz verwenden.  Dabei ist es unerheblich, ob man die Formulierung \(\psi \leftrightarrow \phi\) oder \(\phi \leftrightarrow \psi\) wählt – beide drücken die gleiche Äquivalenz aus.

    \item \textbf{Argumente der Form \(\Gamma \vdash \phi\)}\\
    Besteht \(\Gamma\) aus den Prämissen \(\{\psi_1,\ldots,\psi_n\}\), kann man \(\Gamma \vdash \phi\) in einer Beweiszeile auch in der Form 
    \[
    \psi_1 \land \dots \land \psi_n \;\rightarrow\;\phi
    \]
    interpretieren.  
    Falls einige \(\psi_i\) bereits in vorhergehenden Zeilen abgeleitet wurden oder als Metaprämissen (d.\,h.\ im Fließtext des Beweises) feststehen, dürfen diese \(\psi_i\) aus der Konjunktionskette herausgelöst werden. In der Beweistabelle wird dann nur noch eine (eventuell kleinere) Teilkonjunktion notiert, während alle als bekannt (oder zuvor bewiesen) geltenden \(\psi_i\) direkt bei der Regelbezeichnung des Theorems als \textbf{Prämissen} aufgeführt werden.
\end{enumerate}
\end{remark}

\section{Verkettungen}

\subsection{Allgemeine Formulierung der verketteten Regelanwendung}
In den bisherigen Kapiteln haben wir eine Vielzahl von Inferenzregeln eingeführt, die jeweils genau \emph{einen} logischen Schritt ausführen. In der praktischen Beweisführung ist es jedoch oft wünschenswert, mehrere dieser Regeln \emph{hintereinander} in einem einzigen Schluss anzuwenden, um den Beweisfluss kompakter und übersichtlicher zu gestalten. Dieses Vorgehen wird im Folgenden als \emph{verkettete Regelanwendung} bezeichnet.

\begin{definition}[Verkettete Regelanwendung]
Sei eine Zeile \((m)\) einer Beweistabelle gegeben, in der bereits eine Aussage \(P\) steht. Angenommen, es existiere eine endliche Folge von Regeln \(R_1, R_2, \dots, R_k\), so dass man durch \emph{hintereinandergeschaltete Anwendung} dieser Regeln auf \(P\) eine Aussage \(Q\) gewinnt.

\paragraph{Annahmen}
\textbf{Zeile \(m\):}
\[
\begin{array}{llll}
   i & (m) & P & \dots \\
\end{array}
\]

\paragraph{Schluss}
\textbf{Zeile \(n\):}
\[
\begin{array}{llll}
   i & (n) & Q & R_1R_2\cdots R_k(m) \\
\end{array}
\]
oder präziser, falls Platz vorhanden ist:
\[
\begin{array}{llll}
   i 
   & (n) 
   & Q 
   & R_1 \,\circ\, R_2 \,\circ\,\cdots\,\circ\, R_k \;(m) \\
\end{array}
\]
Hierbei bedeutet \(R_1 \circ R_2 \circ \dots \circ R_k\), dass zuerst \(R_1\) auf Zeile \(m\) angewendet wird, dann \(R_2\) auf das \emph{Ergebnis} von \(R_1\) usw.
\end{definition}

\begin{remark}
Die verkettete Regelanwendung ist \emph{keine} neue logische Regel im Sinne eines Axioms oder einer Erweiterung des Kalküls, sondern eine reine \emph{Abkürzungsnotation}. Sie ändert nicht die \emph{Inhalte} eines Beweises, sondern \emph{lediglich} die Darstellung und Zusammenfassung mehrerer Einzelschritte in einer kompakten Zeile.
\end{remark}

\subsection{Kettennotation}
\begin{definition}[Verallgemeinerte Transitivität zweier Symbole \(\sigma_1\) und \(\sigma_2\)]
\label{rule:Chain}
Seien \(\sigma_1,\sigma_2\) zwei binäre Symbole, die in einer Domäne \(D\) definiert sind.  
Wenn gezeigt wurde, dass für alle \(x,y,z \text{ aus } D\) gilt:
\[
\bigl(x \;\sigma_1\; y, \quad y \;\sigma_2\; z\bigr)
\quad\vdash\quad
x \;\sigma_1\; z,
\]
dann sind \(\sigma_1\) und \(\sigma_2\) \emph{(rechts-)verträglich} im Sinne einer verallgemeinerten Transitivität. Aus dieser Eigenschaft resultiert, dass man \(\sigma_1\) und \(\sigma_2\) in einer \emph{Kette} zusammensetzen kann, um in einem Schritt vom Anfangs\- zum End-Objekt zu schließen.
\end{definition}

\noindent
\textbf{Ergänzung (mehrere Operatoren).}  
Seien nun \(\sigma_1, \sigma_2, \dots, \sigma_o\) verschiedene binäre Symbole (Operatoren oder Relationen), für die alle passenden Transitivitätsaussagen dieser Art vorliegen. Insbesondere gelte für jedes \(i\in\{1,\ldots,o\}\):
\[
\bigl(x \;\sigma_1\; y \quad\land\quad y \;\sigma_i\; z\bigr)
\;\vdash\;
x \;\sigma_1\; z.
\]
Damit können wir nun aus einer ganzen Kettenfolge
\[
x_1 \;\sigma_{k_1}\; x_2,\quad
x_2 \;\sigma_{k_2}\; x_3,\quad
\dots,\quad
x_n \;\sigma_{k_n}\; x_{n+1}
\]
in einem \emph{abkürzenden} Schritt folgern, dass
\[
x_1 \;\sigma_1\; x_{n+1}
\]
gilt, sofern jeder Übergang durch die obigen Verträglichkeits- beziehungsweise Transitivitätseigenschaften gerechtfertigt ist.

\begin{remark}[Kettenregel \rChain{}]
Um diese verkettete Anwendung auch in einer Beweistabelle übersichtlich darzustellen, können wir eine Regel \(\rChain{}\) einführen. Sie verknüpft die Zeilen \(m_1,\dots,m_n\) des Beweises zu einem einzigen Schluss. 
\end{remark}

\noindent
\textbf{Formale Darstellung in der Beweistabelle}:  
Angenommen, wir haben folgende \(n\) Zeilen, in denen jeweils \(\sigma_{k_i}\) bereits abgeleitet wurde:

    \[
	\begin{array}{llclll}
            \multicolumn{6}{l}{\textbf{Zeile } m \text{:}}\\
             i_1 &  (m)  & \multicolumn{3}{l}{x_1\sigma_{k_1} x_2} & \dots \\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+1 \text{:}}\\
             i_2 &  (m+1)  & \multicolumn{3}{l}{x_2\sigma_{k_2} x_3} & \dots \\
            \multicolumn{6}{c}{}\\
            \multicolumn{6}{c}{\vdots}\\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+(n-1) \text{:}}\\
             i_n &  (m+(n-1))  & \multicolumn{3}{l}{x_n\sigma_{k_n} x_{n+1}} & \dots \\   
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+n \text{:}}\\
             i_1,i_2,\dots,i_n &  (m+n)  & \multicolumn{3}{l}{x_1\sigma_{k_1} x_{n+1}} & \rChain{m_1,m_n} 
        \end{array}
    \]

Dann soll in einer \emph{neuen} Zeile \(m_{n+1}\) durch Anwendung von \(\rChain\{m_1,\dots,m_n\}\) abgekürzt folgen:
\[
i_1,\dots,i_n \,(m_{n+1})\colon
\quad
x_1 \;\sigma_1\; x_{n+1}.
\]

Hierbei sind \(\boldsymbol{i_1, \dots, i_n}\) die Annahmelisten, welche die offenen Annahmen bezeichnen, von denen jede Zeile abhängt. 


\noindent
\textbf{Abkürzende Notation}:  
Manchmal werden die Zwischenschritte nur angedeutet, also ab Zeile \(m_2\) lediglich das \(\sigma_{k_2}\) und das Objekt \(x_3\) notiert:

    \[
	\begin{array}{llclll}
            \multicolumn{6}{l}{\textbf{Zeile } m \text{:}}\\
             i_1 &  (m)  & x_1&\sigma_{k_1}& x_2 & \dots \\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+1 \text{:}}\\
             i_2 &  (m+1)  &  &\sigma_{k_2}& x_3 & \dots \\
            \multicolumn{6}{c}{}\\
            \multicolumn{6}{c}{\vdots}\\
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m_n \text{:}}\\
             i_n &  (m_n)  & &\sigma_{k_n}&x_{n+1} & \dots \\   
            \multicolumn{6}{l}{}\\
            \multicolumn{6}{l}{\textbf{Zeile } m+n \text{:}}\\
             i_1,i_2,\dots,i_n &  (m+n)  & x_1&\sigma_{k_1}& x_{n+1} & \rChain{m_1,m_n} 
        \end{array}
    \]
    
\begin{remark}[Geordnete Operatorenmengen und erweiterte Kettennotation]
In manchen Beweissituationen treten mehrere binäre Operatoren \(\sigma_1, \dots, \sigma_n\) auf, die durch eine Kette verbunden werden können (z.\,B.\ \(\sigma_1 = \to\) und \(\sigma_2 = \leftrightarrow\)) und für die jeweils die passende \emph{rechts-Verträglichkeit} nachgewiesen wurde. Um festzulegen, \emph{welcher} dieser Operatoren im letzten Schritt maßgebend ist, notieren wir sie als geordnetes \(n\)-Tupel:
\[
\boldsymbol{\Theta} = (\sigma_1, \sigma_2, \ldots, \sigma_n),
\]
wobei \(\sigma_1\) vorrangig für den finalen Schluss verwendet wird, sofern alle nötigen Verträglichkeitsnachweise \(\sigma_1\)-\(\sigma_j\) vorliegen. Dies ermöglicht eine klare Priorisierung und eine einheitliche Referenz, ohne bei jeder Mischkette erneut angeben zu müssen, welcher Operator \(\sigma_i\) im Endschluss \(\sigma_1\) \textbf{dominiert}.

\smallskip

\textbf{Symmetrische Operatoren:} Falls zusätzlich ein Operator \(\sigma\) \emph{symmetrisch} ist (d.\,h.\ \(x \,\sigma\, y \vdash y \,\sigma\, x\)), kann man in einer Kettennotation stillschweigend die Reihenfolge der Operanden vertauschen, ohne jedes Mal explizit auf die Symmetrie-Eigenschaft verweisen zu müssen. In der Tupeldarstellung \(\boldsymbol{\Theta}\) kann dies beispielsweise durch ein kleines Symbol oder einen Index \(\sigma^*\) angedeutet werden, um zu verdeutlichen, dass \(\sigma\) in beide Richtungen anwendbar ist.
\end{remark}

\subsection{Kompakte Notation für Inferenzregeln}

Um die Einführung neuer Inferenzregeln zu vereinfachen und die Übersichtlichkeit zu erhöhen, verwenden wir im Folgenden eine standardisierte, in der mathematischen Logik übliche Darstellungsweise. Dabei werden die Prämissen über einem horizontalen Strich aufgelistet, und die sich daraus ergebende Konklusion darunter geschrieben. Der Name der Regel wird rechts oder links daneben angegeben. 

\subsubsection{Allgemeine Form einer Inferenzregel}
Eine Inferenzregel hat typischerweise die Form
\[
\frac{P_1 \quad P_2 \quad \dots \quad P_n}{Q}
\quad
\text{(Regelname)},
\]
wobei
\begin{itemize}
    \item $P_1, \dots, P_n$ die \emph{Prämissen} (Voraussetzungen) der Regel sind,
    \item $Q$ die \emph{Konklusion} (abgeleitete Aussage) ist,
    \item \textit{Regelname} den Namen der verwendeten Regel angibt.
\end{itemize}
Zusätzlich können \emph{Nebenbedingungen} gelten (z.\,B.\ ob eine Variable nicht in bestimmten Annahmen frei sein darf). Diese werden meist gesondert formuliert.

In manchen Regeln wird eine temporäre Annahme gemacht, um eine Aussage abzuleiten oder einen Widerspruch zu zeigen. Die allgemeine Darstellung dafür lautet:
\[
\frac{
\begin{array}{c}
\text{[P]}_1\quad\text{[P]}_2\quad\hdots \quad\text{[P]}_n \\
\vdots \\
R
\end{array}
}{Q}
\]
\emph{Nebenbedingung:} Die Annahmen $P_1,\hdots, P_n$ werden \emph{aufgehoben} (geschlossen). Das heißt, $P$ darf in der Schlusszeile nicht mehr als offene Annahme vorkommen.
Weiter gilt:
\begin{itemize}
    \item \textbf{$[P]$}: $P$ wird vorübergehend als Annahme eingeführt.
    \item \textbf{$\vdots$}: Dies symbolisiert mehrere logische Schritte, die aus der Annahme $P$ gefolgert werden.
    \item \textbf{$R$}: Die Ableitung einer Aussage (z.\,B. ein Widerspruch $\bot$ oder eine Konklusion).
    \item \textbf{$Q$}: Das abschließende Resultat der Regel, nachdem die Annahme aufgehoben wurde.
\end{itemize}
Diese Notation ist in der Literatur weit verbreitet und bildet die Grundlage für das Kalkül des natürlichen Schließens. Ein konkreter Beispielfall wird im Verlauf des Abschnitts vorgestellt.

\subsubsection{Beispiele bereits bekannter Regeln}

\paragraph{Konjunktionseinführung ($\land I$)} 
\[
\frac{P \quad Q}{P \land Q}
\quad \land I
\]

\paragraph{Konjunktionseliminierung ($\land E1$, $\land E2$)} 
\[
\frac{P \land Q}{P}
\quad \land E1
\quad\quad
\frac{P \land Q}{Q}
\quad \land E2
\]

\paragraph{Disjunktionseinführung ($\lor I$)}
\[
\frac{P}{P \lor Q}
\quad \lor I1
\quad\quad
\frac{Q}{P \lor Q}
\quad \lor I2
\]

\paragraph{Disjunktionseliminierung ($\lor E$)}
\[
\frac{
P \lor Q 
\quad
\begin{array}{c}
[P]\\
\vdots\\
R
\end{array}
\quad
\begin{array}{c}
[Q]\\
\vdots\\
R
\end{array}
}{R}
\quad \lor E
\]

\paragraph{Implikationseinführung ($\to I$)}
\[
\frac{
\begin{array}{c}
\text{[P]} \\
\vdots \\
Q
\end{array}
}{P \rightarrow Q}
\quad \to I
\]


\paragraph{Implikationelimierung ($\to E$)}
\[
\frac{P \quad P \to Q}{Q}
\quad \to E
\]

\paragraph{Negationseinführung ($\neg I$)}
\[
\frac{
\begin{array}{c}
\text{[P]} \\
\vdots \\
\bot
\end{array}
}{\neg P}
\quad \neg I
\]

\paragraph{Negationelimierung ($\neg E$)}
\[
\frac{
\begin{array}{c}
\text{[\ensuremath{\neg P}]} \\
\vdots \\
\bot
\end{array}
}{P}
\quad \neg I
\]

\subsubsection{Regeln für Allquantor ($\forall$) und Existenzquantor ($\exists$)}

Auch für die Quantoren werden die Inferenzregeln in derselben Notation angegeben. Häufig formuliert man die \emph{Nebenbedingungen} (z.\,B.\ ob eine Variable nicht in bestimmten Annahmen frei sein darf) nur in Worten.

\paragraph{Allquantor-Einführung ($\forall I$)}
\[
\frac{P(x)}{\forall x\,P(x)}
\quad \forall I
\]
\emph{Nebenbedingung:} Die Variable $x$ darf in keinen offenen Annahmen frei vorkommen (sie muss \emph{beliebig} sein).

\paragraph{Allquantor-Eliminierung ($\forall E$)}
\[
\frac{\forall x\,P(x)}{P(t)}
\quad \forall E
\]
\emph{Nebenbedingung:} Der Term $t$ darf überall sinnvoll substituierbar sein (z.\,B.\ keine Kollisionsprobleme mit gebundenen Variablen).

\subsubsection{Ersetzungsregel der Äquivalenz ($\leftrightarrow S$)}

\[
\frac{
  \phi \leftrightarrow \psi 
  \quad
  \theta(\phi)
}{
  \theta(\psi)
}
\quad (\leftrightarrow S)
\]

und

\[
\frac{
  \phi \leftrightarrow \psi
}{
  \theta(\phi)\leftrightarrow \theta(\psi)
}
\quad (\leftrightarrow S)
\]



\paragraph{Existenzquantor-Einführung ($\exists I$)}
\[
\frac{P(t)}{\exists x\,P(x)}
\quad \exists I
\]
Hier ist $t$ ein konkreter Term, für den $P(t)$ gilt.

\paragraph{Existenzquantor-Eliminierung ($\exists E$)}
\[
\frac{
\exists x\,P(x) 
\quad
\begin{array}{c}
\text{[P(x)]}\\
\vdots \\
Q
\end{array}
}{Q}
\quad \exists E
\]
\emph{Nebenbedingung:}
\begin{itemize}
    \item Die in der Annahme verwendete Variable $x$ darf nicht bereits in anderen offenen Annahmen frei sein.
\end{itemize}





\section{Weiterführende Regeln und Definitionen}
\subsection{Die alternative Disjunktion}
\subsubsection{Definition}


Die alternative Disjunktion, oft dargestellt durch das Symbol \(\lxor\), ist ein logischer Operator, der "`entweder ... oder ..."' bedeutet. Sie unterscheidet sich von der klassischen Disjunktion (\(\lor\)), da die alternative Disjunktion impliziert, dass genau eine der beiden Aussagen wahr ist, während die andere falsch sein muss. Die alternative Disjunktion kann wie folgt definiert werden:

\begin{definition}[XOR]
\label{XOr}
\[
P \lxor Q \coloneqq (P \land \neg Q) \lor (\neg P \land Q)
\]
\end{definition}

\subsubsection{Regeln für die alternative Disjunktion}


\paragraph{Exklusive Disjunktionseinführung ($\lxor I$)}
\label{rule:XOrI1}\label{rule:XOrI2}
\[
\frac{P \land \neg Q}{P \lxor Q}
\quad \lxor I1
\quad\quad
\frac{\neg P \land Q}{P \lxor Q}
\quad \lxor I2
\]

\paragraph{Exklusive Disjunktionseliminierung ($\lxor E$)}
\label{rule:XOrE} 
\[
\frac{
  P \lxor Q
  \quad
  \begin{array}{c}
    [P]\quad   [\neg Q]\\
    \vdots \\
    R
  \end{array}
  \quad
  \begin{array}{c}
    [\neg P]\quad  [Q]\\
    \vdots \\
    R
  \end{array}
}{R}
\quad \lxor E
\]

\subsection{Der Eindeutigkeitsquantor}


Der Eindeutigkeitsquantor, oft dargestellt durch das Symbol \(\exists!\), ist ein logischer Operator, der  "`es existiert genau ein"' bedeutet. Der Eindeutigkeitsquantor kann wie folgt definiert werden:
\begin{definition}[\(\exists !\)]
\label{ExonlyonexLpPLpxRpRpLrExxLpPLpxRpAndFayLpPLpyRpToxEqualsyRpRp}
\[
\exists! x(P(x)) \coloneqq \exists x(P(x) \land \forall y(P(y) \rightarrow x = y))
\]
\end{definition}

\subsubsection{Regeln für die eindeutige Existenz}

\paragraph{Einführungsregel für die eindeutige Existenz ($\exists! I$)}
\label{rule:UEI}

\[
\frac{
  \exists x\,P(x)
  \quad
  \begin{array}{c}
    [P(a)]\quad [P(b)] \\
    \vdots \\
    a = b 
  \end{array}
}{\exists! x\,P(x)}
\quad \exists! I
\]

\emph{Nebenbedingungen:}
\begin{itemize}
    \item \(a\) und \(b\) sind \emph{frisch} eingeführte Variablen, d.h.\ sie wurden in keinem offenen Beweisast bisher verwendet.
    \item Für die Ableitung \(a = b\) darf \(b\) nicht bereits in anderen offenen Annahmen frei vorkommen, damit man später die Annahmen schließen kann.
\end{itemize}

\paragraph{Eliminierungsregel  für die eindeutige Existenz  ($\exists! E$)}
\label{rule:UEE}


\[
\frac{
  \exists! x\,P(x)
  \quad
  \begin{array}{c}
    [P(a)]\quad [\forall y\,(P(y)\rightarrow a=y)]\\
    \vdots \\
    Q
  \end{array}
}{
  Q
}
\quad \exists! E
\]

\subsubsection{Behandlung mehrfacher Gleichheiten}
In der Praxis können Gleichheitsausdrücke mehrere Terme involvieren, wie beispielsweise \(a = b = c\). Solche Ausdrücke sind jedoch nicht direkt in der Prädikatenlogik darstellbar. Stattdessen werden sie durch eine Verkettung von binären Gleichheiten ausgedrückt, die mittels der Konjunktion \(\land\) verbunden sind. Der Ausdruck \(a = b = c\) wird somit zu \(a = b \land b = c\).

\begin{definition}
\[
\forall a, b, c \left( a = b = c \right) := \left( a = b \land b = c \right)
\]
\end{definition}

\paragraph{Einführungsregel für das Identitätssymbol dreier Gleichheiten:}
\label{rule:rIIb}

\[
\begin{array}{llll}
	i & (1) & a = b \land b = c & \dots \\
 	i & (2) & a = b = c & \rIIb{1} \\
\end{array}
\]

\[
\begin{array}{llll}
	i & (1) & a = b & \dots \\
        i & (2) & b = c & \dots \\
 	i,j & (3) & a = b = c & \rIIb{1,2} \\
\end{array}
\]

\[
\begin{array}{llll}
	i & (1) & a = b & \dots \\
        i & (2) & a = c & \dots \\
 	i,j & (3) & a = b = c & \rIIb{1,2} \\
\end{array}
\]

\(i\) und \(j\) sind dabei Listen von Annahmen.


\paragraph{Eliminierungsregel für das Identitätssymbol dreier Gleichheiten:}
\label{rule:rIEb}

\[
\begin{array}{llll}
	i & (1) & a = b = c & \dots \\
        i & (2) & a = b & \rIEb{1} \\
 	i & (3) & a = c & \rIEb{1} \\
        i & (4) & b = c & \rIEb{1} \\
\end{array}
\]

\(i\) ist dabei eine Liste von Annahmen.

\subsubsection{Direkte Anwendung von Gleichheitsregeln auf Prädikate}

Falls eine Regel oder ein Theorem mit der Bezeichnung \textit{RegelName} die Gleichheit \(a = b\) ausdrückt, gilt automatisch, dass für jedes Prädikat \(P(x)\), das entweder \(P(a)\) oder \(P(b)\) beschreibt, direkt geschlossen werden kann, dass \(P(b)\) aus \(P(a)\) folgt (und umgekehrt).

\paragraph{Formulierung:}
Falls eine Regel oder ein Theorem die Gleichheit \(a = b\) ausdrückt, so kann sie ebenso in folgendem Kontext verwendet werden:

\[
\begin{array}{llll}
	i & (1) & a = b & \text{\textit{RegelName}} \\
	i & (2) & P(a) & \dots \\
	i & (3) & P(b) & \text{\textit{RegelName}} \\
\end{array}
\]

Analog dazu:

\[
\begin{array}{llll}
	i & (1) & a = b & \text{\textit{RegelName}} \\
	i & (2) & P(b) & \dots \\
	i & (3) & P(a) & \text{\textit{RegelName}} \\
\end{array}
\]

\paragraph{Vorteile:}
- Die explizite Verwendung der Eliminierungsregel (\(\rIE{}\)) entfällt.
- Gleichheiten können direkt in Beweisen genutzt werden, wodurch Beweise kompakter und übersichtlicher werden.



\subsection{Regeln für das Nicht-Gleichheitszeichen}

\begin{definition}[Nicht-Gleichheitszeichen]
\label{rule:Neq}
\[\forall t,u(t\neq u\coloneqq \neg(t=u))\]
\end{definition}


\subsection{Vereinfachung für das Nicht-Gleichheitszeichen}
Das Symbol \(\neq\), das die Ungleichheit von Elementen darstellt, ist in seiner Bedeutung offensichtlich und direkt verständlich. Es bedeutet einfach, dass zwei Elemente nicht gleich sind. Aufgrund dieser direkten und intuitiven Bedeutung können wir in vielen Fällen auf separate Einführungs- und Eliminierungsregeln für \(\neq\) verzichten.

Die Notation \(t \neq u\) ist äquivalent zu \(\neg(t = u)\) und kann direkt verwendet werden, ohne dass eine formale Regel angewendet werden muss. Dies vereinfacht den Umgang mit der Ungleichheit in logischen Argumentationen und Beweisen.

Daher können wir in Zukunft die Verwendung von \(t \neq u\) als eine unmittelbare Folgerung von \(\neg(t = u)\) und umgekehrt ansehen, ohne explizit eine Regel anzuwenden.
\section{Metadefinition}
\subsection{Was ist eine Metadefinition?}


Wir haben bisher gezeigt, dass man \emph{Definitionen} in einem formalen Kalkül auch wie \emph{Regeln} verwenden kann: Im Beweis taucht dann etwa ein „Einführungsschritt“ auf (wenn wir von der definierten Seite zum definierenden Ausdruck wechseln wollen) oder ein „Eliminierungsschritt“ (umgekehrt).  

\medskip

\textbf{Metadefinitionen} (auch \emph{meta-sprachliche Definitionen} genannt) sind hingegen \emph{außerhalb} des eigentlichen Kalküls angesiedelt. Man kann sie sich als reine „Abkürzungsvereinbarungen“ auf der \emph{Meta-Ebene} vorstellen:

\begin{itemize}
\item Sie \emph{erweitern} nicht das formale System und werden \emph{nicht} als Inferenzregel im Beweis verwendet.
\item Stattdessen legen sie fest, dass gewisse Schreibweisen (z.\,B.\ \(\forall x \in A(P(x))\)) \emph{bloß} Kurzformen für bereits bekannte Standardformen (\(\forall x\,(x\in A \to P(x))\)) sind.
\item In der Praxis darf man solche Metadefinitionen \emph{jederzeit} und ohne gesonderte Begründung verwenden – weil sie das System nicht verändern, sondern nur unser Schreiben/Lesen vereinfachen.
\end{itemize}

\bigskip

\noindent
\textbf{Beispiel für eine Metadefinition:}  
Wir vereinbaren einmalig:
\[
t \,\neq\, u
\;\coloneqq\;
\neg\bigl(t = u\bigr).
\]
Dies sagt auf Meta-Ebene nichts anderes als: 
\enquote{Wenn wir \(a\neq b\) schreiben, meinen wir in Wahrheit \(\neg (a = b)\).}  
Daher benötigen wir keine gesonderten \emph{Einführungs-} und \emph{Eliminierungsregeln} für \(\neq\), sondern können direkt
\(t \neq u\) verwenden.  
Aus Sicht eines formalen Beweises ist das \(\neq\)-Symbol gar kein neuer Bestandteil des Kalküls, sondern nur ein bequemes Schreibkürzel.

\bigskip

\begin{remark}
\textbf{Fazit:} Ob eine Definition \emph{innerhalb} des formalen Systems (als Regel) gebraucht wird oder nur \emph{meta-sprachlich} als Schreibabkürzung, hängt davon ab, ob wir daraus im Beweis eigenständige Schritte ableiten (z.B.\ \(\to\)-Einführung) oder ob wir nur die Notation vereinfachen. 
\end{remark}

\subsection{Meta-Notation für bedingte Quantifizierung}
In vielen mathematischen Texten begegnet man Schreibweisen wie
\[
\forall x \in A(P(x))\text{ oder }\forall x \neq y(Q(x,y)).
\]
Formal bedeutet dies immer, dass \emph{vor} der Aussage eine Bedingung (z.B.\;$x\in A$ oder $x \neq y$) steht, und \emph{danach} der zu beweisende Teil (z.B.\;$P(x)$, $Q(x,y)$). Damit ist klar: ``Für alle $x$ \emph{mit} $x\in A$ gilt $P(x)$.''

\bigskip

Eine präzise Art, dies \emph{ohne} viele Einzeldefinitionen formal einzuführen, ist eine \textbf{meta-sprachliche Sammel-Definition}. 

\begin{definition}[Meta-Notation für bedingte Quantoren]
Seien $\alpha(x)$ und $\beta(x)$ zwei Formeln der Prädikatenlogik (wobei $x$ jeweils eine freie Variable sein kann). Wir \textbf{vereinbaren} folgende \emph{Schreibkürzel}:

\begin{enumerate}
  \item \[
    \forall(\alpha(x))(\beta(x))
    \quad\coloneqq\quad
    \forall x\bigl(\alpha(x)\to\beta(x)\bigr).
  \]
  \item \[
    \exists (\alpha(x))(\beta(x))
    \quad\coloneqq\quad
    \exists x\bigl(\alpha(x)\land\beta(x)\bigr).
  \]
    \item \[
    \exists! (\alpha(x))(\beta(x))
    \quad\coloneqq\quad
    \exists! x\bigl(\alpha(x)\land\beta(x)\bigr).
  \]
\end{enumerate}
%
Diese \textbf{Meta-Notation} ist nur eine abkürzende Schreibweise und erweitert die Logik \emph{nicht}: In Beweisen oder in unserem formalen Kalkül kann man jederzeit diese Ausdrücke in die Standardform (rechts) übersetzen – und umgekehrt.
\end{definition}

\subsection{Meta-Notation: Klammerwegfall bei assoziativen Operatoren}

\section{Meta-Regeln und ihre Anwendung}
\subsection{Was sind Meta-Regeln?}
\emph{Meta-Regeln} sind bereits bewiesene Theoreme oder Schlussmuster, die wir wie „fertige Werkzeuge“ nutzen. Sie \emph{erweitern} das formale System \emph{nicht}, sondern ermöglichen nur eine kürzere Beweisführung: 
\begin{itemize}
\item Nach einmaliger Nennung darf man sie an jedem passenden Ort stillschweigend verwenden.  
\item Die formale Korrektheit bleibt gewahrt, da alles auf bereits Bewiesenem beruht.
\end{itemize}

\subsection{Meta-Regeln versus formale Inferenzregeln}
\label{sec:metaRegelnVsInferenzregeln}
\begin{itemize}
\item \textbf{Formale Inferenzregeln} (z.B.\ $\land$-Einführung) beschreiben direkt zulässige Beweisschritte.
\item \textbf{Meta-Regeln} sagen nur, dass bereits Bewiesenes \emph{wie ein abgekürztes Argument} wiederverwendet werden darf.  
\end{itemize}

\subsection{Vorgehen in der Praxis}
In fortgeschrittenen Texten werden Meta-Regeln oft am Kapitel- oder Beweisanfang angekündigt und dann nur noch per Verweis benutzt, um Dopplungen zu vermeiden. Dies macht komplexe Beweise kürzer und übersichtlicher, ohne an formaler Strenge einzubüßen.


\end{document}