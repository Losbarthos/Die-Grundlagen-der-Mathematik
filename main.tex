% main.tex (optimiert für schnelleres Kompilieren)
\documentclass{book}

% --- Packages ---
\usepackage{subfiles}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage{thmtools}
\usepackage{etoolbox}
\usepackage{longtable}
\usepackage{xparse}       % für NewDocumentCommand
\usepackage{imakeidx}
\usepackage{bussproofs}
\usepackage{multirow}
\usepackage{makecell}   % für \makecell
\usepackage[nameinlink,capitalise]{cleveref}
\usepackage{array} % <- nötig für >{$}l<{$} in longtable


\MakeAutoQuote{„}{“}
\hypersetup{
  bookmarksopen=false,
  bookmarksnumbered=true
}

% Optionaler Turbo-Draft-Schalter (keine Syntaxänderung an deinem Dokument notwendig)
\newif\iffastcompile
% \fastcompiletrue % <- bei Bedarf für schnelle Drafts aktivieren
\iffastcompile
  \usepackage[draft]{hyperref}
  \microtypesetup{activate=false}
\fi

\input{commands.tex}

% -------------------------------
% Datei-Zähler und Theorem-Zähler
% -------------------------------
\newcounter{file}

% Theorem
\newcounter{theoremInFile}[file]
\renewcommand{\thetheoremInFile}{\arabic{file}.\arabic{theoremInFile}}
\newtheorem{theorem}[theoremInFile]{Theorem}

% Definition
\newcounter{definitionInFile}[file]
\renewcommand{\thedefinitionInFile}{\arabic{file}.\arabic{definitionInFile}}
\newtheorem{definition}[definitionInFile]{Definition}

% Axiom
\newcounter{axiomInFile}[file]
\renewcommand{\theaxiomInFile}{\arabic{file}.\arabic{axiomInFile}}
\newtheorem{axiom}[axiomInFile]{Axiom}

% Weitere Umgebungen, falls benötigt:
\newtheorem{corollary}[theoremInFile]{Korollar}
\newtheorem{lemma}[theoremInFile]{Lemma}
\newtheorem{hilfsdefinition}[theoremInFile]{Hilfsdefinition}
\newtheorem{tempdefinition}[theoremInFile]{Temporäre Definition}

% Unnummerierte Umgebungen
\theoremstyle{remark}
\newtheorem*{remark}{Bemerkung}
\newtheorem*{bemerkung}{Bemerkung}
\newtheorem*{example}{Beispiel}
\newtheorem*{hint}{Hinweis}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{notation*}{Notation}

% Kürzere Namen für Referenzen
\crefname{theorem}{Thm}{Thms}
\Crefname{theorem}{Thm}{Thms}

\crefname{definition}{Def}{Defs}
\Crefname{definition}{Def}{Defs}

\crefname{axiom}{Ax}{Axs}
\Crefname{axiom}{Ax}{Axs}


\makeindex[name=satz,title=Sätze und Definitionen zu diesem Kapitel]

% -------------------------------
% Schneller Label-Sanitizer (expl3 + Cache)
% Ergebnis wie bisher in \temp
% -------------------------------
\ExplSyntaxOn
\prop_new:N \g__sanitize_cache_prop
\tl_new:N   \l__sanitize_work_tl

\cs_new_protected:Npn \sanitize #1
  {
    % Cache-Hit?
    \prop_get:NnNTF \g__sanitize_cache_prop {#1} \l__sanitize_work_tl
      { \tl_set_eq:NN \temp \l__sanitize_work_tl }
      {
        % Cache-Miss: berechnen
        \tl_set:Nx \l__sanitize_work_tl { \detokenize{#1} }

        % ---- Mathematische Schriftarten
        \regex_replace_all:nnN { \\mathcal } { mathcal } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\mathbb }   { mathbb }  \l__sanitize_work_tl
        \regex_replace_all:nnN { \\mathrm }   { rm }      \l__sanitize_work_tl

        % ---- Logische Verknüpfungen
        \regex_replace_all:nnN { \\leftrightarrow } { Equiv } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\rightarrow }      { Imp }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\eqvdash }         { Eqvboth }\l__sanitize_work_tl
        \regex_replace_all:nnN { \\dashv }           { DashV } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\vdash }           { Vdash } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\iff }             { Iff }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\land }            { And }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\lor }             { Or }    \l__sanitize_work_tl
        \regex_replace_all:nnN { \\neg }             { Neg }   \l__sanitize_work_tl

        % ---- Quantoren und Mengen
        \regex_replace_all:nnN { \\forall }  { Forall } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\exists }  { Exists } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\iota }    { Iota }   \l__sanitize_work_tl

        % ---- Relationen und Operatoren
        \regex_replace_all:nnN { :\= }       { Defeq }    \l__sanitize_work_tl
        \regex_replace_all:nnN { \= }        { Eq }       \l__sanitize_work_tl
        \regex_replace_all:nnN { \\neq }     { Neq }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\notin }     { Notin }    \l__sanitize_work_tl
        \regex_replace_all:nnN { \\in }      { In }       \l__sanitize_work_tl
        \regex_replace_all:nnN { \\subseteq }{ Subseteq } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\times }   { Times }    \l__sanitize_work_tl


        % ---- Mengenoperationen
        \regex_replace_all:nnN { \\emptyset } { Emptyset } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\bigcup }   { Bigcup }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\cup }      { Cup }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\cap }      { Cap }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\bigcap }   { Bigcap }   \l__sanitize_work_tl
        \regex_replace_all:nnN { \\mid }      { Mid }      \l__sanitize_work_tl
        \regex_replace_all:nnN { \\setminus } { Setminus } \l__sanitize_work_tl

        % ---- Zahlen
        \regex_replace_all:nnN { \_ }  { Index } \l__sanitize_work_tl
        \regex_replace_all:nnN { 0 }   { Null }  \l__sanitize_work_tl
        \regex_replace_all:nnN { 1 }   { One }   \l__sanitize_work_tl
        \regex_replace_all:nnN { 2 }   { Two }   \l__sanitize_work_tl
        \regex_replace_all:nnN { 3 }   { Three } \l__sanitize_work_tl
        \regex_replace_all:nnN { 4 }   { Four }  \l__sanitize_work_tl

        % ---- Klammern (literale Zeichen)
        \regex_replace_all:nnN { \x{28} } { Lp } \l__sanitize_work_tl % (
        \regex_replace_all:nnN { \x{29} } { Rp } \l__sanitize_work_tl % )
        \regex_replace_all:nnN { \\bigl|\\bigr|\\Bigl|\\Bigr } { } \l__sanitize_work_tl

        % ---- Störendes entfernen
        \regex_replace_all:nnN { \\begin | \\end } { } \l__sanitize_work_tl
        \regex_replace_all:nnN { aligned }         { } \l__sanitize_work_tl
        \regex_replace_all:nnN { [\{\}] }          { } \l__sanitize_work_tl
        \regex_replace_all:nnN { \\\\ }            { } \l__sanitize_work_tl
        \regex_replace_all:nnN { [\ \t] }          { } \l__sanitize_work_tl
        \regex_replace_all:nnN { \& }              { } \l__sanitize_work_tl
        % ---- Abstands-/Trenn-Kommandos und verbleibende Backslashes entfernen
        \regex_replace_all:nnN { \\\, } {} \l__sanitize_work_tl  % \,
        \regex_replace_all:nnN { \\\; } {} \l__sanitize_work_tl  % \;
        \regex_replace_all:nnN { \\\: } {} \l__sanitize_work_tl  % \:
        \regex_replace_all:nnN { \\\! } {} \l__sanitize_work_tl  % \!
        \regex_replace_all:nnN { \\quad } {} \l__sanitize_work_tl
        \regex_replace_all:nnN { \\qquad } {} \l__sanitize_work_tl
        \regex_replace_all:nnN { \\~ } {} \l__sanitize_work_tl   % \~ (geschütztes Leerzeichen)
        \regex_replace_all:nnN { \\\x{20} } {} \l__sanitize_work_tl % Backslash + Space
        % am Ende: alle übrigen Backslashes killen (Sicherheitsnetz)
        \regex_replace_all:nnN { \\ } {} \l__sanitize_work_tl

        % ---- Sonstiges
        \regex_replace_all:nnN { , }               { Comma } \l__sanitize_work_tl

        % Ergebnis bereitstellen + cachen
        \tl_set_eq:NN \temp \l__sanitize_work_tl
        \prop_gput:NnV \g__sanitize_cache_prop {#1} \temp
      }
  }
\ExplSyntaxOff

\makeatletter
\newcommand{\debugsanitize}[1]{%
  \def\tempa{#1}%
  \expandafter\sanitize\expandafter{\tempa}%
  \typeout{Ergebnis von sanitize: [\temp]}%
}
\makeatother

% ========= Stabile Auto-Labels via prop-Cache (ohne \csname-Tricks) =====
\ExplSyntaxOn

% Guarded: Cache/Temporaries nur einmal anlegen
\prop_if_exist:NF \g__ref_cache_prop { \prop_new:N \g__ref_cache_prop }
\tl_if_exist:NF   \l__ref_raw_tl     { \tl_new:N   \l__ref_raw_tl     }
\tl_if_exist:NF   \l__ref_result_tl  { \tl_new:N   \l__ref_result_tl  }

% --- Hilfsfunktion: ersten Treffer eines Präfixes (thm/def/ax) in allen Dateien
\cs_new_protected:Npn \__ref_find:nn #1#2
  {
    \tl_clear:N \l__ref_result_tl
    \int_step_inline:nn { \value{maxfile} }
      {
        \exp_args:Nx \cs_if_exist:cTF { r@#1##1_#2 }
          { \tl_set:Nx \l__ref_result_tl { #1##1_#2 } \prg_break: }
          { }
        \prg_break_point:
      }
  }

% --- Beim Anlegen: Key -> volles Label in Cache schreiben, aber NIE überschreiben
\cs_new_protected:Npn \__cache_put_once:nn #1#2
  {
    % #1 = sanitized key (als String), #2 = volles Label (z.B. thm3_<...>)
    \prop_if_in:NnF \g__ref_cache_prop {#1}
      { \prop_gput:Nnn \g__ref_cache_prop {#1} {#2} }
  }

\ExplSyntaxOn
% --- Key normalisieren: stringifizieren + Spaces trimmen
\cs_new_protected:Npn \__normalize_key:Nn #1#2
  {
    \tl_set:Nx \l_tmpa_tl {#2}              % 1x expandieren (macht aus \lab -> Inhalt)
    \tl_set:Nx #1 { \tl_to_str:V \l_tmpa_tl }% dann den expandierten Inhalt in String wandeln
    \tl_trim_spaces:N #1
  }

% --- Cache: put-once mit normalisiertem Key
\cs_new_protected:Npn \__cache_put_once_norm:nn #1#2
  {
    \tl_clear_new:N \l__ref_key_norm_tl
    \__normalize_key:Nn \l__ref_key_norm_tl {#1}
    \prop_if_in:NVF \g__ref_cache_prop \l__ref_key_norm_tl
      { \prop_gput:NVx \g__ref_cache_prop \l__ref_key_norm_tl {#2} }
  }
\ExplSyntaxOff



\ExplSyntaxOn

% ====================== Theorem / Definition / Axiom =====================
\NewDocumentCommand{\FormulaThmAuto}{o m o}
  {
    \sanitize{#2}
    \edef\lab{\temp}
    \edef\labFull{thm\arabic{file}_\lab}
    \__cache_put_once_norm:nn { \lab } { \labFull }



    \IfNoValueTF{#1}
      {\begin{theorem}\label{\labFull}}
      {\begin{theorem}[#1]\label{\labFull}}%
    \IfNoValueF{#3}{#3\par\medskip}%
    \[
      #2
    \]
    \end{theorem}%
  }

\NewDocumentCommand{\FormulaDefAuto}{o m o}
  {
    \sanitize{#2}
    \edef\labD{\temp}
    \edef\labFullD{def\arabic{file}_\labD}
    \__cache_put_once_norm:nn { \labD } { \labFullD }



    \IfNoValueTF{#1}
      {\begin{definition}\label{\labFullD}}
      {\begin{definition}[#1]\label{\labFullD}}%
    \IfNoValueF{#3}{#3\par\medskip}%
    \[
      #2
    \]
    \end{definition}%
  }

\NewDocumentCommand{\FormulaAxiomAuto}{o m o}
  {
    \sanitize{#2}
    \edef\labA{\temp}
    \edef\labFullA{ax\arabic{file}_\labA}
    \__cache_put_once_norm:nn { \labA } { \labFullA }


    \IfNoValueTF{#1}
      {\begin{axiom}\label{\labFullA}}
      {\begin{axiom}[#1]\label{\labFullA}}%
    \IfNoValueF{#3}{#3\par\medskip}%
    \[
      #2
    \]
    \end{axiom}%
  }

% =========================== Referenz-Makro ==============================
% \FormulaRefAuto{<Formel>}[<explizites Präfix>]{<Zusatz>}
\ExplSyntaxOn
\NewDocumentCommand{\FormulaRefAuto}{m o g}
  {
    % Key bilden + normalisieren
    \edef\tempa{\unexpanded{#1}}
    \expandafter\sanitize\expandafter{\tempa}
    \edef\lab{\temp}
    \tl_clear_new:N \l__ref_raw_tl
    \__normalize_key:Nn \l__ref_raw_tl { \lab }

    % Expliziter Präfix -> direkte Referenz
    \IfNoValueF{#2}
      {
        \edef\labFull{#2_\lab}
        \IfNoValueTF{#3}
          { \mode_if_math:TF { \hyperref[\labFull]{\text{\cref*{\labFull}}} } { \hyperref[\labFull]{\cref*{\labFull}} } }
          { \mode_if_math:TF { \hyperref[\labFull]{\text{\cref*{\labFull}(#3)}} } { \hyperref[\labFull]{\cref*{\labFull}(#3)} } }
        \use_none:
      }

    % 1) Cache first (stabil: first wins)
    \prop_get:NVNTF \g__ref_cache_prop \l__ref_raw_tl \l_tmpa_tl
      {
        \edef\labFull{\l_tmpa_tl}
        \IfNoValueTF{#3}
          { \mode_if_math:TF { \hyperref[\labFull]{\text{\cref*{\labFull}}} } { \hyperref[\labFull]{\cref*{\labFull}} } }
          { \mode_if_math:TF { \hyperref[\labFull]{\text{\cref*{\labFull}(#3)}} } { \hyperref[\labFull]{\cref*{\labFull}(#3)} } }
      }
      {
        % 2) Live-Suche thm -> def -> ax
        \__ref_find:nn {thm}{\lab}
        \tl_if_empty:NT \l__ref_result_tl { \__ref_find:nn {def}{\lab} }
        \tl_if_empty:NT \l__ref_result_tl { \__ref_find:nn {ax}{\lab} }
        \tl_if_empty:NTF \l__ref_result_tl
          { \text{[??]} }
          {
            \edef\labFull{\l__ref_result_tl}
            % einmalig in Cache legen (first wins)
            \prop_if_in:NVF \g__ref_cache_prop \l__ref_raw_tl
              { \prop_gput:NVx \g__ref_cache_prop \l__ref_raw_tl {\labFull} }
            \IfNoValueTF{#3}
              { \mode_if_math:TF { \hyperref[\labFull]{\text{\cref*{\labFull}}} } { \hyperref[\labFull]{\cref*{\labFull}} } }
              { \mode_if_math:TF { \hyperref[\labFull]{\text{\cref*{\labFull}(#3)}} } { \hyperref[\labFull]{\cref*{\labFull}(#3)} } }
          }
      }
  }
\ExplSyntaxOff

% =========================== Debug: nur Log-Ausgabe ======================
\NewDocumentCommand{\debugrefcache}{m}{
  \sanitize{#1}
  \iow_log:x { ===~Cache-Abfrage~für~Key:~[\tl_to_str:N \temp] }
  \prop_get:NnNT \g__ref_cache_prop {\temp} \l_tmpa_tl
    { \iow_log:x { -->~Cache-Eintrag~gefunden:~[\tl_to_str:N \l_tmpa_tl] } }
}

\NewDocumentCommand{\dumprefcache}{}{
  \iow_log:x { ===~Aktueller~Inhalt~von~g__ref_cache_prop~=== }
  \prop_map_inline:Nn \g__ref_cache_prop { \iow_log:x { *~##1~=>~##2 } }
  \iow_log:x { ===~Ende~Cache~=== }
}

\ExplSyntaxOff
\makeatletter
\newcounter{maxfile}
\setcounter{maxfile}{4} % <- Anzahl deiner Dateien
\makeatother

% -------------------------------
% Beweisumgebungen (seitenumbruchfähig)
% -------------------------------
\newcounter{proofstepnr}

% Ersatz für tabproof: Beweis-Kopf selbst setzen, longtable auf Top-Level
\newenvironment{tabproof}{
  \par\noindent\textit{Beweis.}\par\medskip
  \setcounter{proofstepnr}{0}%
  \begingroup
  \setlength{\tabcolsep}{0pt}%
  \begin{longtable}{@{}l r >{$}l<{$} >{$}l<{$}@{}}
}{
  \end{longtable}%
  \endgroup
  \par\hfill\qedsymbol\par
}

% Gesplittete Variante mit \proofpart ... \closeproofpart
\newenvironment{tabproofsplit}
  {\begin{proof}}
  {\end{proof}}

\newcommand{\proofpart}[1]{%
  \par\medskip\noindent #1:\par%
  \setcounter{proofstepnr}{0}%
  \begingroup
  \setlength{\tabcolsep}{0pt}%
  \begin{longtable}{@{}l r >{$}l<{$} >{$}l<{$}@{}}
}

\newcommand{\closeproofpart}{%
  \end{longtable}%
  \endgroup
}

\newcommand{\proofstep}[3]{%
  \stepcounter{proofstepnr}%
  #1 & (\arabic{proofstepnr}) & #2 & #3\\%
}



\newcommand{\proofstepstar}[3]{%
  #1 & & #2 & #3\\%
}

% Case-Überschrift (hast du schon ähnlich)
\newcommand{\proofcase}[2][]{%
  & & \text{\bfseries Fall\if\relax#1\relax\else~#1\fi: } #2 & \\[-.35ex]%
}

% Case-Schlusszeile über alle Spalten 3–4 (kein multicolumn nötig)
\newcommand{\proofcasesummary}[2][]{%
  & & \text{\bfseries Schluss\if\relax#1\relax\else~ Fall~#1\fi: } #2 & \\[-.35ex]%
}

% (optional) dünne Trennlinie unter einem Fallblock
\newcommand{\proofcaserule}{\cline{3-4}\noalign{\vspace{-0.3ex}}}

% --- Breitere Variante (wide) mit 6 Spalten: leer | (Nr) | Term1 | Op | Term2 | Rechtfertigung
\newenvironment{tabproofwide}{
  \par\noindent\textit{Beweis.}\par\medskip
  \setcounter{proofstepnr}{0}%
  \begingroup
  \setlength{\tabcolsep}{0pt}%
  \begin{longtable}{@{}l r >{$}l<{$} >{$}c<{$} >{$}l<{$} >{$}l<{$}@{}}
}{
  \end{longtable}%
  \endgroup
  \par\hfill\qedsymbol\par
}

\newenvironment{tabproofsplitwide}
  {\begin{proof}}
  {\end{proof}}

\newcommand{\proofpartwide}[1]{%
  \par\medskip\noindent #1:\par%
  \setcounter{proofstepnr}{0}%
  \begingroup
  \setlength{\tabcolsep}{0pt}%
  \begin{longtable}{@{}l r >{$}l<{$} >{$}c<{$} >{$}l<{$} >{$}l<{$}@{}}
}

\newcommand{\closeproofpartwide}{%
  \end{longtable}%
  \endgroup
}


\NewDocumentCommand{\proofstepwide}{s o m m m m}{%
  \IfBooleanTF{#1}{%
    \IfNoValueTF{#2}
      { & & #3 & #4 & #5 & #6\\}
      { #2 & & #3 & #4 & #5 & #6\\}
  }{%
    \stepcounter{proofstepnr}%
    \IfNoValueTF{#2}
      { & (\arabic{proofstepnr}) & #3 & #4 & #5 & #6\\}
      { #2 & (\arabic{proofstepnr}) & #3 & #4 & #5 & #6\\}
  }%
}

\NewDocumentCommand{\proofstepwidestar}{o m m}{%
  \stepcounter{proofstepnr}%
  \IfNoValueTF{#1}
    { & (\arabic{proofstepnr}) & \multicolumn{3}{>{$}l<{$}}{#2} & #3\\}
    { #1 & (\arabic{proofstepnr}) & \multicolumn{3}{>{$}l<{$}}{#2} & #3\\}
}


% ==== Abschnittstitel sammeln (alle Ebenen) ====
\ExplSyntaxOn
\seq_new:N \g__mx_sectioning_seq

% Anzeigename für Level
\cs_new:Npn \mx_level_label:n #1
  {
    \str_case:nnF {#1}
      {
        {part}          {Part}
        {chapter}       {Chapter}
        {section}       {Section}
        {subsection}    {Subsection}
        {subsubsection} {Subsubsection}
        {paragraph}     {Paragraph}
        {subparagraph}  {Subparagraph}
      }
      {#1}
  }

% the<counter> oder leer
\cs_new:Npn \mx_the_counter_or_empty:n #1
  { \cs_if_exist:cTF { the#1 } { \use:c { the#1 } } { } }

% Eintrag speichern
\cs_new_protected:Npn \mx_store_entry:nnn #1#2#3
  { \seq_gput_right:Nn \g__mx_sectioning_seq { #1~#2:~#3 } }

% Einen Abschnittsbefehl patchen (nur wenn er existiert)
\cs_new_protected:Npn \mx_patch_one:n #1
  {
    \cs_if_exist:cT {#1}
      {
        \cs_new_eq:cc { mx_old_#1 } { #1 }
        \exp_args:Nc \RenewDocumentCommand {#1} { s o m }
          {
            \IfBooleanTF{##1}
              {
                \use:c { mx_old_#1 } * {##3}
                \mx_store_entry:nnn { \mx_level_label:n {#1} } {*} {##3}
              }
              {
                \IfNoValueTF{##2}
                  { \use:c { mx_old_#1 } {##3} }
                  { \use:c { mx_old_#1 } [##2] {##3} }
                \mx_store_entry:nnn
                  { \mx_level_label:n {#1} }
                  { \mx_the_counter_frozen:n {#1} } % <— HIER die neue Funktion
                  { ##3 }
              }
          }
      }
  }

% Alle Ebenen abarbeiten
\clist_map_inline:nn
  { part, chapter, section, subsection, subsubsection, paragraph, subparagraph }
  { \mx_patch_one:n {#1} }

% Ausgabe-Kommando
\NewDocumentCommand \ShowSectioningList {} {
  \iow_term:x { ==== Gesammelte Abschnittstitel ==== }
  \seq_map_inline:Nn \g__mx_sectioning_seq { \iow_term:n {##1} }
  \par\bigskip
  \textbf{Gesammelte Abschnittstitel}\\
  \seq_use:Nn \g__mx_sectioning_seq { \\ }
}
\ExplSyntaxOff
% ==== Ende Abschnittstitel-Sammler ====

% -------------------------------
% Dokumentstart
% -------------------------------
\setcounter{file}{3}





\begin{document}

\title{}
\author{}
\date{}


\part{Bd. 01 - Grundlagen der Logik: Eine Einführung in Theorie und Basiskonzepte}
\subfile{B01} 
\part{Bd. 02 - Theoreme der Logik: Vertiefte Beweise und Methoden}
\subfile{B02} 
\part{Bd. 03 - Mengenlehre}
\subfile{B03} 




\end{document}

/* Beispiele 

\FormulaThmAuto[Assoziativgesetz Oder-Verknüpfung]{P \lor (Q \lor R) \eqvdash (P \lor Q) \lor R}
\begin{tabproofsplit}
  \proofpart{$\vdash$}
    \proofstep{1}{P \lor (Q \lor R)}{\rA}
    \proofstep{2}{P}{\rA}
    \proofstep{2}{P \lor Q}{\rOIa{2}}
    \proofstep{2}{(P \lor Q) \lor R}{\rOIa{3}}
    \proofstep{5}{Q \lor R}{\rA}
    \proofstep{6}{Q}{\rA}
    \proofstep{6}{P \lor Q}{\rOIb{6}}
    \proofstep{6}{(P \lor Q) \lor R}{\rOIa{7}}
    \proofstep{9}{R}{\rA}
    \proofstep{9}{(P \lor Q) \lor R}{\rOIb{9}}
    \proofstep{5}{(P \lor Q) \lor R}{\rOE{5,6,8,9,10}}
    \proofstep{1}{(P \lor Q) \lor R}{\rOE{1,2,4,5,11}}
  \closeproofpart

  \proofpart{$\dashv$}
    \proofstep{1}{(P \lor Q) \lor R}{\rA}
    \proofstep{2}{P \lor Q}{\rA}
    \proofstep{3}{P}{\rA}
    \proofstep{3}{P \lor (Q \lor R)}{\rOIa{3}}
    \proofstep{5}{Q}{\rA}
    \proofstep{5}{Q \lor R}{\rOIa{5}}
    \proofstep{5}{P \lor (Q \lor R)}{\rOIb{6}}
    \proofstep{2}{P \lor (Q \lor R)}{\rOE{2,3,4,5,7}}
    \proofstep{9}{R}{\rA}
    \proofstep{9}{Q \lor R}{\rOIb{9}}
    \proofstep{9}{P \lor (Q \lor R)}{\rOIb{10}}
    \proofstep{1}{P \lor (Q \lor R)}{\rOE{1,2,8,9,11}}
  \closeproofpart
\end{tabproofsplit}

\FormulaThmAuto{A \subseteq B \vdash A \cap C \subseteq B \cap C}
\begin{tabproof}
  \proofstep{1}{A \subseteq B}{\rA}
  \proofstep{2}{x \in A \cap C}{\rA}
  \proofstep{2}{x \in A}{\FormulaRefAuto{x \in A \cap B \vdash x \in A}{2}}
  \proofstep{2}{x \in C}{\FormulaRefAuto{x \in A \cap B \vdash x \in B}{2}}
  \proofstep{1,2}{x \in B}{\FormulaRefAuto{A \subseteq B,\, x \in A \vdash x \in B}{1,3}}
  \proofstep{1,2}{x \in B \cap C}{\FormulaRefAuto{x \in A \cap B \eqvdash x \in A \land x \in B}{\rAI{5,4}}}
  \proofstep{1}{A \cap C \subseteq B \cap C}{\FormulaRefAuto{A \subseteq B := \forall x\,(x \in A \rightarrow x \in B)}{\rUI{\rRI{2,6}}}}
\end{tabproof}


\FormulaThmAuto{A \subseteq B \eqvdash A \cap B = A}
\begin{tabproofsplitwide}
  \proofpartwide{\(\vdash\)}
    \proofstepwidestar[1]{A \subseteq B}{\rA}
    \proofstepwidestar[]{A \cap B \subseteq A}{\FormulaRefAuto{A \cap B \subseteq A}}
    \proofstepwide{A}{=}{A \cap A}{\FormulaRefAuto{A = A \cap A}}
    \proofstepwide[1]{}{\subseteq}{A \cap B}{\FormulaRefAuto{A \subseteq B \vdash A \cap C \subseteq B \cap C}{1}}
    \proofstepwide[1]{A}{\subseteq}{A \cap B}{\rChain{3,4}}
    \proofstepwide[1]{A \cap B}{=}{A}{\FormulaRefAuto{A \subseteq B \land B \subseteq A \eqvdash A = B}{\rAI{2,5}}}
  \closeproofpartwide

  \proofpartwide{\(\dashv\)}
    \proofstepwidestar[1]{A \cap B = A}{\rA}
    \proofstepwide[1]{A}{\subseteq}{A \cap B}{\rAEb{\FormulaRefAuto{A \subseteq B \land B \subseteq A \eqvdash A = B}{1}}}
    \proofstepwide[1]{A \cap B}{\subseteq}{B}{\FormulaRefAuto{A \cap B \subseteq B}}
    \proofstepwide[1]{A}{\subseteq}{B}{\FormulaRefAuto{A \subseteq B, B \subseteq C \vdash A \subseteq C}{2,3}}
  \closeproofpartwide
\end{tabproofsplitwide}

\FormulaThmAuto{P(A) \vdash x \in \bigcap_{P(B)} B \leftrightarrow \forall C\, (P(C) \rightarrow x \in C)}
\begin{tabproofwide}
  \proofstepwidestar[1]{P(A)}{\rA}
  \proofstepwidestar[2]{\forall C\, (P(C)\rightarrow x\in C)}{\rA}
  \proofstepwidestar[]{\forall C\, (P(C)\rightarrow x\in C) \rightarrow x\in A}{\rRI{2,\FormulaRefAuto{P(a), \forall x\, (P(x) \rightarrow Q(x)) \vdash Q(a)}{1,2}}}
  \proofstepwide[1]{x\in \bigcap_{P(B)} B}{\leftrightarrow}{x\in I_A}{\rUE{\FormulaRefAuto{\forall x\, (x \in A \leftrightarrow x \in B) \eqvdash A = B}{\FormulaRefAuto{P(A) \vdash \bigcap_{P(B)} B = \{ x \in A \mid \forall D\, (P(D) \rightarrow x \in D) \}}{1}}}}
  \proofstepwide[1]{}{\leftrightarrow}{x\in A \land \forall C\, (P(C)\rightarrow x\in C)}{\FormulaRefAuto{\{x\in A \,\mid\, P(x)\} := \iota B\bigl(\forall x\,(x\in B \leftrightarrow (x\in A \land P(x)))\bigr)}{\rIE{\rUE{\DefBigcapLbAMidPLpARpRbMidSubB{}},4}}}
  \proofstepwide[1]{}{\leftrightarrow}{\forall C\, (P(C)\rightarrow x\in C)}{\FormulaRefAuto{P \rightarrow Q \vdash P \leftrightarrow (Q \land P)}{3}}
  \proofstepwide[1]{x\in \bigcap_{P(B)} B}{\leftrightarrow}{\forall C\, (P(C)\rightarrow x\in C)}{\rChain{4,6}}
\end{tabproofwide}

\FormulaThmAuto{A \subseteq C,\, B \subseteq C \vdash A \cup B \subseteq C}
\begin{tabproofwide}
  \proofstepwidestar[1]{A \subseteq C}{\rA}
  \proofstepwidestar[2]{B \subseteq C}{\rA}
  \proofstepwide{z \in A \cup B}{\rightarrow}{z \in A \lor z \in B}%
    {\FormulaRefAuto{z \in A \cup B \eqvdash z \in A \lor z \in B}}
  \proofstepwide[1,2]{}{ \rightarrow}{z \in C}%
    {\FormulaRefAuto{P \rightarrow Q,\, R \rightarrow Q,\, P \lor R \vdash Q}%
      {\rUE{\FormulaRefAuto{A \subseteq B := \forall x\,(x\in A \rightarrow x\in B)}{1}},%
       \rUE{\FormulaRefAuto{A \subseteq B := \forall x\,(x\in A \rightarrow x\in B)}{2}},3}}
  \proofstepwide[1,2]{z \in A \cup B}{\rightarrow}{z \in C}%
    {\rChain{3,4}}
  \proofstepwidestar[1,2]{A \cup B \subseteq C}%
    {\FormulaRefAuto{A \subseteq B := \forall x\,(x\in A \rightarrow x\in B)}{\rUI{5}}}
\end{tabproofwide}


*/